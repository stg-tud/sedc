<!DOCTYPE html><html><head><meta charset='utf-8'><meta name=generator content='LectureDoc'>
	
	<!-- START [HEADER] - Automatically inserted by LectureDoc in generated HTML files.  -->	
	<script src="Library/Mousetrap-1.4.4/mousetrap.min.js" type="text/javascript"></script>
	<script src="Library/Mousetrap-1.4.4/mousetrap-pause.min.js" type="text/javascript"></script>
	<script src="Library/Gator-0.8/gator.min.js" type="text/javascript"></script>
	<script src="Library/Gator-0.8/gator-pause.js" type="text/javascript"></script>

	<script src="Library/Timeline-1.0.0/Timeline.js" type="text/javascript"></script>
	<link href="Library/Timeline-1.0.0/Timeline.css" type="text/css" rel="stylesheet">

    <script src="Library/MultipleChoice-1.0.0/MultipleChoice.js" type="text/javascript"></script>
    <link href="Library/MultipleChoice-1.0.0/MultipleChoice.css" type="text/css" rel="stylesheet">
		
	<link rel="stylesheet" href="Library/highlight.js-7.3.0/styles/default.css">
	<script src="Library/highlight.js-7.3.0/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>	
		
	<link href="Library/LectureDoc/css/LectureDoc.css" type="text/css" rel="stylesheet">
	<script src="Library/LectureDoc/LectureDoc.js" type="text/javascript"></script>
	<!-- END -->

</head><body data-ldjs-last-modified="1380527398000">
<div id='body-content'>
<section class="slide"><div class="section-body"><h1>Software Engineering</h1>
<h2>Design &amp; Construction</h2>
<p><strong>Winter Semester 2013/2014</strong></p>
<p><img src="Images/STG-logo.jpg" alt="Software Technology Group" /><br />
<strong>Department of Computer Science</strong><br />
<strong>Technische Universität Darmstadt</strong></p>
<ul>
<li><strong><a href="&lt;mailto:eichberg@informatik.tu-darmstadt.de&gt;">Dr. Michael Eichberg</a></strong></li>
<li><a href="&lt;mailto:amann@st.informatik.tu-darmstadt.de&gt;">Sven Amann</a> </li>
</ul>
</div></section>
<p><strong>Copyright 2014</strong></p>
<p>This script is primarily written by Dr. Michael Eichberg. It contains material created by Prof. Dr. Mira Mezini and others. However, all typos, issues and errors are the sole responsibility of Michael Eichberg. </p>
<p>The content of this script – slides and additional material - is relevant for the exam.</p>
<h1>Organization</h1>
<section class="slide" data-title="Organization"><div class="section-body"><h1>Organization</h1>
<h2>Overview</h2>
<ul>
<li>We will have a written exam on February 18th, 2014. The exam will start at 2:00pm and will last 90 minutes. The exam will be in S206/030.</li>
<li>We will have between 10 and 12 Exercises.</li>
<li>By doing the exercises you can get a bonus for the exam.</li>
</ul>
</div></section>
<h2>Exam</h2>
<p>The exam will take 90 minutes and will be an open book exam; i.e., you are allowed to use all written material, but no electronic devices.</p>
<h2>Exercise</h2>
<p>We will have one exercise per week and doing the exercises is highly recommended. The exercises are considered to be an essential part of this lecture and will help you to foster your understanding of software design principles.
The programming language that may be used for some exercises and some parts of the lecture is Scala 2.10 (<a href="http://www.scala-lang.org">http://www.scala-lang.org</a>).<br /></p>
<p>The obligatory Hello World example:</p>
<pre><code class="scala">object Demo extends App {
	println(&quot;This is scala!&quot;)
}
</code></pre>
<p>The content of the exercise is relevant for the final exam. </p>
<p>The exercises are organized by <strong>Sven Amann</strong> and <strong>Oliver Bracevac</strong>.</p>
<h2>Bonus</h2>
<p>By successfully completing the exercise, you can get a maximum bonus that is equal to one full grade. You need to get at least 30% of all possible exercise points to get some bonus. I.e., just completing one exercise is not sufficient. To get the full bonus, you just need to get at least 90% of all possible exercise points. The maximum bonus is equivalent to one full grade.</p>
<p><em>The bonus cannot be used to pass the exam.</em></p>
<p>This bonus system complies with the regulations defined in the &quot;4. Novelle der APB §25(2) vom 2.10.2012&quot;.</p>
<h2>Content</h2>
<p>The goal of this lecture is to teach you fundamental software design principles that will foster your understanding of the intricacy when developing software and which will also help you to become a better software engineer. </p>
<section class="slide" data-title="Main Topics"><div class="section-body"><h1>Topics of the Lecture</h1>
<ul>
<li>What does it mean to develop &quot;Software&quot;?</li>
<li>(Software) Design Principles</li>
<li>Advanced Programming Language Features</li>
</ul>
</div></section>
<section class="slide" data-title="Goals of the Lecture"><div class="section-body"><h1>Goals of the Lecture</h1>
<ul>
<li>To learn to judge the design of existing pieces of software</li>
<li>To learn to produce “good” designs; i.e. to produce code that is, e.g., reusable, maintainable, comprehensible, ...</li>
<li>To understand the relation between design and programming languages</li>
<li>To get familiar with advanced programming language features and to learn when to apply them</li>
<li>To get a deeper and thorough understanding of design patterns</li>
<li>To understand why improvements of programming languages are important</li>
<li>To understand programming language concepts w.r.t. supporting high-level design</li>
</ul>
<p>After successfully completing this lecture you should be to develop software that is well designed and which uses (advanced) programming language features to support the design.</p>
</div></section>
<hr />
<h1>The Birth of Software Engineering</h1>
<section class="slide" data-title="The Birth of Software Engineering"><div class="section-body"><h1>Software Engineering Timeline</h1>
<p><strong>Impressions from the NATO Software Engineering Conferences</strong></p>
<p><img src="Images/Nato-SEConference1.jpg" alt="The NATO Software Engineering Conference" />
<img src="Images/Nato-SEConference2.jpg" alt="The NATO Software Engineering Conference" /></p>
<svg id="Software-Engineering-Timeline" class="timeline">

</svg>  
<script type="text/javascript">
	Timeline.draw("Software-Engineering-Timeline",[
		{d:"1960th",t:"Software Crisis"},
		{d:"Oct. 1968",t:"1. Conference\n in Garmisch, Germany"},
		{d:"1969",t:"2. Conference in Rom, Italy"},
	]);	
</script>
</div></section>
<p>In the 1960th, the general problem was that projects were running over-budget or never delivered at all. Software was inefficient and often did not meet requirements. This situation was referred to as the <strong>Software Crisis</strong>. Furthermore, Before the 1960th software was not considered as a good of its own; it was developed and delivered along with the hardware that was sold to customers.</p>
<p>The term “Software Engineering” was coined at the end of the sixties and is often attributed to F.L. Bauer.</p>
<p>&lt;!-- TODO Add reference for the last statement. --&gt;</p>
<section class="slide"><div class="section-body"><blockquote><p>[The major cause of the software crisis is] that the machines have become several orders of magnitude more powerful! To put it quite bluntly: as long as there were no machines, programming was no problem at all; when we had a few weak computers, programming became a mild problem, and now we have gigantic computers, programming has become an equally gigantic problem.</p>
<p>E. Dijkstra, 1972 [#Dijkstra:1972:HP:355604.361591]</p>
</blockquote>
</div></section>
<p>Since computers have become more powerful, more complex software is possible and more complex programs (more requirements) are requested to be developed. But, back in the 1960th, experience in creating big software systems was not available.</p>
<p>Common questions were:</p>
<ul>
<li>How to keep code maintainable?</li>
<li>How to satisfy extensive and changing requirements?</li>
<li>How to work on code as a team?<br />
<em>In the 60th client-server based version control systems or distributed version control systems just did not exist.</em></li>
</ul>
<p>In response to these problems, a conference was organized with the goal to figure out how to adopt (successful) hardware engineering approaches for software development.</p>
<section class="slide" data-title="Definition of Software Engineering"><div class="section-body"><p>Today, Carnegie Mellon University&apos;s Software Engineering Institute defines “Software Engineering” relative to “Engineering” as: </p>
<blockquote><p>Engineering is the systematic application of scientific knowledge in creating and building cost-effective solutions to practical problems in the service of mankind. </p>
<p>Software engineering is that form of engineering that <strong>applies the principles of computer science and mathematics</strong> to achieving cost-effective solutions to software problems. </p>
</blockquote>
</div></section>
<p>Since the 60th, we have made significant progress! </p>
<p>We now have:</p>
<ul>
<li>Sophisticated methods and tools for requirements engineering, enabling distributed teams to work together efficiently</li>
<li>Best practices, high-level architecture styles </li>
<li>Formal modeling techniques and visual design notations</li>
<li>Potent high-level programming languages</li>
<li>Potent quality assurance methods, techniques and tools</li>
<li>Advanced process and project management methodologies</li>
<li>Advanced development environments</li>
</ul>
<section class="slide"><div class="section-body"><p>But, as Dijkstra already identified ....</p>
<blockquote><p>[...] I would like to insert a warning to those who identify the difficulty of the programming task with the struggle against the inadequacies of our current tools, because they might conclude that, once our tools will be much more adequate, programming will no longer be a problem. </p>
<p><strong>Programming will remain very difficult, because once we have freed ourselves from the circumstantial cumbersomeness, we will find our selves free to tackle the problems that are now well beyond our programming capacity.</strong>
E. Dijkstra, 1972 [#Dijkstra:1972:HP:355604.361591]</p>
</blockquote>
</div></section>
<p>Dijkstra&apos;s statement is today as true as it was in 1972! Even though, we are solving problems today that were not possible to solve in 1972.</p>
<p>Some of today&apos;s challenges are:</p>
<ul>
<li>How to develop software efficiently that makes good use of multi-core systems?</li>
<li>How to process huge amounts of data?<br />
(Many companies already collect huge amounts of information but don&apos;t know how to effectively use and analyze it.)</li>
<li>How to develop complex software systems that are secure? 
Some standards, such as PCI DSSS (cf. <a href="http://www.pcicomplianceguide.org/aboutpcicompliance.php">http://www.pcicomplianceguide.org/aboutpcicompliance.php</a>) for handling and processing credit card data, define strict requirements on the software.</li>
</ul>
<p>But, the advances in technology drive more complex requirements and business agility! Hence, the Software Crisis is still with us though at a much higher level. The requirements are getting more and more complex and are changing rapidly. To solve our current and future problems, studying and advancing foundations, methods, notations, tools for software development is extremely important.</p>
<p>It is necessary, to fundamentally question our assumptions about Software Engineering.</p>
<h2>Software as an Engineering Product?</h2>
<section class="slide" data-title="Product Engineering"><div class="section-body"><h1>Software as an Engineering Product?</h1>
<h2>Product Engineering</h2>
<ul>
<li><p><strong>1st Phase: Requirements Analysis</strong><br />
The problem to solve is analyzed and documented.</p>
</li>
<li><p><strong>2nd Phase: Design and Validation</strong><br />
<em>Engineers</em> translate the requirements into a detailed description of the solution using models and rigorously validate these models.	</p>
</li>
<li><p><strong>3rd Phase: Building the Product</strong><br />
<em>Workers</em> build the design using appropriate tools and materials.</p>
</li>
</ul>
</div></section>
<p>First, we have to understand that we can clearly distinguish between designing and building a product. </p>
<ul>
<li>When a design effort is complete, the design documentation is turned over to the manufacturing team.<br />
The manufacturing team can then proceed to build (lots of) the product, without further intervention of designers.</li>
<li><em>Designing and building a product is done by different teams with different skills.</em></li>
<li>In general, manufacturing is a labor intensive, expensive process.</li>
<li>Overall, considerable time is spent in validating and refining designs before they are build.<br />
<em>Simulations based on theoretical models are used to ensure the quality of the design.</em></li>
</ul>
<p>To better understand the intricacies of developing software, let&apos;s compare <strong>Software Design</strong> and <strong>Hardware Design</strong>.</p>
<section class="slide" data-title="Hardware vs. Software Design"><div class="section-body"><h1>Software as an Engineering Product?</h1>
<h2>Hardware vs. Software Design</h2>
<table>
	<tr><th>Hardware Design</th><th>Software Design</th></tr>
	<tr><td>Product is a physical object</td><td>Product is the running software</td></tr>
	<tr><td>
		Building the product is: 
		<ul>
			<li>done by humans and robots</li>
			<li>expensive </li>
			<li>slow</li>
			<li>hard to redo</li>			
		</ul>
		</td>
		<td>Building the product is: 
	 	<ul>
			<li>done by compilers and linkers </li>
			<li>extremely cheap</li>
			<li>very fast</li>
			<li>easy to redo</li>						
		</td>
	</tr>
	<tr><td>Precise quality measures</td><td>No precise quality measures</td></tr>
</table>
</div></section>
<p>Hence, programming is not about building the software; programming is about designing the software and the code is the ultimate design document! Furthermore, simulating software is unnecessary or even impossible.</p>
<section class="slide"><div class="section-body"><h1>Development of Eclipse</h1>
<p><img src="Images/EclipseCodeAndProjectGrowth.png" alt="Code and Project growth of Eclipse" /></p>
</div></section>
<p>Software designs tend to be incredibly large and complex and typical commercial software products have designs that consist of hundreds of thousands of lines.  Many run into the millions.</p>
<p>More complex designs are targeted every day.</p>
<p>Furthermore, software designs are constantly evolving. </p>
<section class="slide" data-title="Code as Design"><div class="section-body"><p><a href="http://www.developerdotstar.com/mag/articles/reeves_design_main.html">→Code as Design: Three Essays by Jack W. Reeves</a></p>
<blockquote><p>The following essays by Jack W. Reeves offer three perspectives on a single theme, namely that <strong>programming is fundamentally a design activity</strong> and that the only final and true representation of &quot;the design&quot; is the source code itself. [...]</p>
</blockquote>
<p><strong><a href="http://www.developerdotstar.com/mag/articles/reeves_design.html">→What Is Software Design?</a></strong><br />
This essay was first published in the Fall 1992 issue of the C++ Journal.  [...] in recent years the essay has entered the flow of ideas and discussion in the software development community at large [...].</p>
<p><strong><a href="http://www.developerdotstar.com/mag/articles/reeves_13yearslater.html">→What Is Software Design: 13 Years Later</a></strong><br />
In this essay the author responds to the most common arguments he has encountered. He also considers certain ideas from the original essay in light of more current trends and techniques.</p>
<p><strong><a href="http://www.developerdotstar.com/mag/articles/reeves_originalletter.html">→Letter to the Editor</a></strong><br />
This is the original letter written by Jack W. Reeves to C++ Journal. It stands as a rewarding essay in its own right, giving first written expression to the themes and ideas found in &quot;What is Software Design?&quot; In some aspects it is even more comprehensive and spirited than the essay it inspired.</p>
</div></section>
<p>Out of all the documentations that software projects normally generate, is there anything that can truly be considered an engineering document?<br /></p>
<blockquote><p>... the only ... documentation that seems to satisfy the criteria of an engineering design is the source code listings.<br />
<strong>Jack Reeves, To Code is to Design, C++ Report 1992</strong></p>
</blockquote>
<p>&lt;!-- TODO Add reference to the bibliography entry. --&gt;</p>
<p>However, Jack Reeves was not the first who realized that it may not be helpful to distinguish between design and production when developing software products.</p>
<section class="slide"><div class="section-body"><p>NATO Software Engineering Conference 1968 (<a href="http://homepages.cs.ncl.ac.uk/brian.randell/NATO/">http://homepages.cs.ncl.ac.uk/brian.randell/NATO/</a>)</p>
<blockquote><p>[...] there is no essential difference between design and production, since the production will include decisions which will influence the performance of the software system, and thus properly belong in the design phase.</p>
<p><strong>Peter Naur</strong></p>
</blockquote>
<hr />
<blockquote><p>[...] Honestly, I cannot see how these activities allow a rigid separation if we are going to do a decent job.</p>
<p><strong>Edsger Dijkstra</strong></p>
</blockquote>
<footer><div class="footer-body"><p>Back in the 1960s, writing the source code was considered to be the &quot;production step&quot;.</p>
</div></footer>
</div></section>
<p>In short, the possibility to find solutions to the software industry&apos;s problems by trying to blindly emulate hardware developers is extremely limited.</p>
<section class="slide"><div class="section-body"><h1>Questionable Ideas</h1>
<h2>Grounded on Misleading Analogies</h2>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="100%" style="font-size: 200%; font-family: script;">
    <text x="10" y="45" fill="#222266">Waterfall Model</text>
    <text x="300" y="145" fill="#000088">Software Industrialization</text>
    <text x="250" y="280" fill="#660022">Programmer productivity as<tspan x="250" y="325">"Lines of Code"</tspan></text>
    <text x="80" y="450" fill="#006633">Outsourcing: Design here, Production elsewhere</text>
</svg>
</div></section>
<p><strong>Wind of Change?</strong></p>
<blockquote><p>The creation of genuinely new software has far more in common with developing a new theory of physics than it does with producing cars or watches on an assembly line.</p>
<p>T. Bollinger, “The Interplay of Art and Science in Software”, IEEE Software, 1997</p>
</blockquote>
<hr />
<blockquote><p>Software [...] is treated as a product, and this is the problem. </p>
<p>P.G. Armour, The Business of Software, CACM, 2000</p>
</blockquote>
<hr />
<blockquote><p>“Software Engineering: An idea whose time has come and gone!” </p>
<p>Tom DeMarco, IEEE Software, 2009</p>
</blockquote>
<aside><div class="aside-body"><h1>Craft vs. Engineering</h1>
<p>Experience can lead us in the right direction. This is craft. Experience will only take us so far into uncharted territory. Then we must take what we started with and make it better through a controlled process of refinement. This is engineering.</p>
</div></aside>
<h2>Complexity and Change are Invariants</h2>
<section class="slide" data-title="Complexity and Change are Invariants"><div class="section-body"><h1>Consequences of the Cheap Software Build</h1>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="80%" style="font-size: 250%; font-family: script;">
    <text x="40" y="300" fill="#660022">Complexity and Change are Invariants!</text>
</svg>
</div></section>
<section class="slide"><div class="section-body"><h1>Complexity and Change are Invariants</h1>
<div class="statement">Designing for organizing complexity and facilitating change is the key to support maintainability. </div>
</div></section>
<p>&lt;!-- TODO Add add reference for the following claim: --&gt;</p>
<p>A software product spends around 80% of its lifetime in maintenance.</p>
<p>While there are certainly examples of hardware designs that are arguably as complex as software designs, note two facts about modern hardware:</p>
<ol>
<li><p>Complex hardware engineering efforts are not always as free of bugs as software critics would like us to believe. Major microprocessors have been shipped with errors in their logic, bridges collapsed, dams broken, airliners fallen out of the sky, and thousands of automobiles and other consumer products have been recalled - all within recent memory and all the result of design errors. </p>
</li>
<li><p>Complex hardware designs have correspondingly complex and expensive build phases. As a result, the ability to manufacture such systems limits the number of companies that produce truly complex hardware designs. </p>
</li>
</ol>
<p>No such limitations exist for software. There are hundreds of software organizations, and thousands of very complex software systems in existence. Both the number and the complexity are growing daily. </p>
<p>This means that the software industry is not likely to find solutions to its problems by trying to emulate hardware developers. If anything, as CAD and CAM systems have helped hardware designers to create more and more complex designs, hardware engineering is becoming more and more like software development. </p>
<section class="slide" data-title="On Requirements"><div class="section-body"><h1>Incomplete and Changing Requirements</h1>
<h2>What is the right question to ask?</h2>
<ul>
<li>How do we get complete requirements?</li>
<li>Can we get complete requirements at all?</li>
</ul>
</div></section>
<p>General observation: <em>People are not used to completely specify things.</em> (Hence, the classical waterfall method is not “real” to customers.)</p>
<p><strong>The report effect:</strong></p>
<ol>
<li>The customers are not entirely aware of what the computing systems will do for them; they see new requirements as soon as old ones are met.</li>
<li>They see one kind of produced report and ask whether the system can also do this and that. </li>
</ol>
<p>If we would use the waterfall process to develop the software, the customers would not get intermediate products that would make them wary about particular aspects of the system early enough.</p>
<section class="story"><div class="section-body"><p><strong>Building a House</strong></p>
<p>If you are building a house, you soon notice the effects of your decisions on the phases of the construction.</p>
<p>As each new event occurs, it becomes obvious to the builder that it is harder and harder to change his mind or correct mistakes.</p>
<p>Users and customers of software have no intermediate events that “CAST THINGS IN CONCRETE”. They tend to change their mind often and in most awkward times.</p>
<p>Consider the following scenario: Suppose we are building a square house that is 50 feet on each side.</p>
<p>As the result of a mistake when laying out the foundation, one corner is one feet longer than the others.</p>
<p>The mistake has a lot of implications. Yet, it is clear that it is not easy to correct and the customer can see that.</p>
</div></section>
<section class="slide"><div class="section-body"><h1>Incomplete and Changing Requirements</h1>
<p><strong>Scenario:</strong>
You are developing a software for personnel management that advices employees about their benefits, including their retirement plan. </p>
<p><strong>Initial Requirement:</strong>
The first opportunity to withdraw money without penalty is when an employee turns 60.</p>
<p><strong>Resulting Code:</strong></p>
<pre><code class="scala">if(employee.age &gt;= 60) {...}
</code></pre>
<p><strong>Changed Requirement:</strong>
After testing it is discovered that withdrawing money is possible when the employee is 59.5.</p>
<p><strong>Customer&apos;s Assessment:</strong>
This change will be easy to do...</p>
<p>But, the following change may not be possible:</p>
<pre><code class="scala">if(employee.age &gt;= 59.5) {...}
</code></pre>
</div></section>
<p>But,...</p>
<ul>
<li>you may have been using integer arithmetic and now need to switch to rational number arithmetic.</li>
<li>if you decide to keep integer arithmetic, you will have to convert all ages into months.</li>
</ul>
<p>Hence, what looks simple at first sight may turn out to be a rather complex change. More important, the customer may not be aware of the consequence. Changing the fundaments and changing entry age may end up being of the same scale and causing the same headache. However, the customer can see the former and not the latter.</p>
<p>To the customer, the changes to the latter are more like making changes on the blueprints rather than on the actual concrete.</p>
<p>As a result, software users tend to change requirements on the fly.</p>
<aside><div class="aside-body"><blockquote><p>The task of the software development team is to engineer the illusion of simplicity.</p>
<p>in G. Booch: Object-oriented Analysis with Applications, Addison-Wesley, 1993</p>
</blockquote>
</div></aside>
<h2>Everything is Part of the Design</h2>
<section class="slide"><div class="section-body"><h1>&quot;Everything&quot; is Part of the Design</h1>
<ol>
<li>High-level architectural design</li>
<li>Class-level design</li>
<li>Low(implementation)-level detailed design</li>
<li><strong>The code</strong></li>
</ol>
</div></section>
<p>We need good software design at all levels. The better the early design, the easier it is to do the detailed design and the better will be its quality. Except from the lowest-level detailed design (the code), all higher-level designs are never a complete software design. All higher-level designs are just a structural framework for the detailed design.</p>
<p>The final design is the code. Hence, the software design is not complete until it is coded and tested!
Designers should use anything that helps; e.g., user stories, Z specifications, UML diagrams.
These are all useful notations for facilitating the design process and can serve as auxiliary documentation.
Yet, they are not a software design! The real design will be created using some programming language.</p>
<p>Designs should be coded as they are derived and be refined when necessary.
The process of rendering the design in code reveals mistakes and the need for additional design effort.
The earlier it occurs, the better the design will be.
The detailed design will ultimately influence (or should be allowed to
influence) the high-level design.
Refining all the aspects of a design is a process that should be happening throughout the design cycle.</p>
<section class="slide"><div class="section-body"><h1>Testing and Debugging is Designing</h1>
<div class="statement">Testing is not just concerned with getting the current design correct, it is part of refining the design.</div>
</div></section>
<p>If we consider source code as design, we see that software engineers (just like other engineers) also do a considerable amount of validating and refining their designs.
Most software designers do not call it engineering...rather testing and debugging, i.e., do not consider testing and debugging as real &quot;engineering“ due to the refusal of the software industry to accept code as the actual design.</p>
<section class="slide"><div class="section-body"><blockquote><p>In [...] embedded systems [...] the software requirements change throughout the software development process, even during system testing.  This is largely due to unanticipated behavior, dynamic changes in the operating environment, and complex software/hardware and software/software interactions in the systems being deveoped. <strong>Controlling requirement changes (and, hence, the scope and cost of development) is difficult since the changes are often prompted by an improved understanding of the software’s necessary interfaces with the physical components</strong> [...] in which it is embedded.<br /></p>
<p>Analyzing software requirements errors in safety-critical, embedded systems; R. R. Lutz; 1993 (cf. [#lutz:1993])</p>
</blockquote>
</div></section>
<p>Hence, a core property of every complex system is that it is basically impossible to identify all requirements before the implementation starts. Implementing the system is essential to gain an ever more complete understanding of the systems requirements.</p>
<h2>Auxiliary Documentation</h2>
<p>Obviously the actual design documents (entailed in code) are the most important, but often not the only one that must be produced. Auxiliary documentation (directly associated with the design process) is as important for a software project as it is for a hardware project.</p>
<p>Auxiliary documentation should capture information from the problem space. </p>
<p>Inventing software concepts to model concepts in a problem space requires an understanding of the essential problem space concepts. Usually this process involves information that does not directly end up being modeled in the SW space.</p>
<p>Auxiliary documentation should document those aspects of the design that are difficult to
extract directly from the design itself. Many of these aspects are best depicted graphically. This makes
them hard to include as comments in the source code. (However, this is not an argument for a graphical software design notation instead of a programming language.)</p>
<p>This is not different from the need for textual descriptions to accompany the design documents of other engineering disciplines.</p>
<p>But, keeping auxiliary documentation up to date manually is difficult.</p>
<section class="slide" data-title="Auxiliary Documentation"><div class="section-body"><h1>&quot;Up-to-Date&quot; Auxiliary Documentation</h1>
<pre><code class="java">package org.eclipse.emf.teneo.hibernate.resource;
...

	/**
	 * Rolls back the transaction if any and clears different lists to
	 * start with an empty resource again.
	 * Note that the super.doUnload is not called because that clears 
	 * the list resulting in all kinds of undesirable inverse removes.
	 */
	@Override
	protected void doUnload() {
		super.doUnload();
	}
...

</code></pre>
</div></section>
<p>Non up-to-date auxiliary documentation is an argument for more expressive programming languages. I.e., programming languages that enable the developer to directly express the intent.</p>
<p>It is an argument for keeping auxiliary documentation to a minimum and as informal as possible until as late in the project as possible. However, keep in mind that some software development processes – primarily for safety critical systems – do require extensive documentation as part of the development process.</p>
<p>Generally, auxiliary documentation should be written after the code is more accurate. Keep in mind that only the design reflected in code has been refined during the build/test cycle! Ideally, software tools that post-process a source code design and generate auxiliary documentation should be available.</p>
<p>The probability of the initial design being unchanged during this cycle is inverse to the number of modules and programmers on a project.</p>
<section class="slide" data-title="To Code Is To Design"><div class="section-body"><div class="statement"><strong>TO CODE IS TO DESIGN.</strong></div>
<p><em>Which doesn&apos;t mean that you should start coding right away!</em></p>
</div></section>
<section class="slide" data-title="Properties of a good development process"><div class="section-body"><h1>Properties of a good development process</h1>
<ul>
<li>… recognizes <strong>programming as a design activity</strong> and does not hesitate to code when coding makes sense.</li>
<li>… recognizes <strong>testing and debugging as design activities</strong> - the software equivalent of design validation and refinement of other engineering disciplines - and does not shorten the steps. </li>
<li><p>… recognizes that there are other design activities:</p>
<ul>
<li>top level design,</li>
<li>module design,</li>
<li>class design, </li>
<li>etc. </li>
</ul>
</li>
<li>… recognizes that <strong>all design activities interact</strong> and allows the design to change as various steps reveal the need. </li>
</ul>
</div></section>
<h2>Programming Languages are Design Languages</h2>
<section class="slide"><div class="section-body"><div class="statement">If <em>to code is to design</em>, then  <strong>Programming Languages</strong>  are  <strong>Design Languages</strong>!</div>
</div></section>
<h3>Coding High-Level and Detailed Designs</h3>
<p>Programming languages outperform other design notations in their capability to express both high-level and detailed design. High-level design notations have to be translated into the target programming language before detailed design can begin. Translation is time consuming and error prone since a design notation may not map cleanly into the programming language of choice. Pogrammers often go back to the requirements and redo the high-level design, coding it as they go.</p>
<section class="slide"><div class="section-body"><h1>What we need is:</h1>
<div class="statement">Unified design notation suitable for all levels of design, i.e., programming languages that are suitable for capturing high-level design.</div>
</div></section>
<p>However, current programming languages have weaknesses as tools for expressing certain aspects of a software design. The information is in the code but it is very difficult to get it out in human readable form</p>
<section class="slide"><div class="section-body"><h1>Making Code Look Like Design</h1>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="100%" style="font-size: 175%; font-family: Courier New;">
	<defs>
	   <marker id='head' orient='auto' markerWidth='10' markerHeight='10' refX='0.1' refY='2'>
	     <path d='M0,0 V4 L2,2 Z' fill='black' />
	   </marker>
	</defs> 
	<text x="70" y="50" fill="#000066">Functional Object-oriented Programming</text>
 	<line x1="300" y1="140" x2="475" y2="80" style="stroke:rgb(0,0,100);stroke-width:8"  marker-end="url(#head)"/>
	<line x1="700" y1="140" x2="525" y2="80" style="stroke:rgb(0,0,100);stroke-width:8"  marker-end="url(#head)"/>
	 
	<text x="50" y="170" fill="#000066">Object-oriented<tspan x="50" y="205">Programming</tspan></text>
	<line x1="490" y1="260" x2="350" y2="205" style="stroke:rgb(0,0,100);stroke-width:8"  marker-end="url(#head)"/>
    
	<text x="650" y="170" fill="#000066">Functional<tspan x="650" y="205">Programming</tspan></text>	
	<line x1="510" y1="260" x2="650" y2="205" style="stroke:rgb(0,0,100);stroke-width:8"  marker-end="url(#head)"/>
    
	<text x="300" y="290" fill="#000066">Modular Programming</text>	
	<line x1="500" y1="385" x2="500" y2="310" style="stroke:rgb(0,0,100);stroke-width:8"  marker-end="url(#head)"/>
    
	<text x="300" y="410" fill="#000066">Structured Programming</text>
	<line x1="500" y1="505" x2="500" y2="430" style="stroke:rgb(0,0,100);stroke-width:8"  marker-end="url(#head)"/>
    
	<text x="300" y="530" fill="#000066">Assembler-like Languages</text>
</svg>
</div></section>
<aside><div class="aside-body"><p>The article <strong>The Impact of Software Engineering Research on Modern Programming Languages</strong> by B. G. Ryder, M. L. Soffa and M. Burnett, which appeared in ACM Transactions on Software Engineering and Methodology (2005), discusses the relation between Software Engineering and Programming Language Research, a set of interviews with Programming Language Developers (Niklaus Wirth, Bjarne Stroustrup, Tim Lindholm,...) is included, which are very worth reading.</p>
</div></aside>
<p>Advances in programming language technology are driven by the need to make programming languages capable of more directly capturing higher-level designs!</p>
<section class="slide"><div class="section-body"><h1>Takeaway</h1>
<p>Consequences of the cheap build for this course:</p>
<ul>
<li>Designing means structuring code in modular way so as to support managing complexity and continuous change.</li>
<li>We will adopt an agile design process to accommodate change in the design process.</li>
<li>We will adopt test-driven development, as we consider testing to be part of design.</li>
<li>Languages as design notations will be in focus but also design principles and styles as well as tools for expressing modular structures outside the languages.</li>
</ul>
</div></section>
<aside><div class="aside-body"><p>In this lecture we are primarily concerned with the design of the source code as such. We are not considering other factors, such as, how to distribute responsibility between team members, the details of the chosen software development process, the kind of software (open-source vs. closed-source) that is developed. (cf. [#Kamp:2012aa] for further details).</p>
</div></aside>
<p>TODO &lt;&lt;[1.2-Introduction-Scala.md]</p>
<h1>Programming Languages and Design Principles</h1>
<p>In the following, we will discuss the development of programming languages as a means to improve their ability to capture the software design at ever increasing abstraction levels. Or, from another point of view, we discuss why advances in programming language technology are driven by the need to make programming languages capable of capturing higher-level designs.</p>
<section class="slide" data-title="Programming Languages and Design Principles"><div class="section-body"><h1>Programming Languages and Design Principles</h1>
<div class="statement">Making Code Look Like Design</div>
</div></section>
<h2>“Designing” with Pseudo-Assembler</h2>
<section class="slide" data-title="“Designing” with Pseudo-Assembler"><div class="section-body"><h1>“Designing” with Pseudo-Assembler</h1>
<p>What does the following program do?</p>
<pre><code class="C">i = 1
TEST:	if i &lt; 4
	then goto BODY
	else goto END
BODY:	print i
	i = i + 1
	goto TEST
END:
</code></pre>
</div></section>
<section class="slide"><div class="section-body"><h1>“Designing” with Pseudo-Assembler</h1>
<p>What does the following program do?</p>
<pre><code class="C">i = 1
LOOP:	print i
	i = i + 1
	if i &lt; 4 goto LOOP
END:	
</code></pre>
</div></section>
<p>Though both programs just print out &quot;123&quot; the second one is easier to read and comprehend. It has a better style:</p>
<ul>
<li>Clear structure</li>
<li>No crossing gotos</li>
<li>Better names</li>
<li>Code structure closer to what we want to express.<br />
&quot;Print out i, i smaller than 4“</li>
</ul>
<p>Hence, the second variant, though functionally identical, is easier to understand, debug, change.</p>
<section class="slide" data-title="Style can only be recommended"><div class="section-body"><p><em>But:</em> </p>
<div class="statement"><strong>Style can only be recommended, not enforced!</strong></div>
</div></section>
<h2>Designing with Structured Programming Languages</h2>
<section class="slide" data-title="Designing with Structured Programming Languages"><div class="section-body"><h1>Designing with Structured Programming Languages</h1>
<pre><code class="C">i = 1
while ( i &lt; 4 ) {
	print(i)
	i = i + 1
}
</code></pre>
<p><strong>Style gets enforced!</strong><br /></p>
</div></section>
<p>In the 1960th programming language support for better structuring of code emerged. <code>Goto</code>s were replaced by loops (<code>while</code>) and conditionals (<code>if</code>/<code>else</code>). Furthermore, procedures were introduced to support user-defined abstractions.</p>
<p>New words, new grammars, new abstractions enable developers to directly express looping/conditional computations, instead of emulating them by jumps. Using a – by then – modern structured programming language, it was no longer possible  to write crossing <code>goto</code>s!</p>
<section class="slide"><div class="section-body"><h1>Better languages, More challenging tasks…</h1>
<p>A simple image browser with structured programming:
<img src="Images/ImageBrowser.png" alt="Image Browser" /></p>
</div></section>
<section class="slide"><div class="section-body"><p><strong>Code for Image Browser Structured into Procedures</strong></p>
<div style="font-size:0.65em">
  <div style="position:absolute;top:100px;left:16px;width:320px;">
  <pre><code class="C">main () {
draw_label(“Art Browser”)
   m = radio_menu(
      {“Whale”, “Eagle”, “Dogfish”})
   q = button_menu({“Quit”})
   while ( ! check_buttons(q) ) {
      n = check_buttons(m)
      draw_image(n)
   }
}
  </code></pre></div>

  <div style="position:absolute;top:280px;left:16px;width:320px">
  <pre><code class="C">set_x (x) {
   current_x = x
}
  </code></pre></div>

  <div style="position:absolute;top:350px;left:16px;width:320px;">
  <pre><code class="C">draw_circle (x, y, r) {
   %%primitive_oval(x, y, 1, r)
}
  </code></pre></div>

  <div style="position:absolute;top:420px;left:16px;width:320px;">
  <pre><code class="C">set_y (y) {
   current_y = y
}
  </code></pre></div>


  <div style="position:absolute;top:100px;left:352px;width:320px;">
  <pre><code class="C">radio_menu(labels) {
   i = 0
   while (i < labels.size) {
      radio_button(i)
      draw_label(labels[i])
      set_y(get_y()
         + RADIO_BUTTON_H)
      i++
   }
}
  </code></pre></div>

  <div style="position:absolute;top:280px;left:352px;width:320px;">
  <pre><code class="C">radio_button (n) {
   draw_circle(get_x(),
      get_y(), 3)
}
  </code></pre></div>

  <div style="position:absolute;top:370px;left:352px;width:320px;">
  <pre><code class="C">get_x () {
   return current_x
}
  </code></pre></div>

  <div style="position:absolute;top:440px;left:352px;width:320px;">
  <pre><code class="C">get_y () {
   return current_y
}
  </code></pre></div>


  <div style="position:absolute;top:100px;left:686px;width:320px;">
  <pre><code class="C">draw_image (img) {
   w = img.width
   h = img.height
   do (r = 0; r < h; r++)
      do (c = 0; c < w; c++)
         WINDOW[r][c] = img[r][c]
}
  </code></pre></div>

  <div style="position:absolute;top:230px;left:686px;width:320px;">
  <pre><code class="C">button_menu(labels) {
   i = 0
   while (i < labels.size) {
      draw_label(labels[i])
      set_y(get_y()
         + BUTTON_H)
      i++
   }
}
  </code></pre></div>

  <div style="position:absolute;top:400px;left:686px;width:320px;">
  <pre><code class="C">draw_label (string) {
   w = calculate_width(string)
   print(string, WINDOW_PORT)
   set_x(get_x() + w)
}
  </code></pre></div>

</div>
<footer><div class="footer-body"><p><strong>Try to identify which method calls which method!</strong></p>
</div></footer>
</div></section>
<p>In this case, the code is structured, but the procedures are not! It is hard, if not nearly impossible, to  maintain or even extend this code.</p>
<section class="slide"><div class="section-body"><p><strong>Structured Programming with Style</strong></p>
<div style="font-size:0.65em">

	<div style="position:absolute;top:100px;left:352px;width:320px;">
		<pre><code class="C">main()
	</code></pre></div>
	
	<div style="position:absolute;top:150px;left:16px;width:320px;">
	<pre><code class="C">gui_radio_button(n)
	</code></pre></div>

	<div style="position:absolute;top:190px;left:16px;width:320px;">
	<pre><code class="C">gui_button_menu(labels)
	</code></pre></div>

	<div style="position:absolute;top:230px;left:16px;width:320px;">
	<pre><code class="C">gui_radio_menu(labels)
	</code></pre></div>


	<div style="position:absolute;top:150px;left:352px;width:320px;">
	<pre><code class="C">graphic_draw_image (img)
	</code></pre></div>

	<div style="position:absolute;top:190px;left:352px;width:320px;">
	<pre><code class="C">graphic_draw_circle (x, y, r)
	</code></pre></div>

	<div style="position:absolute;top:230px;left:352px;width:320px;">
	<pre><code class="C">graphic_draw_label (string)
	</code></pre></div>

	<div style="position:absolute;top:150px;left:686px;width:320px;">
	<pre><code class="C">state_set_y (y)
	</code></pre></div>

	<div style="position:absolute;top:190px;left:686px;width:320px;">
	<pre><code class="C">state_get_y ()
	</code></pre></div>

	<div style="position:absolute;top:230px;left:686px;width:320px;">
	<pre><code class="C">state_set_x (x)
	</code></pre></div>

	<div style="position:absolute;top:270px;left:686px;width:320px;">
	<pre><code class="C">state_get_x ()
	</code></pre></div>

</div>
</div></section>
<p>Group procedures by the functionality they implement and the state they access, e.g. by naming conventions …</p>
<p>Advantages:</p>
<ul>
<li>The code is closer to what we want to express.<br />
&quot;main calls gui, gui calls graphic to draw, …“</li>
<li>The code is easier to understand, debug and change.</li>
</ul>
<h2>Designing with Modular Programming Languages</h2>
<section class="slide" data-title="Designing with Modular Programming Languages"><div class="section-body"><h1>Designing with Modular Programming Languages</h1>
<pre><code class="C">module gui {
    exports:
        radio_menu(labels)
        button_menu(labels)
        check_buttons(menu)
}	
</code></pre>
</div></section>
<p>Modular programming introduced modules, higher-level units/modules introduce higher-level abstractions! One can handle a whole module as if it was its interface.
Programming language mechanisms for supporting information hiding: interface hides module internals.</p>
<section class="slide" data-title="Module-based Abstraction"><div class="section-body"><h1>Module-based Abstraction</h1>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="100%" style="font-size: 36px; font-family: Courier New;">
	<defs>
	   <marker id='head' orient='auto' markerWidth='10' markerHeight='10' refX='0.1' refY='2'>
	     <path d='M0,0 V4 L2,2 Z' fill='black' />
	   </marker>
	</defs> 
	
	<rect x="360" y="15" width="305" height="55" fill="rgb(255,255,180)" />
	<text x="370" y="50" fill="#000066">image_browser</text>
 	 
 	<rect x="40" y="135" width="475" height="160" fill="rgb(255,255,180)" />
	<text x="50" y="170" fill="#000066">gui:
		<tspan x="70" y="205">radio_menu(labels)</tspan>
		<tspan x="70" y="240">button_menu(labels)</tspan>
		<tspan x="70" y="275">check_buttons(menu)</tspan>
	</text>
 	
    	<rect x="640" y="135" width="195" height="55" fill="rgb(255,255,180)" />
	<text x="650" y="170" fill="#000066">graphics</text>	

 	<line x2="300" y2="130" x1="475" y1="70" style="stroke:rgb(0,0,100);stroke-width:8"  marker-end="url(#head)" />
	<line x1="510" y1="70" x2="630" y2="140" style="stroke:rgb(0,0,100);stroke-width:8"  marker-end="url(#head)" />
	<line x1="515" y1="260" x2="630" y2="185" style="stroke:rgb(0,0,100);stroke-width:8"  marker-end="url(#head)"/>
</svg>
</div></section>
<p>Abstraction enables us to:</p>
<ul>
<li>look at the overall structure of the system (architectural thinking).</li>
<li>zoom in on individual units as needed</li>
<li>with more or less details</li>
</ul>
<p>Hence, abstraction is the key to managing complexity.</p>
<section class="slide" data-title="Abstraction"><div class="section-body"><div class="statement">Abstraction mechanisms enable us to code and design simultaneously!</div>
<p><strong>&quot;Write what you mean.&quot;</strong></p>
<blockquote><p>&quot;The significant problems we face cannot be solved at the same level of thinking we were at when we created them.&quot;</p>
<p>Einstein</p>
</blockquote>
</div></section>
<ul>
<li>Makes the code easier to understand, debug and change.</li>
<li>Allows structured organization of code.</li>
<li>Ability to ignore details.
Makes the code closer to what we want to express. </li>
</ul>
<section class="slide"><div class="section-body"><p>Let’s “develop” application families with sophisticated GUIs with uniform look and feel with modular programming…</p>
<p>  <img src="Images/Screenshot-Numbers.png" width="80%" style="position:absolute;top:100px;left:16px"/>
  <img src="Images/Screenshot-Keynote.png" width="80%" style="position:absolute;top:150px;left:66px"/>
  <img src="Images/Screenshot-Pages.png" width="80%" style="position:absolute;top:200px;left:116px"/></p>
<div style="position:absolute;top:300px;width:524px;left:225px;background-color:rgba(255,255,255,.8);padding:25px;font-size:1.25em">Great variability:<br>   
checkbox button, toolbar button, toggle button, radio button … 
</div>
</div></section>
<p>Modeling variability with modular programming languages appeared complex…</p>
<h2>Designing with Object-Oriented Programming Languages</h2>
<section class="slide" data-title="Designing with Object-Oriented Programming Languages"><div class="section-body"><h1>Designing with Object-Oriented Programming Languages</h1>
<p>Object-oriented programming languages introduce new abstraction mechanisms:</p>
<ul>
<li>classes, </li>
<li>inheritance, </li>
<li>subtype polymorphism.</li>
</ul>
<div class="statement">(Still) Dominating Programming Paradigm</div>
</div></section>
<section class="slide"><div class="section-body"><p><strong>The roots of object-oriented programming languages are in the sixties.</strong></p>
<p>Dahl and Nygaard, Simula 64, 68<br />
<img src="Images/DahlAndNygaard.jpg" alt="Dahl and Nygaard" /><br /></p>
<p>Allan Kay, Smalltalk 70 - 80<br />
<img src="Images/AlanKay.jpg" alt="Alan Kay" /><br /></p>
</div></section>
<p>Object-oriented languages are popular because they make it easier to design software and program at the same time.</p>
<p>They allow us to more directly express high level information about design components abstracting over differences of their variants.</p>
<p>Make it easier to produce the design, and easier to refine it later.</p>
<p>With stronger type checking, they also help the process of detecting design errors. </p>
<p>Result in a more robust design, in essence a better engineered design.</p>
<section class="slide"><div class="section-body"><blockquote><p>[…] improvements in programming techniques and programming languages in particular are overwhelmingly more important than anything else in the software business […] 
[…] programmers are interested in design […] when more expressive programming languages become available, software developers will adopt them. </p>
<p>Jack Reeves,  To Code is to Design, C++ Report 1992</p>
</blockquote>
</div></section>
<h2>Designing with Functional, Object-Oriented Programming Languages</h2>
<section class="slide" data-title="Designing with Functional, Object-Oriented Programming Languages"><div class="section-body"><h1>Designing with Functional, Object-Oriented Programming Languages</h1>
<p>By fusing object-oriented and functional programming we are provided with further means to raise our abstraction level. This enables us to better express our intention.</p>
<p><strong>Example</strong><br />
Creating an abstraction to express that we want to repeat something n times.</p>
<pre><code class="scala">def repeat[T: scala.reflect.ClassTag](times: Int)(f: ⇒ T): Array[T] = {
  val array = new Array[T](times)
  var i = 0
  while (i &lt; times) { array(i) = f; i += 1 }
  array
}
</code></pre>
<p><strong>Usage</strong>
Now, we can express that we want to read in two values from the command line.</p>
<pre><code class="scala">val values = repeat(2) { System.in.read() }
</code></pre>
</div></section>
<aside><div class="aside-body"><p>The complete code: <a href="Code/src/pl/scala/Repeat.scala">Repeat.scala</a></p>
</div></aside>
<h2>Programming Languages are not a Panacea</h2>
<section class="slide" data-title="Programming Languages are not a Panacea"><div class="section-body"><h1>Programming Languages are not a Panacea</h1>
<p>  <img src="Images/java.awt.components.jpg" width="420"></p>
</div></section>
<ul>
<li>Accessibility of object-oriented programming drives more complex designs!</li>
<li>Programming languages are powerful tools, but cannot and will never guarantee good designs.</li>
<li>Programming always needs to be done properly to result in good code.</li>
<li>Human <em>creativity</em> remains the main factor.</li>
</ul>
<section class="slide" data-title="The Imperative of Good Style"><div class="section-body"><p><strong>We need good style to cope with complexity!</strong></p>
<p><img src="Images/Cover-AgileDevelopment.jpg" alt="Cover AgileDevelopment" />
<img src="Images/Cover-DesignHeuristics.jpg" alt="Cover DesignHeuristics" />
<img src="Images/Cover-DesignPatterns.jpg" alt="Cover DesignPatterns" />
<img src="Images/Cover-OOADwithApplications.jpg" alt="Cover OOADwithApplications" />
<img src="Images/Cover-HeadsFirstDesignPatterns.jpg" alt="Cover HeadsFirstDesignPatterns" />
<img src="Images/Cover-PatternsOfEAA.jpg" alt="Cover PatternsOfEAA" />
<img src="Images/Cover-SystemOfPatterns.jpg" alt="Cover SystemOfPatterns" />
...</p>
</div></section>
<p>Help is provided through established practices and techniques, design patterns and principles.</p>
<p><strong>Good style can only be recommended, not enforced!</strong></p>
<p>Eventually style rules will have to be turned into language features to be really effective.
 classes.<br /></p>
<section class="slide" data-title="General Design Principles"><div class="section-body"><h1>General Design Principles</h1>
<p>The following principles apply at various abstraction levels:</p>
<ul>
<li>Keep it short and simple</li>
<li>Don&apos;t repeat yourself (also just called &quot;DRY-Principle&quot;)</li>
<li>High Cohesion</li>
<li>Low Coupling</li>
<li>No cyclic dependencies</li>
<li>Make it testable</li>
<li>Open-closed Design Principle</li>
<li>Make it explicit/use Code</li>
<li>Keep related things together</li>
<li>Keep simple things simple</li>
<li>Common-reuse/Common-closure/Reuse-release principles</li>
</ul>
</div></section>
<section class="slide" data-title="Object-Oriented Design Principles"><div class="section-body"><h1>Object-Oriented Design Principles</h1>
<ul>
<li>Liskov Substitution Principle</li>
<li>Responsibility Driven Design</li>
<li>...</li>
</ul>
<h1>Design Constraints</h1>
<ul>
<li><strong>Conway&apos;s Law:</strong><br /></li>
</ul>
<blockquote><p>A system&apos;s design is constrained by the organization&apos;s communication structure.</p>
</blockquote>
</div></section>
<h1>Class Design Principles</h1>
<h2>About Class Design Principles</h2>
<section class="slide" data-title="Class Design Principles"><div class="section-body"><h1>Class Design Principles …</h1>
<ul>
<li><p>state desired properties of class designs.</p>
</li>
<li><p>are heuristics.</p>
</li>
<li><p>help making a class design usable for client classes.</p>
</li>
</ul>
</div></section>
<p>Class Design Principles ...</p>
<ul>
<li>state desired properties of class designs. E.g. “A class should have only one responsibility.”</li>
<li>are heuristics that serve as guidelines to produce good designs.</li>
<li>are not absolute criteria to judge about the quality of designs.</li>
<li>help making a class design usable for client classes. We think about how our classes are used by other classes.</li>
</ul>
<section class="slide" data-title="S.O.L.I.D."><div class="section-body"><div class="statement">Class Design Principles aim for code we can efficiently work on!</div>
<p>The S.O.L.I.D. Principles:</p>
<ul>
<li><strong>S</strong>ingle Responsibility Principle (<strong>S</strong>RP)</li>
<li><strong>O</strong>pen-closed Principle (<strong>O</strong>CP)</li>
<li><strong>L</strong>iskov Substitution Principle (<strong>L</strong>SP)</li>
<li><strong>I</strong>nterface Segregation Principle (<strong>I</strong>SP)</li>
<li><strong>D</strong>ependency Inversion Principle (<strong>D</strong>IP)</li>
</ul>
</div></section>
<p>During its lifetime of a software the (class) design changes constantly. This is a consequence of requirement changes which is the rationale for conducting an iterative design process.</p>
<p>Class Design Principles are not only about the current state of the code, but also give you an understanding of how well the code will be under the effect of change. Especially whether and how changes will affect client classes.<br /></p>
<h2>Single Responsibility Principle</h2>
<section class="slide" data-title="Single Responsibility Principle"><div class="section-body"><h1>Single Responsibility Principle</h1>
<div class="statement">A class should have only one reason to change.</div>
<footer><div class="footer-body"><p>Agile Software Development; Robert C. Martin; Prentice Hall, 2003</p>
</div></footer>
</div></section>
<h3>Example</h3>
<section class="slide"><div class="section-body"><p><strong>What do you think of the following design?</strong></p>
<p><img src="Images/SRP-Rectangle-GUI-GeometryApp-GraphicalApplication.png" alt="Rectangle-GUI-GeometryApp-GraphicalApplication" /></p>
</div></section>
<p>Observation:</p>
<ul>
<li>Rectangle provides a method to draw a rectangle shapes on the screen. For that, Rectangle uses GUI to implement draw().</li>
<li>GeometricApplication is a package for geometrical computations, which also uses Rectangle (area()). </li>
<li><strong>GeometricApplication depends on GUI (GUI has to be deployed along with Rectangle) even if it only needs the geometrical functions of rectangles.</strong></li>
</ul>
<p>Evaluation:</p>
<ul>
<li><p><code>Rectangle</code> has multiple responsibilities!</p>
<ul>
<li>Geometrics of rectangles: <code>area()</code></li>
<li>Drawing of rectangles: <code>draw()</code></li>
</ul>
</li>
<li><code>Rectangle</code> has low cohesion!<br />
It is not a representation of a coherent concept, but a point to bundle needed functionality without consideration of their cohesion. Geometrics and drawing do not naturally belong together. </li>
</ul>
<p>Problems:<br /></p>
<ul>
<li><code>Rectangle</code> has multiple reasons to change.</li>
<li>If drawing functionality changes in the future, we need to retest and redeploy <code>Rectangle</code> in context of <code>GeometricalApplication</code>!</li>
</ul>
<section class="slide"><div class="section-body"><p><strong>A Single-Responsibility Compliant Design</strong></p>
<p><img src="Images/SRP-TwoRectangleClasses.png" alt="A Single-Responsibility Compliant Design" /></p>
</div></section>
<p><strong>Assessment:</strong></p>
<ul>
<li><p>Split responsibilities:</p>
<ul>
<li><code>Rectangle</code> models geometric properties of rectangles.</li>
<li><code>DrawableRectangle</code> models visual properties of graphical rectangles.</li>
</ul>
</li>
<li><p>Computational Geometry Application uses only <code>Rectangle</code>. It only depends on the geometrical aspects.</p>
</li>
<li>GUI uses <code>DrawableRectangle</code> and indirectly <code>Rectangle</code>. It needs both aspects and therefore depends on both.</li>
<li>Both classes can be reused easily!<br />
Only changes to the responsibilities we use will affect us.</li>
<li>Both classes are easily understood!<br />
Each implements one concept.<br />
<code>Rectangle</code> represents a rectangle shape by its geometric properties.<br />
<code>DrawableRectangle</code> represents a rectangle by its visual properties.</li>
</ul>
<h3>Responsibility and Cohesion</h3>
<section class="slide" data-title="Responsibility"><div class="section-body"><h1>Responsibility</h1>
<ul>
<li><p>In general, <strong>a class is assigned the responsibility to know or do something</strong> (one thing).<br />
Examples:</p>
<ul>
<li>Class <code>PersonData</code> is responsible for knowing the data of a person.<br /></li>
<li>Class <code>CarFactory</code> is responsible for creating <code>Car</code> objects.</li>
</ul>
</li>
<li>A responsibility is an axis of change. </li>
<li>A class with only one responsibility has only one reason to change!</li>
</ul>
</div></section>
<p>In general, if new functionality must be achieved, or existing functionality needs to be changed, the responsibilities of classes must be changed.</p>
<section class="slide" data-title="Cohesion"><div class="section-body"><h1>Cohesion</h1>
<ul>
<li><p>Cohesion measures the degree of togetherness among the elements of a class.<br /></p>
</li>
<li><p>In a class with high cohesion every element is part of the implementation of exactly one concept. The elements of the class work together to achieve one common functionality.</p>
</li>
<li><p>A class with high cohesion implements only one responsibility!<br /></p>
</li>
</ul>
</div></section>
<p>Cohesion actually <em>measures</em> the extent to which operations and data within a class belong to the concept this class is representing. Therefore, a class with low cohesion – i.e., a class where the operations and data actually belongs to several concepts – violates the single-responsibility principle.</p>
<p>Common metrics that are defined to measure the cohesion (such as LCOM(*)) are usually not working at the conceptual level and hence, would identify a class such as <code>PersonData</code> that stores information regarding a person and which usually offers a large number of &quot;getter&quot; and &quot;setter&quot; methods as non-cohesive. But, from a conceptual perspective this class is cohesive.</p>
<section class="slide"><div class="section-body"><ul>
<li><p>Applying the single-responsibility principle maximizes the cohesion of classes.</p>
</li>
<li><p>Classes with high cohesion ...</p>
<ul>
<li>can be reused easily,</li>
<li>are easily understood,</li>
<li>protect clients from changes, that should not affect them.</li>
</ul>
</li>
</ul>
</div></section>
<h3>Further Scenarios</h3>
<section class="slide" data-title="The Employee Example"><div class="section-body"><p><strong>Should we split the responsibilities of this class?</strong></p>
<div style="text-align:center">
	<img src="Images/SRP-Employee.png" alt="SRP Employee" />
</div>
</div></section>
<p>The class <code>Employee</code> which has two responsibilities:</p>
<ol>
<li>Calculating an employee’s payment.</li>
<li>Storing employee data in the database.</li>
</ol>
<p>Calculating the payment is part of the business rules. It corresponds to a real-world concept the application shall implement. Storing information in the database is a technical aspect. It is a necessity of the IT architecture that we have selected; does not correspond to a real-world concept.</p>
<p>Mixing business rules and technical aspects is calling for trouble! <strong>From experience</strong>, we know that both aspects are extremely volatile. Hence, most probably we should split the class in this case. </p>
<h3>Application</h3>
<section class="slide" data-title="When to apply the Single-Responsibility Principle?"><div class="section-body"><p>We <strong>should split</strong> a class that has two responsibilities if:</p>
<ul>
<li><p>Both responsibilities will change separately.</p>
</li>
<li><p>The responsibilities are used separately by other classes.</p>
</li>
<li><p>Responsibilities pertain to optional features of the system.</p>
</li>
</ul>
<p>We <strong>should not</strong> split responsibilities if:</p>
<ul>
<li><p>Both responsibilities will only change together, e.g. if they together implement one common protocol.</p>
</li>
<li><p>Both responsibilities are only used together by other classes.</p>
</li>
<li><p>Responsibilities pertain to mandatory features.</p>
</li>
</ul>
<footer><div class="footer-body"><p>This principle also applies at higher-abstraction levels, such as the component-level or the service-oriented layer.</p>
</div></footer>
</div></section>
<h2>Strategic Application of Principles</h2>
<section class="slide"><div class="section-body"><h1>Strategic Application of Principles</h1>
<div class="statement">Only apply a principle, if there is a symptom!</div>
<p>Be agile and modify the design when needed.</p>
</div></section>
<p>Choose the kinds of changes to guide your application of the single-responsibility principle. Guess the most likely kinds of changes derived from experience. Experienced designers hope to know the user and an industry well enough to judge the probability of different kinds of changes.
Invoke the single-responsibility principle against the most probable changes.</p>
<p>An axis of change is an axis of change only if the change actually occurs.</p>
<h3>The Smart Home Example</h3>
<p>In the following we will reason about a typical object-oriented design of a smart home.</p>
<section class="slide" data-title="The Smart Home Example"><div class="section-body"><h1>The Smart Home Example</h1>
<p>A smart home has many features that are controlled automatically:
Heating, Lighting, Shutters,  ...</p>
<p><img src="Images/SRP-SmartHome.png" alt="SRP SmartHome" /></p>
</div></section>
<section class="slide" data-title="The Smart Home Example - Java Solution"><div class="section-body"><p><strong>A prototypical object-oriented solution (Part 1):</strong></p>
<pre><code class="java">abstract class Location {
  private List&lt;Shutter&gt; shutters; // FEATURE: BLANKING
  private List&lt;Light&gt; lights; // FEATURE: LIGHTING

  public Location(List&lt;Shutter&gt; shutters, List&lt;Light&gt; lights) {
  this.shutters = shutters;
  this.lights = lights;
  }

  public List&lt;Shutter&gt; shutters() { return shutters; }
  public List&lt;Light&gt; lights() { return lights; }
}

abstract class CompositeLocation&lt;L extends Location&gt; extends Location {
  private List&lt;L&gt; locations;

  public CompositeLocation(List&lt;L&gt; locations) {
  super(shutters(locations), lights(locations));
  this.locations = locations;
  }
  private static List&lt;Light&gt; lights(List&lt;? extends Location&gt; locs) {…}
  private static List&lt;Shutter&gt; shutters(List&lt;? extends Location&gt; locs) {…}

  public List&lt;L&gt; locations() { return locations; }
}
</code></pre>
</div></section>
<p><code>Location</code> is the base class that declares the functionality that some location can offer (optionally!). Hence, it takes multiple responsibilities.</p>
<section class="slide"><div class="section-body"><p><strong>A prototypical object-oriented solution (Part 2):</strong></p>
<pre><code class="java">class Room extends Location {
  public Room(List&lt;Shutter&gt; shutters, List&lt;Light&gt; lights) {
  super(shutters, lights);
  }
}

class Floor extends CompositeLocation&lt;Room&gt; {
  public Floor(List&lt;Room&gt; locations) { super(locations); }
}

class House extends CompositeLocation&lt;Floor&gt; {
  public House(List&lt;Floor&gt; locations) { super(locations); }
}

class Main {
  public static void main(String[] args) {
  House house = new House(null);
  List&lt;Floor&gt; floors = house.locations();
  }
}
</code></pre>
<p>The question: <strong>Split or Not Split?</strong></p>
</div></section>
<p>In the prototypical solution all (optional) features are declared by the main interface (<code>Location</code>). 
We should split the code, if we want to be able to make functional &quot;packages&quot;, such as heating control, lighting control, or security, optional. Consider, e.g., the case that the provider may want to sell several configurations of a smart home, each with a specific selection of features.<br /></p>
<section class="slide" data-title="The Smart Home Example - Java&apos;s Limitations"><div class="section-body"><p><strong>Sketching a solution if would like to split (Part 1):</strong></p>
<pre><code class="java">public interface Location { }

interface CompositeLocation&lt;L extends Location&gt; extends Location {
	abstract List&lt;L&gt; locations();
}

class Room implements Location { }

class Floor implements CompositeLocation&lt;Room&gt; {
	private List&lt;Room&gt; rooms;

	public List&lt;Room&gt; locations() { return rooms; }
}

class House implements CompositeLocation&lt;Floor&gt; {
	private List&lt;Floor&gt; floors;

	public List&lt;Floor&gt; locations() { return floors; }
}
</code></pre>
</div></section>
<p>So far we are just modeling the basic structure of a building (<code>House</code>).</p>
<section class="slide"><div class="section-body"><p><strong>Sketching a solution if would like to split (Part 2):</strong></p>
<pre><code class="java">interface LightedLocation extends Location {
  List&lt;Light&gt; lights();
}

class LightedRoom extends Room implements LightedLocation {
  private List&lt;Light&gt; lights;
  public List&lt;Light&gt; lights() { return lights; }
}

abstract class LightedCompositeLocation&lt;LL extends LightedLocation&gt;
  implements CompositeLocation&lt;LL&gt; {

  public List&lt;Light&gt; lights() {
    List&lt;Light&gt; lights = new ArrayList&lt;Light&gt;();
    for (LightedLocation child : locations()) 
      lights.addAll(child.lights());
    return lights;
  }
}
</code></pre>
<p><img src="Images/InTheRain.png" alt="InTheRain" /></p>
</div></section>
<p>Given the shown code/the proposed solution, we can identify several issues:</p>
<ul>
<li><code>class LightedFloor extends ...</code><br />
The class should inherit from (<code>LightedCompositeLocation</code> and <code>Floor</code>) ? (we don&apos;t want code duplication!)</li>
<li><code>class LightedHouse extends ...</code><br />
The class should inherit from ? (we don&apos;t want code duplication!)</li>
<li>Imagine that we have another additional feature; e.g., shutters and we want to avoid code duplication!</li>
</ul>
<div class="statement">Ideally, we would like to have several versions of class definitions - one per responsibility - which can be “mixed and matched” as needed.</div>
<aside><div class="aside-body"><p>Additional downloads:</p>
<ul>
<li><a href="Code/src/srp/java/r0/Location.java">The complete source code of the prototypical Java version.</a></li>
<li><a href="Code/src/srp/java/r1/Location.java">The complete source code of the sketched Java version.</a></li>
</ul>
</div></aside>
<section class="slide" data-title="The Smart Home Example - Scala Basis"><div class="section-body"><p><strong>Splitting up using Scala (Java Inspired Base):</strong></p>
<pre><code class="scala">trait Shutter
trait Light

abstract class Location {
  def shutters: List[Shutter]
  def lights: List[Light]
}

class Room(
  val lights: List[Light],
  val shutters: List[Shutter]) extends Location

abstract class CompositeLocation[L &lt;: Location] extends Location {
  def lights: List[Light] = locations.flatMap(_.lights)
  def shutters: List[Shutter] = locations.flatMap(_.shutters)
  def locations: List[L]
}

class Floor(val locations: List[Room]) extends CompositeLocation[Room]

class House(val locations: List[Floor]) extends CompositeLocation[Floor]

object Main extends App {
  val house = new House(new Floor(new Room(Nil, Nil) :: Nil) :: Nil)
  val floors: List[Floor] = new House(Nil).locations
}
</code></pre>
</div></section>
<section class="slide" data-title="The Smart Home Example - Scala Solution"><div class="section-body"><p><strong>Splitting up using Scala (Base):</strong></p>
<pre><code class="scala">trait Base {
  trait Location {}
  type location &lt;: Location

  trait Room extends Location 
  type room &lt;: Room
  def createRoom(): room // factory method

  trait CompositeLocation[L &lt;: Location] extends Location {
    def locations: List[L]
  }

  trait Floor extends CompositeLocation[room]
  type floor &lt;: Floor
  def createFloor(locations: List[room]): floor // factory method

  trait House extends CompositeLocation[floor]
  type house &lt;: House
  def createHouse(locations: List[floor]): house // factory method

  def buildHouse(specification: String): house = {
    // imagine to parse the specification...
    createHouse(List(createFloor(List(createRoom()))))
  }
}
</code></pre>
</div></section>
<p>Note, that the <code>buildHouse</code> method constructs a house object though the concrete type is not yet known.</p>
<p>What we want to achieve is that:</p>
<ul>
<li>Features that are developed independently (such as heating, cooling or lighting) can be (freely) combined </li>
<li>The solution is type safe even in the presence of new optional features (which requires appropriate support by the available programming language)</li>
<li>We do not duplicate code (Copy &amp; Paste programming).</li>
</ul>
<p>Additionally, the underlying programming language should also support separate compilation to enable us to deploy our solution independently.</p>
<section class="slide"><div class="section-body"><p><strong>Splitting up using Scala (Lighting Feature):</strong></p>
<pre><code class="scala">trait Lighten { def lights(): List[Light] }

trait Lighted extends Base {

  trait Location extends super.Location with Lighten {
    def turnLightsOn = lights.foreach(_.turnOn())
    def turnLightsOff = lights.foreach(_.turnOff())
  }
  type location &lt;: Location

  trait Room extends super.Room with Location
  type room &lt;: Room

  trait CompositeLocation[L &lt;: Location] 
    extends super.CompositeLocation[L] 
       with Location {
    def lights: List[Light] = locations.flatMap(_.lights())
  }

  trait Floor extends super.Floor with CompositeLocation[room]
  type floor &lt;: Floor

  trait House extends super.House with CompositeLocation[floor]
  type house &lt;: House
}
</code></pre>
</div></section>
<section class="slide"><div class="section-body"><p><strong>Splitting up using Scala (Combining Features):</strong></p>
<pre><code class="scala">// Dimmed is similar to Lighted
trait LightedAndDimmed extends Lighted with Dimmed {

  trait Location 
    extends super[Lighted].Location with super[Dimmed].Location
  type location &lt;: Location

  trait Room 
    extends super[Lighted].Room with super[Dimmed].Room 
       with Location
  type room &lt;: Room

  trait CompositeLocation[L &lt;: Location]
    extends super[Lighted].CompositeLocation[L]
       with super[Dimmed].CompositeLocation[L]
       with Location

  trait Floor 
    extends super[Lighted].Floor with super[Dimmed].Floor 
       with CompositeLocation[room]
  type floor &lt;: Floor
  // also for House...
}
</code></pre>
<footer><div class="footer-body"><p>Scala does not directly support deep, nested mixin composition.</p>
</div></footer>
</div></section>
<section class="slide"><div class="section-body"><p><strong>Splitting up using Scala (Using Our Combined):</strong></p>
<pre><code class="scala">object LightedAndDimmedBuilding extends LightedAndDimmed with App {

  type location = Location
  type room = Room
  type floor = Floor
  type house = House

  def createRoom(): room = 
    new Room {  var lights: List[Light] = Nil; 
	        var shutters: List[Shutter] = Nil }
  def createFloor(rooms: List[room]): floor = 
    new Floor { val locations = rooms }
  def createHouse(floors: List[floor]): house = 
    new House { val locations = floors }

  // Demo 
  val h = buildHouse(&quot;three floors with 6 rooms each&quot;)
  h.lights
  h.shutters
  h.locations
  h.turnLightsOn
}
</code></pre>
</div></section>
<p>Basically, in the first 4 lines we create type aliases for location, room, floor and house which &quot;fixes&quot; our abstract type definitions. After that we implement the factory methods as required. For the method parameter types and return types, we still use the names of the type definitions. </p>
<aside><div class="aside-body"><p>Additional downloads:</p>
<ul>
<li><p><a href="Code/src/srp/scala/SmartHome.zip">The complete scala source code.</a></p>
</li>
</ul>
<p>Further information: </p>
<ul>
<li><p><a href="http://www.scala-lang.org/docu/files/IC_TECH_REPORT_200433.pdf">Independently Extensible Solutions to the Expression Problem</a></p>
</li>
</ul>
</div></aside>
<h3>Summary</h3>
<section class="slide" data-title="Strategic Application of Principles - Summary"><div class="section-body"><div class="statement">A class should have only one reason to change.</div>
<p>Applying the single-responsibility principle maximizes the cohesion of classes.</p>
<ul>
<li><p>Classes with high cohesion </p>
<ul>
<li>can be reused easily,</li>
<li>are easily understood,</li>
<li>protect clients from changes, that should not affect them.</li>
</ul>
</li>
</ul>
<p><strong>But, be strategic in applying the single-responsibility principle.</strong><br /></p>
</div></section>
<p>Carefully study the context and make informed trade-offs. Guess most likely axes of change and separate along them. Be agile: Only apply the single-responsibility principle when needed.</p>
<p>As we have seen in the previous example, achieving the desired separation may not be straightforward with typical object-oriented mechanisms.</p>
<h2>Open-Closed Principle</h2>
<section class="slide" data-title="Open-Closed Principle"><div class="section-body"><h1>Open-Closed Principle</h1>
<div class="statement">Software entities (classes, modules, functions, components, etc.) should be open for extension, but closed for modifications.</div>
<p><strong>Extension</strong>: Extending the behavior of a module.</p>
<p><strong>Modification</strong>: Changing the code of a module.</p>
</div></section>
<h3>Extension and Modification</h3>
<section class="slide" data-title="Extension and Modification"><div class="section-body"><div class="statement">Why is it important to be closed for modifications?</div>
</div></section>
<p><em>Open for extension</em> means that when requirements of the application change, we can extend the module with new behaviors that reflect those changes. We change what the module does.</p>
<p><em>Closed for modification</em> means that changes in behavior do not result in changes in the module&apos;s source or binary code.</p>
<p>Several reasons for closing modules against changes:</p>
<ul>
<li>The module was delivered to customers and a change will not be accepted. If you need to change something later, hopefully you opened your module for extension!</li>
<li>The module is a third-party Library/Framework and only available as binary code. If you need to change something, hopefully the third-party opened the module for extension!</li>
<li><strong>Most importantly</strong>: not changing existing code means modular compilation, testing and debugging. </li>
</ul>
<h3>Abstraction is the Key</h3>
<section class="slide" data-title="Abstraction is the Key"><div class="section-body"><h1>Abstraction is the Key</h1>
<div class="statement">To enable extending an entity without modifying it, abstract over subparts of its behavior.</div>
<blockquote><p>Many programming languages allow to create abstractions that are fixed and yet represent an unbounded group of possible behaviors!</p>
</blockquote>
</div></section>
<p>Different kinds of abstraction mechanisms exist:</p>
<ul>
<li><p>Object-oriented languages:</p>
<ul>
<li>abstractions are encoded in abstract base classes resp. interfaces.</li>
<li>unbounded group of possible behaviors is represented by all the possible derivative classes resp. implementations.</li>
</ul>
</li>
<li><p>Functional languages:</p>
<ul>
<li>abstractions are encoded in function types.</li>
<li>unbounded group of possible behaviors is represented by all the possible first-class functions of the declared type.</li>
</ul>
</li>
</ul>
<p>In the following, we shortly discuss the two main ways of abstracting over variability in object-oriented programs.</p>
<section class="slide" data-title="Abstracting Over Variations"><div class="section-body"><h1>Abstracting Over Variations</h1>
<p><img src="Images/OCP-Container.png" alt="OCP Container" /></p>
</div></section>
<ul>
<li><code>Container</code> declares the layout functionality but does not implement it. The rest of <code>Container</code> is implemented against the abstraction.</li>
<li>Concrete subclasses fill in the details over which <code>Container</code>’s implementation abstract.</li>
</ul>
<section class="slide" data-title="Abstracting Over Variations"><div class="section-body"><h1>Abstracting Over Variations</h1>
<p><img src="Images/OCP-Container-LayoutManager.png" alt="OCP Container LayoutManager" /></p>
</div></section>
<ul>
<li><code>Container</code> delegates the layout functionality to an abstraction. The rest of its functionality is implemented against this abstraction.</li>
<li>To change the behavior of an instance of <code>Container</code> we configure it with the <code>LayoutManager</code> of our choice.</li>
<li>We can add completely new behavior by implementing our own <code>LayoutManager</code>.</li>
</ul>
<h3>Understanding the Open-Closed Principle</h3>
<section class="slide" data-title="Drawable Shapes - Initial Design"><div class="section-body"><h1>A Possible Design for Drawable Shapes</h1>
<p><img src="Images/OCP-ShapeInitialDesign.png" alt="OCP Shape" /></p>
<footer><div class="footer-body"><p>Drawing is implemented in separate methods (e.g., of class <code>Application</code>).</p>
</div></footer>
</div></section>
<ul>
<li>Each <code>Shape</code> identifies itself via the enumeration <code>ShapeType</code>.</li>
<li>Realizations of <code>Shape</code> declare specialized methods for the shape type they represent.</li>
</ul>
<section class="slide"><div class="section-body"><p><strong>Consider an application that draws shapes - circles and rectangles – on a standard GUI.</strong></p>
<p><img src="Images/OCP-SketchVectorDrawingApp.png" alt="OCP SketchVectorDrawingApp" /></p>
</div></section>
<section class="slide"><div class="section-body"><p><strong>Implementation of the drawing functionality:</strong></p>
<pre><code class="java">class Application {
  public void drawAllShapes(List&lt;Shape&gt; shapes) {
    for(Shape shape : shapes) {
      switch(shape.getType()) {
      case Circle:
        drawCircle((Circle)shape);
        break;
      case Rectangle:
        drawRectangle((Rectangle)shape);
        break;
  } } }

  private void drawCircle(Circle circle) { ... }

  private void drawRectangle(Rectangle rectangle) { ... }
}
</code></pre>
<p>Does this design conform to the open-closed design principle?</p>
</div></section>
<p><strong>Evaluating the proposed design:</strong></p>
<ul>
<li><p>Adding new shapes is hard, we need to:</p>
<ul>
<li>Implement a new realization of <code>Shape</code>.</li>
<li>Add a new member to <code>ShapeType</code>.<br />
This possibly leads to a recompile of all other realizations of <code>Shape</code>.</li>
<li><code>drawAllShapes</code> (and every method that uses shapes of different types) must be changed.<br />
We have to hunt for every place that contains conditional logic that distinguishes between types of shapes and we have to add code to it.</li>
</ul>
</li>
<li><code>drawAllShapes</code> is hard to reuse!<br />
When we reuse it, we have to bring along <code>Rectangle</code> and <code>Circle</code>.</li>
</ul>
<section class="slide" data-title="Rigid, Fragile, Immobile Designs"><div class="section-body"><h1>Rigid, Fragile and Immobile Designs</h1>
<ul>
<li><p><strong>Rigid designs</strong> are hard to change – every change causes many changes to other parts of the system.</p>
</li>
<li><p><strong>Fragile designs</strong> tend to break in many places when a single change is made. </p>
</li>
<li><p><strong>Immobile designs</strong> contain parts that could be useful in other systems, but the effort and risk involved with separating those parts from the original system are too big.</p>
</li>
</ul>
<p>When we evaluate our design, does it show signs of rigidity, fragility or immobility?</p>
</div></section>
<section class="slide"><div class="section-body"><h1>Evaluating the Design</h1>
<ul>
<li><p>Our design is rigid, fragile and immobile.</p>
</li>
<li><p>The proposed design <strong>violates the open-closed design principle</strong> with respect to extensions with new kinds of shapes.</p>
</li>
<li><p>We need to close our module against this kind of change by building appropriate abstractions.</p>
</li>
</ul>
</div></section>
<p>Assessing our design w.r.t. its rigidity, fragility and immobility:</p>
<ul>
<li>Our example design <strong>is rigid</strong>: Adding a new shape causes many existing classes to be changed.</li>
<li>Our example design <strong>is fragile</strong>: Many switch/case (if/else) statements that are both hard to find and hard to decipher.</li>
<li>Our example design <strong>is immobile</strong>: <code>drawAllShapes</code> is hard to reuse.</li>
</ul>
<section class="slide" data-title="Drawable Shapes - Refined Design"><div class="section-body"><h1>Refined Design for Drawable Shapes</h1>
<p><img src="Images/OCP-ShapeOCPConformDesign.png" alt="OCP ShapeOCPConformDesign" /></p>
</div></section>
<ul>
<li><p>Makes adding new shapes possible without modification.<br />
We just need to implement a new realization of <code>Shape</code>.</p>
</li>
<li><p><code>drawAllShapes</code> only depends on <code>Shape</code>.<br />
We can reuse it unchanged.</p>
</li>
</ul>
<section class="slide"><div class="section-body"><h1>Evaluating the Extensibility</h1>
<div class="statement">This solution complies to the open-closed design principle.</div>
<footer><div class="footer-body"><p>Is this unconditional statement correct?</p>
</div></footer>
</div></section>
<p>This unconditional statement is – of course – not correct. It is not possible to be open for all kinds of extension and also be closed for modification.</p>
<section class="slide"><div class="section-body"><h1>Other Kinds of Changes</h1>
<p><img src="Images/OCP-ShapeOCPConformDesign.png" alt="OCP ShapeOCPConformDesign" />
These abstractions are more of an hindrance to several other kinds of changes.</p>
</div></section>
<ul>
<li><p>Consider extending the design with further shape functions:</p>
<ul>
<li>shape transformations, shape dragging, …</li>
<li>calculating the intersection or union of shapes, etc.</li>
</ul>
</li>
<li>Consider adding support for different operating systems.<br />
The implementation of the drawing functionality varies for different operating systems.</li>
</ul>
<section class="slide"><div class="section-body"><div class="statement">Abstractions May <strong>Support</strong> or <strong>Hinder</strong> Change!</div>
</div></section>
<ul>
<li>Change is easy if change units correspond to abstraction units.<br />
In our example, adding a new type of <code>Shape</code> is easy as it is directly supported by inheritance and subtyping.</li>
<li>Change is tedious if change units do not correspond to abstraction units.</li>
</ul>
<aside><div class="aside-body"><p>Consider again the Scala-based implementation of our SmartHome scenario. In the given design it is easily possible to add support for a new type of <code>Location</code>, but adding new functionality – while still being possible – is harder as seen in the previous example.</p>
<p>For example, adding support for a new type of <code>Room</code> is straightforward:</p>
<pre><code class="scala">trait LightedAndDimmedRealEstate extends LightedAndDimmed {
  trait Garage extends Location
}

object MyLightedAndDimmedEstate extends LightedAndDimmedRealEstate {

  type location = Location
  type room = Room
  type floor = Floor
  type house = House

  def createRoom(): room = new Room { var lights: List[Light] = Nil; var shutters: List[Shutter] = Nil }
  def createFloor(rooms: List[room]): floor = new Floor { val locations = rooms }
  def createHouse(floors: List[floor]): house = new House { val locations = floors }

  class Garage(val lights: List[Light] = Nil, val shutters: List[Shutter] = Nil) extends super.Garage

  val garage = new Garage(Nil, Nil)
  garage.turnLightsOff
  garage.turnLightsOn
}
</code></pre>
</div></aside>
<h3>Abstractions Reflect a Viewpoint</h3>
<section class="slide" data-title="Abstractions Reflect a Viewpoint"><div class="section-body"><h1>Abstractions Reflect a Viewpoint</h1>
<div class="statement">No matter how “closed” a module is, there will always be some kind of change against which it is not closed.</div>
<footer><div class="footer-body"><p>There is no model that is natural to all contexts.</p>
</div></footer>
</div></section>
<section class="slide" data-title="On the &quot;Natural&quot; Model Structure"><div class="section-body"><h1>On the &quot;Natural&quot; Model Structure</h1>
<p>Imagine: Development of a &quot;Zoo Software&quot;.</p>
<p>Three stakeholders:</p>
<ul>
<li>Veterinary surgeon: <strong>What matters is how animals reproduce!</strong></li>
<li>Trainer: <strong>What matters is the intelligence!</strong></li>
<li>Keeper: <strong>What matters is what they eat!</strong></li>
</ul>
</div></section>
<section class="slide"><div class="section-body"><p><strong>One Possible Class Hierarchy When Modeling Animals</strong></p>
<p><img src="Images/OCP-Animals.png" alt="OCP Animals" /></p>
<footer><div class="footer-body"><p>Do you see a problem?</p>
</div></footer>
</div></section>
<p>When we consider the classes <code>Oviparous</code> and <code>Mammal</code> it is obvious that the class hierarchy reflects the veterinary surgeon&apos;s understanding.</p>
<section class="slide"><div class="section-body"><p><strong>The Animal World From a Trainer&apos;s Viewpoint</strong></p>
<blockquote><p>“The show shall start with the pink pelicans and the African geese <strong>flying</strong> across the stage. They are to land at one end of the arena and then <strong>walk</strong> towards a small door on the side. At the same time, a killer whale should <strong>swim</strong> in circles and <strong>jump</strong> just as the pelicans fly by. After the jump, the sea lion should <strong>swim</strong> past the whale, <strong>jump</strong> out of the pool, and <strong>walk</strong> towards the center stage where the announcer is waiting for him.”</p>
</blockquote>
<p><img src="Images/OCP-Animals-Show.png" alt="OCP Animals Show" /></p>
</div></section>
<section class="slide"><div class="section-body"><p><strong>Models Reflecting Different Viewpoints Overlap</strong></p>
<p><img src="Images/OCP-Animals-Viewpoints.png" alt="OCP Animals Viewpoints" /></p>
</div></section>
<ul>
<li>Elements of a category in one model correspond to several categories in the other model (and vice versa).</li>
<li>Adopting the veterinary viewpoint hinders changes concerning trainer’s viewpoint (and vice versa). </li>
</ul>
<section class="slide" data-title="Limitations of Current Programming Languages When Modeling Co-Existing Viewpoints"><div class="section-body"><div class="statement">Current programming languages and tools do not well support modeling the world based on co-existing viewpoints.</div>
<footer><div class="footer-body"><p>No matter how “closed” a module is, there will always be some kind of change against which it is not closed.</p>
</div></footer>
</div></section>
<p>Using a programming language which offers more advanced modeling mechanisms, it may be possible to create a design that more closely models the presented world. </p>
<h3>Strategic and Agile Closure</h3>
<section class="slide" data-title="OCP - Strategic Closure"><div class="section-body"><h1>Strategic Closure</h1>
<ul>
<li><p>Choose the kinds of changes against which to close your module.</p>
<ul>
<li>Guess at the most likely kinds of changes.</li>
<li>Construct abstractions to protect against those changes.</li>
</ul>
</li>
<li><p>Prescience derived from experience:</p>
<ul>
<li>Experienced designers hope to know the user and an industry well enough to judge the probability of different kinds of changes.</li>
<li>Invoke open-closed principle against the most probable changes.</li>
</ul>
</li>
</ul>
</div></section>
<section class="slide" data-title="OCP - Be Agile"><div class="section-body"><h1>Be Agile</h1>
<blockquote><p>Recall that guesses about the likely kinds of changes to an application over time will often be wrong. </p>
</blockquote>
<p>Conforming to the open-closed principle is expensive:</p>
<ul>
<li>Development time and effort to create the appropriate abstractions </li>
<li><p>Created abstractions might increase the complexity of the design.</p>
<ul>
<li>Needless, Accidental Complexity. </li>
<li>Incorrect abstractions supported/maintained even if not used.</li>
</ul>
</li>
</ul>
<p><strong>Be agile: Wait for changes to happen and close against them.</strong></p>
</div></section>
<section class="slide" data-title="OCP - Takeaway"><div class="section-body"><h1>Takeaway</h1>
<blockquote><p>Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modifications.<br /></p>
<p>Bertrand Meyer, 1988</p>
</blockquote>
<ul>
<li>Abstraction is the key to supporting the open-closed design principle.</li>
<li>No matter how “closed” a module is, there will always be some kind of change against which it is not closed.</li>
</ul>
</div></section>
<h2>Liskov Substitution Principle (LSP)</h2>
<p>External resource: <a href="http://www.objectmentor.com/resources/articles/lsp.pdf">The Liskov Substitution Principle: www.objectmentor.com/resources/articles/lsp.pdf</a></p>
<h3>The Essence of the Liskov Substitution Principle</h3>
<section class="slide" data-title="Liskov Substitution Principle"><div class="section-body"><h1>Liskov Substitution Principle</h1>
<div class="statement">Subtypes must be behaviorally substitutable for their base types.</div>
<p>Barbara Liskov, 1988<br />
(received the ACM Turing Award)</p>
</div></section>
<section class="slide" data-title="The Essence of the Liskov Substitution Principle"><div class="section-body"><blockquote><p>We identified class inheritance and subtype polymorphism as primary mechanisms for supporting the open-closed principle in object-oriented designs. </p>
</blockquote>
<hr />
<p>The Liskov Substitution Principle:</p>
<ul>
<li>gives us a way to <strong>characterize good inheritance hierarchies</strong>,<br /></li>
<li>increases our awareness about traps that will cause us to create hierarchies that do not conform to the open-closed principle.</li>
</ul>
</div></section>
<h3>Substitutability in object-oriented programming languages</h3>
<section class="slide" data-title="Substitutability in object-oriented programming languages"><div class="section-body"><h1>Substitutability in object-oriented programms</h1>
<p><img src="Images/LSP-SomeClass.png" alt="LSP SomeClass" /></p>
<pre><code class="java">void clientMethod(SomeClass sc) {
  …
  sc.someMethod();
  …
}
</code></pre>
</div></section>
<p>In object-oriented programs, subclasses are substitutable for superclasses in client code: In <code>clientMethod</code>, <code>sc</code> may be an instance of <code>SomeClass</code> or any of its subclasses. <br />
Hence, if <code>clientMethod</code> works with instances of <code>SomeClass</code>, it does so with instances of any subclass of <code>SomeClass</code>. They provide all methods of <code>SomeClass</code> and eventually more. </p>
<section class="slide" data-title="LSP by Example"><div class="section-body"><h1>Liskov Substitution Principle by Example</h1>
<p>Assume, we have implemented a class <code>Rectangle</code> in our system. </p>
<pre><code class="java">class Rectangle {
  public void setWidth(int width) {
    this.width = width;
  }
  public void setHeight(int height) {
    this.height = height;
  }
  public void area() {return height * width;}
  …
}
</code></pre>
<p>Let&apos;s now assume that we want to implement a class <code>Square</code> and want to maximize reuse.</p>
</div></section>
<p>Since a square is a rectangle (mathematically speaking), we decided to implement <code>Square</code> as a subclass of <code>Rectangle</code>. </p>
<p>We override <code>setWidth</code> and <code>setHeight</code> and can reuse the implementation of <code>area</code>.</p>
<section class="slide"><div class="section-body"><p><strong>Implementing <code>Square</code> as a subclass of <code>Rectangle</code>:</strong></p>
<pre><code class="java">class Square extends Rectangle {
  public void setWidth(int width) {
  	super.setWidth(width);
  	super.setHeight(width);
  }
  public void setHeight(int height) {
  	super.setWidth(height);
  	super.setHeight(height);
  }
  …
}
</code></pre>
<p>  <img src="Images/LSP-SquareAndRectangle.png" style="position:absolute;top:120px;left:550px"></p>
<p>With this overriding of <code>setHeight</code> and <code>setWidth</code> – to set both dimensions to the same value – instances of <code>Square</code> remain mathematically valid squares.</p>
<p>This model is self-consistent!</p>
<p>We can pass <code>Square</code> wherever <code>Rectangle</code> is expected.</p>
<footer><div class="footer-body"><p>What do you think of this design?</p>
</div></footer>
</div></section>
<p>A square does comply to the mathematical properties of a rectangle: A square has four edges and only right angles and is therefore a rectangle.</p>
<p>We can indeed pass <code>Square</code> wherever <code>Rectangle</code> is expected, as far as the Java type system is concerned. </p>
<p>But, by doing so we may break assumptions that clients of <code>Rectangle</code> make about the “behavior” of a <code>Rectangle</code>.</p>
<section class="slide"><div class="section-body"><p><strong>A client that works with instances of <code>Rectangle</code>, but breaks when instances of <code>Square</code> are passed to it:</strong></p>
<pre><code class="java">void clientMethod(Rectangle rec) {
  rec.setWidth(5);
  rec.setHeight(4);
  assert(rec.area() == 20);
}
</code></pre>
<p>  <img src="Images/LSP-SquareAndRectangle.png" style="position:absolute;top:120px;left:550px"></p>
<p><img src="Images/InTheRain.png" alt="InTheRain" /></p>
</div></section>
<p>The <code>clientMethod</code> method makes an assumption that is true for <code>Rectangle</code>: setting the <em>width</em> respectively <em>height</em> has no effect on the other attribute. This assumption does not hold for <code>Square</code>.</p>
<p>The <code>Rectangle</code>/<code>Square</code> hierarchy violates the Liskov Substitution Principle (LSP)!
<code>Square</code> is behaviorally not a correct substitution for <code>Rectangle</code>.</p>
<p>A <code>Square</code> <strong>does not comply with the behavior</strong> of a rectangle: Changing the height/width of a square behaves differently from changing the height/width of a rectangle. Actually, it doesn&apos;t make sense to distinguish between the width and the height of a square.</p>
<section class="slide" data-title="Software Is All About Behavior"><div class="section-body"><h1>Software Is All About Behavior</h1>
<div class="statement">Programmers do not define entities that are something, but entities that behave somehow.</div>
</div></section>
<section class="slide" data-title="Validity is not Intrinsic"><div class="section-body"><h1>Validity is not Intrinsic</h1>
<blockquote><p>Inspecting the Square/Rectangle hierarchy in isolation did not show any problems. In fact it even seemed like a self-consistent design.<br />
We had to inspect the clients to identify problems.</p>
</blockquote>
<hr />
<ul>
<li><p>A model viewed in isolation can not be meaningfully validated!<br />
The validity of a model depends on the clients that use it.</p>
</li>
<li><p>Hence, the validity of a model must be judged against the possible uses of the model.<br />
We need to anticipate the assumptions that clients will make about our classes.</p>
</li>
</ul>
</div></section>
<p>To get a LSP compliant solution, we make <code>Rectangle</code> and <code>Square</code> siblings.
We introduce the interface <code>Shape</code> to bundle common methods.</p>
<section class="slide" data-title="Rectangles and Square - LSP Compliant Solution"><div class="section-body"><p><strong>Rectangles and Square - LSP Compliant Solution</strong></p>
<p><img src="Images/LSP-SquareAndRectangle-LSPCompliant.png" alt="LSP SquareAndRectangle LSPCompliant" /></p>
</div></section>
<ul>
<li>Clients of <code>Shape</code> cannot make any assumptions about the behavior of setter methods.</li>
<li>When clients want to change properties of the shapes, they have to work with the concrete classes.</li>
<li>When clients work with the concrete classes, they can make true assumptions about the computation of the area.</li>
</ul>
<section class="slide" data-title="LSP and Subtyping Rules"><div class="section-body"><div class="statement">So what does the Liskov Substitution Principle add to the common object-oriented  subtyping rules?</div>
</div></section>
<section class="slide"><div class="section-body"><p><img src="Images/LSP-SomeClass.png" alt="LSP SomeClass" /></p>
<p>It’s not enough that instances of <code>SomeSubclass1</code> and <code>SomeSubclass2</code> provide all methods declared in <code>SomeClass</code>. 
<strong>These methods should also behave like their heirs.</strong></p>
<p>A client method should not be able to distinguish the behavior of objects of <code>SomeSubclass1</code> and <code>SomeSubclass2</code> from that of objects of <code>SomeClass</code>.</p>
<div class="statement">The Liskov Substitution Principle additionally requires behavioral  substitutability. </div>
</div></section>
<section class="slide" data-title="Behavioral Subtyping"><div class="section-body"><h1>Behavioral Subtyping</h1>
<div class="statement"><code>S</code> is a behavioral subtype of <code>T</code>, if objects of type <code>T</code> in a program <code>P</code> may be replaced by objects of type <code>S</code> without altering any of the properties of <code>P</code>.</div>
</div></section>
<h3>Liskov Substitution Principle and Open-closed Principle</h3>
<section class="slide" data-title="The Relation between LSP and OCP"><div class="section-body"><h1>The Relation between LSP and OCP</h1>
<p>Consider a function <code>f</code> parameterized over type <code>T</code> </p>
<ul>
<li><code>S</code> is a derivate of <code>T</code>. </li>
<li>when passed to <code>f</code> in the guise of objects of type <code>T</code>, objects of type <code>S</code> cause <code>f</code> to misbehave.</li>
<li><code>S</code> violates the Liskov Substitution Principle. </li>
</ul>
<div class="statement"><code>f</code> is fragile in the presence of <code>S</code>; i.e.,	<code>f</code> is not closed against derivations of <code>T</code> anymore.</div>
</div></section>
<p>When a developer encounters such code in a real project, the developer of <code>f</code> will most probably put a test to ensure that instances of <code>S</code> are treated properly.</p>
<section class="slide"><div class="section-body"><div class="statement">Can you think of straightforward examples of violations of the Liskov Substitution Principle?</div>
</div></section>
<p>Straightforward examples of violations of the Liskov Substitution Principle.</p>
<ul>
<li>Derivates that override a method of the superclass by an empty method.</li>
<li>Derivates that document that certain methods inherited from the superclass should not be called by clients.</li>
<li>Derivates that throw additional (unchecked) exceptions.</li>
<li>…</li>
</ul>
<h3>More (Sophisticated) Examples of LSP Violations</h3>
<p>In the following, we will mention some “obvious means” of introducing LSP violations (also in Java‘s platform classes) and will consider a more sophisticated example.</p>
<section class="slide" data-title="LSP Violations in the JDK"><div class="section-body"><p><strong>The class Properties inherits from Hashtable</strong></p>
<p>From the JavaDoc:</p>
<blockquote><p>Because <code>Properties</code> inherits from <code>Hashtable</code>, the <code>put</code> and <code>putAll</code> methods can be applied to a <code>Properties</code> object. Their use is strongly discouraged as they allow the caller to insert entries whose keys or values are not <code>Strings</code>. The <code>setProperty</code>  method should be used instead. If the store or save method is called on a &quot;compromised&quot; <code>Properties</code> object that contains a non-String key or value, the call will fail.</p>
</blockquote>
</div></section>
<section class="slide" data-title="LSP and Persistent Set"><div class="section-body"><h1>Implementing a Persistent Set</h1>
<p><strong>Situation:</strong> 
We have implemented a library of container classes, including the interface <code>Set</code> (e.g. using Java 1.4). We want to extend the library with support for persistent sets.</p>
<p>A third-party container class capable of persistence, <code>PersistentSet</code>, is available. It accepts objects of type <code>PersistentObject</code>. </p>
<p><img src="Images/LSP-PersistentSet.png" alt="LSP PersistentSet" /></p>
</div></section>
<section class="slide"><div class="section-body"><h1>Implementing a Persistent Set</h1>
<p><img src="Images/LSP-PersistentSetNoSolution.png" alt="LSP PersistentSetNoSolution" /></p>
<footer><div class="footer-body"><p>Do you see a problem?</p>
</div></footer>
</div></section>
<p>We implement <code>PersistentSetAdapter</code>. It implements <code>Set</code>, refers to an object of the class <code>PersistentSet</code>, <code>ps</code>, and implements <code>Set</code> operations by forwarding to <code>ps</code>.</p>
<p>Only <code>PersistentObjects</code> can be added to <code>PersistentSet</code>. Yet, nothing in <code>Set</code> states this explicitly.</p>
<section class="slide"><div class="section-body"><h1>Implementing a Persistent Set</h1>
<h2>A client that breaks our design</h2>
<p>A client method:</p>
<pre><code class="java">public void fill(Set s) {
  fill-the-set-with-arbitrary-objects
}
</code></pre>
<p>Somewhere else:</p>
<pre><code class="java">Set s = new PersistentSetAdapter(); // Problem!

fill(s);
</code></pre>
</div></section>
<p>Assessment:<br /></p>
<ul>
<li><code>fill</code> has no idea whether the set passed to it is persistent and cannot know that the elements to fill must be of type <code>PersistentObject</code>.</li>
<li>Adding an arbitrary object causes the cast in <code>PersistentSetAdapter</code> to fail.</li>
<li>A method that worked fine before <code>PersistentAdpaterSet</code> was introduced (<code>fill</code>) breaks, when we introduce <code>PersistentAdpaterSet</code>.</li>
</ul>
<section class="slide"><div class="section-body"><h1>Implementing a Persistent Set</h1>
<h2>A Liskov Substitution Principle compliant solution</h2>
<p><img src="Images/LSP-PersistentSetSolution.png" alt="LSP PersistentSetSolution" /></p>
</div></section>
<p>Conclusion:
<code>PersistentSetAdapter</code> does not have a behavioral IS-A relationship to <code>Set</code>. Hence, we must separate their hierarchies and make them siblings.</p>
<h3>Mechanisms for Supporting the Liskov Substitution Principle</h3>
<section class="slide" data-title="Mechanisms that support LSP"><div class="section-body"><div class="statement">What mechanisms can we use to support LSP?</div>
<p>Recall:</p>
<blockquote><p>A model viewed in isolation cannot be meaningfully validated with respect to LSP!
Validity must be judged from the perspective of possible usages of the model. </p>
</blockquote>
</div></section>
<p>Hence, we need to anticipate assumptions that clients make about our models – which is de facto impossible. Most of the times we will only be able to view our model in isolation; we do not know how it will be used and how it will be extended by means of inheritance.</p>
<p>Trying to anticipate them all might yield needles complexity.</p>
<h4>Introduction to Design-by-Contract</h4>
<section class="slide" data-title="Design by Contract"><div class="section-body"><div class="statement">Design by Contract</div>
<p>Solution to the validation problem: A technique for <strong>explicitly stating what may be assumed</strong>. </p>
<p>Two main aspects of design-by-contract:</p>
<ul>
<li>We can specify <strong>contracts</strong> using Pre-, Post-Conditions and Invariants.<br />
They must be respected by subclasses and clients can rely on them.</li>
<li><strong>Contract enforcement</strong> (behavioral subtyping).<br />
Tools to check the implementation of subclasses against contracts of superclasses. </li>
</ul>
</div></section>
<p>The programmer of a class defines a contract that abstractly specifies the behavior on which clients can rely.</p>
<p><strong>Pre- and Post-conditions</strong></p>
<ul>
<li>Declared for every method of the class.</li>
<li>Preconditions must be true for the method to execute.</li>
<li>Post-conditions must be true after the execution of the method.</li>
</ul>
<p><strong>Invariants</strong></p>
<ul>
<li>Properties that are always true for instances of the class.</li>
<li>May be broken temporarily during a method execution, but otherwise hold.</li>
</ul>
<section class="slide"><div class="section-body"><h1>Contract for <code>Rectangle.setWidth(int)</code></h1>
<h2>(one possible)</h2>
<pre><code class="java">public class Rectangle implements Shape {
  private int width;
  private int height;

  public void setWidth(int w) {
    this.width = w;
  }
}
</code></pre>
<ul>
<li><p><strong>Precondition</strong> for setWidth(int w):	</p>
<ul>
<li>w &gt; 0</li>
</ul>
</li>
<li><p><strong>Post-condition</strong> for setWidth(int w):</p>
<ul>
<li>width = w </li>
<li>height unchanged</li>
</ul>
</li>
</ul>
</div></section>
<section class="slide" data-title="Contract Enforcement"><div class="section-body"><h1>Contract Enforcement</h1>
<p><strong>Subclasses must conform to the contract of their base class!</strong></p>
<p>This is called behavioral subtyping.</p>
<p>It ensures that clients won’t break when instances of subclasses are used in the guise of instances of their heirs!</p>
<footer><div class="footer-body"><p>What would the subtyping rules look like?</p>
<p>What does it mean for a subclass to conform to the contract of the base class? </p>
</div></footer>
</div></section>
<section class="slide" data-title="Behavioral Subtyping: Rule for Preconditions"><div class="section-body"><h1>Behavioral Subtyping</h1>
<h2>Rule for Preconditions</h2>
<ul>
<li>Preconditions may be replaced by (<em>equal or) weaker ones</em>. </li>
<li>Preconditions of a class imply preconditions of its subclasses.</li>
</ul>
</div></section>
<p>Rationale:</p>
<ul>
<li>A derived class must not impose more obligations on clients. </li>
<li>Conditions that clients obey to before executing a method on an object of the base class should suffice to call the same method on instances of subclasses.</li>
</ul>
<section class="slide" data-title="Behavioral Subtyping: Rule for Postconditions"><div class="section-body"><h1>Behavioral Subtyping</h1>
<h2>Rule for Postconditions</h2>
<ul>
<li>Postconditions may be replaced by (<em>equal or) stronger ones</em>.</li>
<li>Postconditions of a class are implied by those of its subclasses.</li>
</ul>
</div></section>
<p>Rationale:</p>
<ul>
<li>Properties assumed by clients after executing a method on an object of the base class still hold when the same method is executed on instances of subclasses.</li>
<li>The guarantees that a method gives to clients can only become stronger.</li>
</ul>
<section class="slide" data-title="&quot;Standard&quot; Subtyping"><div class="section-body"><h1>&quot;Standard&quot; Subtyping</h1>
<p>“Standard” subtyping relies on <em>contra-variance</em> of the argument types and <em>covariance</em> of the return type for enforcing “pre- and post-conditions on signatures”. </p>
<pre><code>f:		T1  → T2
f’:		T1’ → T2’ 
	
f’ &lt;: f	&lt;=&gt;	T1 &lt;: T1’ and T2’ &lt;: T2  (f&apos; is a subtype of f)
</code></pre>
<footer><div class="footer-body"><p>In Java, a method <code>f</code> that has the same name, the same return type and the same number of arguments as a method <code>f</code> defined in a superclass doesn&apos;t override the superclass&apos;s method if one or more argument types are contra-variant.</p>
</div></footer>
</div></section>
<section class="slide" data-title="&quot;Standard&quot; Subtyping in Scala"><div class="section-body"><h1>Scala&apos;s Type Hierarchy</h1>
<p><img src="Images/SRP-Scala-TypeHierarchy-TopLevelTypes.png" alt="SRP Scala TypeHierarchy TopLevelTypes" /></p>
</div></section>
<p>Value classes are supported since Scala 2.10.</p>
<section class="slide" data-title="&quot;Standard&quot; Subtyping in Scala"><div class="section-body"><h1>Scala&apos;s Type Hierarchy</h1>
<p><img src="Images/SRP-Scala-TypeHierarchy.png" alt="SRP Scala TypeHierarchy" /></p>
</div></section>
<p>When compared to languages such as Java, Scala also has a well-defined least Type, i.e., a type that is the subtype of all other types.</p>
<section class="slide"><div class="section-body"><h1>&quot;Standard&quot; Subtyping in Scala</h1>
<pre><code class="scala">val f: (Seq[_]) ⇒ Boolean 
    = (s) ⇒ { s eq null }

val af1: (Object) ⇒ Boolean 
    = null // = f ?

val af2: (List[_]) ⇒ Boolean 
    = null // = f ?

val af3: (Seq[_]) ⇒ Any 
    = null // = f ?

val af4: (Seq[_]) ⇒ Nothing 
    = null // = f ?
</code></pre>
<footer><div class="footer-body"><p>Is it possible to assign a value of type <code>f</code> to the variable: <code>af1</code>,<code>af2</code>,<code>af3</code> or <code>af4</code>?</p>
</div></footer>
<aside data-title="Answers"><div class="aside-body"><p>The answers are: </p>
<ul>
<li>1: no</li>
<li>2: yes</li>
<li>3: yes</li>
<li>4: no (A client that can cope with &quot;Nothing&quot; will certainly not be able to cope with Booleans.)</li>
</ul>
</div></aside>
</div></section>
<pre><code class="scala">(Seq[__]) =&gt; Boolean
</code></pre>
<p>describes a type that is a function that takes a sequence of some type and returns a Boolean value. It is the same as the <code>Function1[Seq[__],Boolean]</code>.</p>
<p>The complete source code: <a href="Code/src/lsp/scala/Demo.scala">Demo.scala</a></p>
<section class="slide" data-title="Behavioral and Standard Subtyping in OO"><div class="section-body"><h1>Behavioral and Standard Subtyping in OO</h1>
<p><strong>Behavioral subtyping is a <em>stronger notion</em> than subtyping of functions defined in type theory.</strong></p>
<p>LSP imposes some standard requirements on signatures that have been adopted in OO languages:</p>
<ul>
<li>contra-variance/covariance of method argument/return types.</li>
<li>no new (checked) exceptions should be thrown by methods of the subtype, except for those exceptions that are subtypes of exceptions thrown by the methods of the super-type.</li>
</ul>
<p>In addition, there are a number of conditions that behavioral subtypes must meet concerning values (rather than types) of input and output.</p>
<p>Behavioral subtyping is undecidable in general.</p>
</div></section>
<p>If <code>q</code> is the property &quot;method foo always terminates“ and holds for objects of type <code>T</code>, it&apos;s generally impossible for a program (compiler) to verify that it holds true for some subtype <code>S</code>. </p>
<p>LSP is useful, however, in reasoning about the design of class hierarchies.</p>
<h4>Languages and Tools for Design-by-Contract (DbC)</h4>
<section class="slide" data-title="Languages and Tools for Design-by-Contract"><div class="section-body"><h1>Languages and Tools for Design-by-Contract</h1>
<ul>
<li>Contracts as comments in code or in documentation.</li>
<li>Unit-tests as contracts.</li>
<li>Formalisms and tools for specifying contracts in a declarative way and enforcing them.</li>
</ul>
</div></section>
<p>Contracts as comments are easy and always possible, but not machine checkable. Unit test are machine checkable, but not declarative, possibly cumbersome and need to maintained/updated whenever a new subclass is added. The <a href="http://eiffel.com">Eifel</a> language has built-in support for design-by-contracts (the term was coined by B. Meyer). <a href="http://www.eecs.ucf.edu/~leavens/JML/index.shtml">Java Modeling Language (JML)</a> uses annotations to specify pre-/post-conditions for Java. Recent languages, e.g., IBMs X10, integrate DbC into the type system by means of dependent types (values in type expressions).</p>
<h5>Java Modeling Language (JML)</h5>
<section class="slide" data-title="Java Modeling Language"><div class="section-body"><h1>Java Modeling Language</h1>
<p>A behavioral interface specification language that can be used to specify the behavior of Java modules.</p>
<pre><code class="java">public class Rectangle implements Shape { 
	private int width;
	private int height;
	
	/*@
</code></pre>
<pre><code class="JML">	  @ requires w &gt; 0;
	  @ ensures height = \old(height) &amp;&amp; width = w; 
</code></pre>
<pre><code class="java">	  @*/
	public void setWidth(double w)  {
		this.width = w;
	} 	
} 
</code></pre>
</div></section>
<p>In JML, specifications are written as Java annotation comments to the Java program, which hence can be compiled with any Java compiler.</p>
<p>To process JML specifications several tools exist:</p>
<ul>
<li>an assertion-checking compiler (jmlc) which performs runtime verification of assertions, </li>
<li>a unit testing tool (jmlunit), </li>
<li>an enhanced version of javadoc (jmldoc) that understands JML specifications and </li>
<li>an extended static checker (<a href="http://en.wikipedia.org/wiki/ESC/Java">ESC/Java</a>)  a static verification tool that uses JML as its front-end.</li>
</ul>
<h4>Contracts in Documentation</h4>
<section class="slide" data-title="Contracts in Documentation"><div class="section-body"><h1>Contracts in Documentation</h1>
<div class="statement">One should document any restrictions on how a method may be overridden in subclasses.</div>
</div></section>
<section class="slide" data-title="The Method java.lang.Object.equals(Object o)"><div class="section-body"><h1>The Method <code>java.lang.Object.equals(Object o)</code></h1>
<p>The documentation consists almost entirely of restrictions on how it may be overridden. </p>
<article><div class="article-body"><blockquote><p><code>public boolean equals(Object obj)</code></p>
<p>Indicates whether some other object is &quot;equal to&quot; this one.</p>
<p>The equals method <strong>implements an equivalence relation</strong> on non-null object references:</p>
<ul>
<li>It is reflexive: for any non-null reference value x, x.equals(x) should return true.</li>
<li>It is symmetric: for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true.</li>
<li>It is transitive: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true.</li>
<li>It is consistent: for any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified.</li>
<li>For any non-null reference value x, x.equals(null) should return false.</li>
</ul>
<p>The equals method for class Object implements the most discriminating possible equivalence relation on objects...</p>
</blockquote>
</div></article>
</div></section>
<p>The method <code>equals</code> in Object implements identity-based equality to mean: Each instance of a class is equal only to itself. Java classes may override it to implement logical equality. This method is a real “hot spot” and it is overridden frequently. Violations of the restrictions may have dire consequences and it can be very difficult to pin down the source of the failure. Many classes, <em>including all collection classes</em>, depend on the objects passed to them obeying the equals contract.</p>
<section class="slide" data-title="The Contract of Object.equals(Object o)"><div class="section-body"><h1>The Contract of <code>Object.equals(Object o)</code></h1>
<p>  <img src="Images/EffectiveJava.png" style="float:right;margin:1.5em"></p>
<p>In the following, we will discuss two restrictions on overriding equals from chapter 3 of the <a href="http://java.sun.com/developer/Books/effectivejava/Chapter3.pdf">book</a>.</p>
</div></section>
<section class="slide"><div class="section-body"><h1>Example Implementation of <code>Object.equals(Object o)</code></h1>
<pre><code class="java">/** 
* Case-insensitive string. Case of the original string is 
* preserved by toString, but ignored in comparisons. 
*/ 
public final class CaseInsensitiveString { 
   private String s; 
   public CaseInsensitiveString(String s) { 
        if (s == null) throw new NullPointerException(); 
        this.s = s; 
   } 
  
   public boolean equals(Object o) { 
      if (o instanceof CaseInsensitiveString) 
         return s.equalsIgnoreCase(((CaseInsensitiveString)o).s); 
      if (o instanceof String)  
         return s.equalsIgnoreCase((String)o); 
      return false; 
   } 
...// Remainder omitted 
}  
</code></pre>
<footer><div class="footer-body"><p>What do you think?</p>
</div></footer>
</div></section>
<p>This implementation violates the defined contract. The requirement that the implementation has to be symmetric is violated:</p>
<pre><code class="java">s1 = new CaseInsensitiveString(&quot;Hello&quot;);
s2 = &quot;hello&quot;; 
s1.equals(s2) == true;
s2.equals(s1) == false; 
</code></pre>
<section class="slide"><div class="section-body"><h1>Example Usage of CaseInsensitiveString</h1>
<pre><code class="java">CaseInsensitiveString cis = new CaseInsensitiveString(&quot;Polish&quot;); 
List list = new ArrayList(); 
list.add(cis);

return list.contains(&quot;polish&quot;); // true or false ?
</code></pre>
</div></section>
<p>Nobody knows what `list.contains(s) would return. The result may vary from one Java implementation to another. The result changes when we check the equality of the parameter against the element or vice versa!</p>
<section class="slide"><div class="section-body"><div class="statement">Once you have violated <code>equals</code>&apos;s contract, you simply don’t know how other objects will behave when confronted with your object.</div>
</div></section>
<section class="slide"><div class="section-body"><h1>The Implementation of <code>java.net.URL.equals</code></h1>
<article><div class="article-body"><blockquote><p><code>public boolean equals(Object obj)</code></p>
<p>Compares this URL for equality with another object.</p>
<p>If the given object is not a URL then this method immediately returns false.</p>
<p>Two URL objects are equal if they have the same protocol, reference equivalent hosts, have the same port number on the host, and the same file and fragment of the file.</p>
<p>Two hosts are considered equivalent if both host names can be resolved into the same IP addresses; else if either host name can&apos;t be resolved, the host names must be equal without regard to case; or both host names equal to null.</p>
<p>Since hosts comparison requires name resolution, this operation is a blocking operation.</p>
<p>…</p>
</blockquote>
</div></article>
<footer><div class="footer-body"><p>What do you think?</p>
</div></footer>
</div></section>
<p>Assessment:</p>
<ul>
<li><code>java.net.URL</code>’s <code>equals</code> method violates the consistent part of equals contract.</li>
<li>The implementation of that method relies on the IP addresses of the hosts in URLs being compared. </li>
<li>Translating a host name to an IP address can require network access, and it isn’t guaranteed to yield the same results over time. </li>
<li>This can cause the URL equals method to violate the equals contract, and it has caused problems in practice.<br />
(Unfortunately, this behavior cannot be changed due to compatibility requirements.)</li>
</ul>
<aside><div class="aside-body"><p>Later on the problems with the implementation were documented:</p>
<blockquote><p>Note: The defined behavior for equals is known to be inconsistent with virtual hosting in HTTP.</p>
</blockquote>
</div></aside>
<section class="slide" data-title="Enforcing Documented Contracts"><div class="section-body"><h1>Enforcing Documented Contracts</h1>
<ul>
<li>Maybe hard when done manually …</li>
<li>May require very powerful tooling (theorem proving) …<br /></li>
<li>Is un-decidable in general.</li>
</ul>
</div></section>
<section class="slide" data-title="The Imperative of Documenting Contracts"><div class="section-body"><h1>The Imperative of Documenting Contracts</h1>
<div class="statement">It is necessary to carefully and precisely document methods that may be overridden because one cannot deduce the intended specification from the code. </div>
<hr />
<p><strong>Example:</strong></p>
<pre><code class="java">package java.lang;
class Object {
  public boolean equals(Object ob ) { 
    return this == ob;  
  }
}
</code></pre>
<p>(Recall <code>equals</code>&apos;s contract!)</p>
</div></section>
<section class="slide"><div class="section-body"><h1>The Imperative of Documenting Contracts</h1>
<div class="statement">RFC (Request for Comments) 2119 defines keywords - may, should, must, etc. – which can be used to express so-called „subclassing directives“. </div>
<hr />
<p><strong>Example:</strong></p>
<pre><code class="java">/** 
 * Subclasses should override. 
 * Subclasses may call super 
 * New implementation should call addPage 
 */ 
 public void addPages() {...}
</code></pre>
</div></section>
<section class="story"><div class="section-body"><p>Contracts can also be regarded as a way of recording details of method responsibilities.</p>
<p>Writing contracts...</p>
<p><strong>… helps to avoid constantly checking arguments.</strong><br /></p>
<p>(E.g. consider the complexity of checking that a given array is sorted (precondition) vs. finding a value in a sorted array (functionality of a method)).</p>
<p><strong>… helps to determine who is responsible:</strong></p>
<pre><code class="java">/*@ requires x &gt;= 0.0; 
  @ ensures JMLDouble.approximatelyEqualTo(x, 
  @               \result * \result, eps); 
  @*/ 
public static double sqrt(doublex) {…} 
</code></pre>
<p>Here, the client has the obligation to pass a non-negative number and can expect to get an approximation of the square root. The implementor has the obligation to compute and return square roots. It can assume that the argument is non-negative.</p>
</div></section>
<section class="slide" data-title="On the Quality of the Documentation"><div class="section-body"><h1>On the Quality of the Documentation</h1>
<div class="statement">When documenting methods that may be overridden, one must be careful to document the method in a way that will <strong>make sense for all potential overrides</strong> of the function.</div>
</div></section>
<p>Investigations we have done with documentations of stable, intensively used frameworks in the context of the <a href="http://www.eclipse.org/recommenders/">CodeRecommenders</a> project show that often there is a discrepancy between documentation and the actual overriding. Two possible reasons: </p>
<ul>
<li>outdated documentation, </li>
<li>framework designer cannot foresee all possible extension/usage scenarios.</li>
</ul>
<section class="slide excursion" data-title="Generating API Documentation with JAutoDoc"><div class="section-body"><h1>Generating API Documentation with JAutoDoc</h1>
<p>The complete documentation was auto-generated.</p>
<pre><code class="java">/**
 * The number of questions.
 */
private int numberOfQuestions;


/**
 * Sets the number of questions.
 * 
 * @param numberOfQuestions the number of questions
 * @throws IllegalArgumentException the illegal argument exception
 */
public void setNumberOfQuestions(int numberOfQuestions) 
      throws IllegalArgumentException {
    if (numberOfQuestions &lt; 0) {
        throw new IllegalArgumentException(&quot;numberOfQuestions &lt; 0&quot;);
    }
    this.numberOfQuestions = numberOfQuestions;
}
</code></pre>
<aside data-title="What People Say About JAutoDoc"><div class="aside-body"><h1>What People Say About JAutoDoc</h1>
<ul>
<li>User: Anonymous (2009-08-02 11:32:37)<br />
Rating: 9	
Wow exactly what I needed!</li>
<li>User: Anonymous (2009-02-13 19:58:32)<br />
Rating: 9	
Thank you... this plugin rocks!</li>
<li>User: Anonymous (2009-02-13 19:58:32)<br />
Rating: 9<br />
<strong>Works perfectly. Smarter than I expected!</strong></li>
</ul>
</div></aside>
</div></section>
<h3>Takeaway</h3>
<section class="slide" data-title="Takeaway"><div class="section-body"><h1>Takeaway</h1>
<div class="statement">Subtypes must be behaviorally substitutable for their base types.</div>
<ul>
<li><p><strong>Behavioral subtyping extends “standard” OO subtyping.</strong><br />
Additionally ensures that assumptions of clients about the behavior of a base class are not broken by subclasses.</p>
</li>
<li><p><strong>Behavioral subtyping helps with supporting OCP.</strong><br />
Only behavioral subclassing (subtyping) truly supports open-closed designs.<br /></p>
</li>
<li><p><strong>Design-by-Contract is a technique for supporting LSP.</strong>  <br />
Makes the contract of a class to be assumed by the clients and respected by subclasses explicit (and checkable).</p>
</li>
</ul>
</div></section>
<h2>Interface Segregation Principle (ISP)</h2>
<section class="slide" data-title="Interface Segregation Principle"><div class="section-body"><h1>Interface Segregation Principle</h1>
<div class="statement">Clients should not be forced to depend on methods that they do not use.</div>
</div></section>
<h3>Introduction by Example</h3>
<section class="slide" data-title="Introduction by Example"><div class="section-body"><h1>Introduction by Example</h1>
<p>Consider the development of software for an automatic teller machine (ATM):</p>
<ul>
<li>Support for the following types of transactions is required: withdraw, deposit, and transfer</li>
<li>Support for different languages and support for different kinds of UIs is also required</li>
<li>Each transaction class needs to call methods on the GUI<br />
E.g., to ask for the amount to deposit, withdraw, transfer.</li>
</ul>
<p><img src="Images/ISP-ATM-OneInterface.png" alt="ISP ATM OneInterface" /></p>
<footer><div class="footer-body"><p>What do you think?</p>
</div></footer>
</div></section>
<p><strong>Assessment:</strong></p>
<p>ISP tells us to avoid this. Each transaction class uses a part of the interface, but depends on all others. Any change affects all transactions.</p>
<section class="slide" data-title="A Polluted Interface"><div class="section-body"><h1>A Polluted Interface</h1>
<p><img src="Images/ISP-ATM-PollutedInterfaceATMUI.png" alt="ISP ATM PollutedInterfaceATMUI" /></p>
<p><code>ATM UI</code> is a polluted interface:</p>
<ul>
<li>It declares methods that do not belong together.</li>
<li>It forces classes to depend on unused methods and therefore depend on changes that should not affect them.</li>
<li>ISP states that such interfaces should be split.</li>
</ul>
</div></section>
<h3>The Rationale Behind ISP</h3>
<section class="slide" data-title="The Rationale Behind ISP"><div class="section-body"><h1>The Rationale Behind ISP</h1>
<div class="statement">When clients depend on methods they do not use, they become subject to changes forced upon these methods by other clients.</div>
<p>This causes coupling between all clients.</p>
</div></section>
<section class="slide" data-title="How does an ISP compliant solution look like?"><div class="section-body"><h1>How does an ISP compliant solution look like?</h1>
<p><img src="Images/ISP-ATM-OneInterface.png" alt="ISP ATM OneInterface" /></p>
</div></section>
<section class="slide" data-title="An ISP Compliant Solution"><div class="section-body"><h1>An ISP Compliant Solution</h1>
<p><img src="Images/ISP-ATM-MultipleInterface.png" alt="ISP ATM MultipleInterface" /></p>
</div></section>
<h3>Proliferation of Interfaces</h3>
<section class="slide" data-title="Proliferation of Interfaces"><div class="section-body"><h1>Proliferation of Interfaces</h1>
<div class="statement">Try to group possible clients of a class and have an interface for each group.</div>
<hr />
<p><strong>But:</strong>
Segregating interfaces should not be overdone! </p>
</div></section>
<p>If you overdue the application of the interface segregation principle, you will end up with 2n-1 interfaces for a class with n methods.</p>
<p>Recall that, in general, a class implementing many interfaces may be a sign of a violation of the single-responsibility principle.</p>
<h3>Takeaway</h3>
<section class="slide" data-title="Takeaway"><div class="section-body"><h1>Takeaway</h1>
<div class="statement">Clients should not be forced to depend on methods that they do not use.</div>
</div></section>
<h2>Dependency Inversion Principle (DIP)</h2>
<section class="slide" data-title="Dependency-Inversion Principle"><div class="section-body"><h1>Dependency-Inversion Principle</h1>
<div class="statement">High-level modules should not depend on low-level modules. Both should depend on abstractions.</div>
<hr />
<div class="statement">Abstractions should not depend on details. Details should depend on abstractions.</div>
</div></section>
<h3>Example</h3>
<section class="slide" data-title="Introduction by Example"><div class="section-body"><h1>Introduction by Example</h1>
<p>A small design excerpt from the smart-home scenario:</p>
<p><img src="Images/DIP-ButtomLamp.png" alt="DIP ButtomLamp" /></p>
<p>Behavior of <code>Button</code>:</p>
<ul>
<li>The button is capable of “sensing” whether it has been activated/deactivated by the user.</li>
<li>Once a change is detected, it turns the Lamp on, respectively off.</li>
</ul>
<footer><div class="footer-body"><p>Do you see any problem with this design?</p>
</div></footer>
</div></section>
<p><strong>Assessment:</strong></p>
<ul>
<li>We cannot reuse <code>Button</code> since it depends directly on <code>Lamp</code>.
(But there are plenty of other uses for <code>Button</code>.)</li>
<li><code>Button</code> should not depend on the details represented by <code>Lamp</code>.</li>
</ul>
<p>These are symptoms of the real problem (Violation of the Dependency-Inversion Principle).<br />
The <strong>high-level policy</strong> (detection of on/off gestures) underlying this (mini) design depends on the low-level details.</p>
<p><em>The underlying abstraction is the detection of on/off gestures and their delegation to a server object that can handle them.</em></p>
<p>If the interface of <code>Lamp</code> is changed, <code>Button</code> has to be at least tested or even adjusted, even though the policy that <code>Button</code> represents is not changed!</p>
<p>To make the high-level policy independent of details we should be able to define it independent of the details of <code>Lamp</code> or any other specific device.</p>
<section class="slide" data-title="A Dependency-Inversion Principle Compliant Solution"><div class="section-body"><h1>A Dependency-Inversion Principle Compliant Solution</h1>
<p><img src="Images/DIP-ButtomSwitchableLamp.png" alt="DIP ButtomSwitchableLamp" /></p>
</div></section>
<p>Now <code>Button</code> only depends on abstractions; it can be reused with various classes that implement <code>Switchable</code>.</p>
<p>Changes in <code>Lamp</code> will not affect <code>Button</code>.</p>
<p>The dependencies have been inverted: <code>Lamp</code> now has to conform to the interface defined by <code>Button</code>.</p>
<p><strong>Actually: both depend on an abstraction!</strong></p>
<h3>The Rationale behind the Dependency-Inversion Principle</h3>
<section class="slide" data-title="The Rationale"><div class="section-body"><h1>The Rationale</h1>
<p>High-level, low-level modules. Good software designs are structured into modules.</p>
<ul>
<li><p><strong>High-level modules</strong> contain the important policy decisions and business models of an application – The identity of the application.</p>
</li>
<li><p><strong>Low-level modules</strong> contain detailed implementations of individual mechanisms needed to realize the policy.</p>
</li>
</ul>
<div class="statement"><strong>High-level policy:</strong> The abstraction that underlies the application; the truth that does not vary when details are changed; the system inside the system; the metaphor.</div>
</div></section>
<p><em>High-level policies and business processes is what we want to reuse.</em> If high-level modules depend on the low-level modules changes to the lower level details will force high-level modules to be tested again/to be changed. Additionally, it becomes harder if not practically impossible to use them in other contexts. It is the high-level modules that should influence the low-level details.</p>
<h3>Advanced Example</h3>
<section class="slide" data-title="Example - Regulating the Temperature"><div class="section-body"><h1>Example - Regulating the Temperature</h1>
<p><img src="Images/DIP-RegulatorBase.png" alt="DIP RegulatorBase" /></p>
<footer><div class="footer-body"><p>Is it compliant with the Dependency-Inversion Principle?</p>
<p>If not, what would you do?</p>
</div></footer>
</div></section>
<p>We have three modules where <code>Regulate</code> uses the other two:</p>
<ul>
<li><code>Regulate</code> pulls data about the current temperature from the <code>Thermometer</code> component and </li>
<li><code>Regulate</code> signals the <code>Furnace</code> component to increase or decrease heat.</li>
</ul>
<section class="slide"><div class="section-body"><h1>Example - Regulating the Temperature</h1>
<p><img src="Images/DIP-RegulatorDIPCompliant.png" alt="DIP RegulatorDIPCompliant" /></p>
</div></section>
<h3>Layers and Dependencies</h3>
<section class="slide" data-title="Layers and Dependencies"><div class="section-body"><h1>Layers and Dependencies</h1>
<blockquote><p>„…all well-structured object-oriented architectures have clearly defined layers, with each layer providing some coherent set of services through a well-defined and controlled interface…“<br />
Grady Booch</p>
</blockquote>
<p><strong>A possible Interpretation:</strong></p>
<p>  <img src="Images/DIP-LayersBase.png" style="float:left;"></p>
<p>The higher the module is positioned in a layered architecture, the more general the function it implements.</p>
<p>The lower the module, the more detailed the function it implements.</p>
<footer><div class="footer-body"><p>What do you think of this interpretation?</p>
</div></footer>
</div></section>
<p>This interpretation clearly <strong>violates DIP</strong>. Higher-level modules depend on lower-level modules. </p>
<p>This is actually a typical structure of a layered architecture realized with structured programming (e.g., using &quot;C&quot;).</p>
<section class="slide"><div class="section-body"><h1>Layers and Dependencies</h1>
<h2>Inverted Layer Dependencies</h2>
<p><img src="Images/DIP-LayersDIPCompliant.png" alt="DIP LayersDIPCompliant" /></p>
</div></section>
<ul>
<li>An upper-layer declares (owns) interfaces for services it needs.</li>
<li>Lower-layer implements these interfaces.</li>
<li>Upper-layer uses lower-layer by the interface.<br />
The upper layer does not depend on the lower-layer.</li>
<li>Lower-layer depends on the interface declared by the upper-layer.</li>
</ul>
<p>Usually, we think of utility libraries as owning their own interfaces. (A relict from structured programming era.) Due to ownership inversion, <code>Policy</code> is unaffected by changes in <code>Mechanism</code> or <code>Utility</code>.</p>
<h3>Naive Heuristic for Ensuring DIP</h3>
<section class="slide" data-title="Naive Heuristic for Ensuring DIP"><div class="section-body"><h1>Naive Heuristic for Ensuring DIP</h1>
<div class="statement">DO NOT DEPEND ON A CONCRETE CLASS.</div>
<p>All relationships in a program should terminate on an abstract class or an interface.</p>
<ul>
<li>No class should hold a reference to a concrete class.</li>
<li>No class should derive from a concrete class.</li>
<li>No method should override an implemented method of any of its base classes.</li>
</ul>
</div></section>
<p>This heuristic is usually violated at least once in every program:</p>
<ul>
<li>Some class will have to create concrete classes.</li>
<li>Subclass relationships do often terminate at a concrete class. </li>
</ul>
<p>The heuristic seems naive for concrete stable classes, e.g., <code>String</code> in Java. But, concrete application classes are generally volatile and you should not depend on them. Their volatility can be isolated by keeping them behind abstract interfaces owned by clients.</p>
<h3>Takeaway</h3>
<section class="slide" data-title="Takeaway"><div class="section-body"><h1>Takeaway</h1>
<div class="statement">High-level modules should not depend on low-level modules. Both should depend on abstractions. </div>
<ul>
<li>Traditional structural programming creates a dependency structure in which policies depend on details.
(Policies become vulnerable to changes in the details.)</li>
<li><p>Object-orientation enables to invert the dependency:</p>
<ul>
<li>Policy and details depend on abstractions.</li>
<li>Service interfaces are owned by their clients.</li>
<li>Inversion of dependency is the hallmark of good object-oriented design.  <br />
(Implies an inversion of interface ownership.)</li>
</ul>
</li>
</ul>
</div></section>
<h1>Inheritance</h1>
<section class="slide" data-title="A Critical View On Inheritance"><div class="section-body"><h1>A Critical View On Inheritance</h1>
<div class="statement">Inheritance is the main built-in variability mechanism of OO languages.</div>
<p>Common functionality can be implemented by a base class and each variation can be implemented by a separate subclass. </p>
</div></section>
<ul>
<li>In the following, we analyze the strengths and deficiencies of inheritance with respect to supporting variability. </li>
<li>Many design patterns that we will discuss in the following sections propose solutions to compensate for deficiencies of inheritance.</li>
<li>This section serves as a bridge between the block on design principles and the blocks about design patterns and advanced languages.<br /></li>
</ul>
<h2>Desired Properties Of Inheritance</h2>
<section class="slide" data-title="Desired Properties"><div class="section-body"><h1>Desired Properties</h1>
<hr />
<h2>Built-in support for OCP.</h2>
<hr />
<h2>Good Modularity.</h2>
<hr />
<h2>Support for structural variations.</h2>
<hr />
<h2>Variations can be represented in type declarations.</h2>
<hr />
</div></section>
<p>A good support for OCP, reduces the need to anticipate variations. Inheritance allows replacing the implementation of arbitrary methods of a base class (unless it is explicitly forbidden, e.g., in Java methods can be declared as <code>ﬁnal</code>).</p>
<p>Of course, support for variability in a class is conditioned by the granularity of its methods and the abstractions built-in.</p>
<p>When we achieve good modularity, the base class can remain free of any variation-specific functionality; each variation is implemented in a separate subclass. </p>
<p>In general, inheritance allows to design the most suitable interface for each variation.
Different variations of a type may need to extend the base interface with variation-specific fields and methods. (In addition to varying the implementation of the inherited base interface.)</p>
<p>The property that variations can be represented in type declarations is necessary for type-safe access of variation-specific interfaces. </p>
<section class="slide" data-title="Desired Properties By Example"><div class="section-body"><h1>Desired Properties By Example</h1>
<h2>Variation of selection functionality of table widgets.</h2>
<pre><code class="Java">class TableBase extends Widget { 
  TableModel model; 
  String getCellText(int row, int col){return model.getCellText(row, col);}
  void paintCell(int r, int c){getCellText(row, col) … } 
}
abstract class TableSel extends TableBase { 
  abstract boolean isSelected(int row, int col); 
  void paintCell(int row, int col) { if (isSelected(row, col)) … }
}
class TableSingleCellSel extends TableSel { 
  int currRow; int currCol; 
  void selectCell(int r, int c){currRow = r; currCol = c;} 
  boolean isSelected(int r, int c){return r == currRow &amp;&amp; c == currCol;} 
} 
class TableSingleRowSel extends TableSel { 
  int currRow; 
  void selectRow(int row) { currRow = row; } 
  boolean isSelected(int r, int c) { return r == currRow;} 
} 
class TableRowRangeSel extends TableSel { … } 
class TableCellRangeSel extends TableSel { … } 
</code></pre>
</div></section>
<p>The modularization of these variations by inheritance is illustrated by the given (pseudo-)code: </p>
<ul>
<li>TableBase implements basic functionality of tables as a variation of common functionality for all widgets, e.g., display of tabular data models. </li>
<li>The abstract class <code>TableSel</code> extends <code>TableBase</code> with functionality that is common for all types of table selection, e.g., rendering of selected cells. </li>
<li><code>TableSingleCellSel</code>, <code>TableSingleRowSel</code>, <code>TableRowRangeSel</code>, and <code>TableCellRangeSel</code> implement specific types of table selections. </li>
</ul>
<p><strong>Assessment</strong></p>
<p><strong>Built-in support for OCP</strong>:<br />
The implementation of paintCell in <code>TableSel</code> can be overridden.</p>
<p><strong>Good modularity</strong>:<br />
Each table selection model is encapsulated in a separate class.</p>
<p><strong>Support for structural variations:</strong><br /></p>
<ul>
<li>Different operations and variables are declared and implemented by <code>TableSingleCellSel</code> and <code>TableSingleRowSel</code>: <code>currRow</code>, <code>currCel</code>, <code>selectCell</code> and <code>currRow</code>, <code>selectRow</code>, respectively.</li>
<li>Can design the most suitable interface for each type of table selection. </li>
<li>Do not need to design a base interface that fits all future variations.</li>
</ul>
<p><strong>Variations can be represented in type declarations:</strong></p>
<ul>
<li><p>We know that a variable declared with type <code>TableSingleRowSel</code> would always refer to a table supporting single row selection.</p>
</li>
</ul>
<h2>Deficiencies of Inheritance</h2>
<h3>Non-Reusable, Hard-to-Compose Extensions</h3>
<section class="slide" data-title="Non-Reusable, Hard-to-Compose Extensions"><div class="section-body"><h1>Non-Reusable, Hard-to-Compose Extensions</h1>
<p>An Extract from Java’s Stream Hierarchy</p>
<p><img src="Images/Inheritance-java.io.png" alt="Inheritance Java.Io" /></p>
</div></section>
<p>Consider an extract from <code>java.io</code> package that consists of classes for reading from a source. Streams abstract from concrete data sources and sinks:</p>
<ul>
<li><code>InputStream</code> is root of stream classes reading from a data source.</li>
<li><code>FileInputStream</code> implements streams that read from a file.</li>
<li><code>PipedInputStream</code> implements streams that read from a PipedOutputStream.<br />
Typically, a thread reads from a <code>PipedInputStream</code> data written to the corresponding <code>PipedOutputStream</code> by another thread.</li>
<li><code>ByteArrayInputStream</code> implements streams that read from memory.</li>
</ul>
<section class="slide" data-title="Non-Reusable, Hard-to-Compose Extensions"><div class="section-body"><h1>Non-Reusable, Hard-to-Compose Extensions</h1>
<p>An Extract from Java’s Stream Hierarchy --  <strong>A Simple Variation</strong></p>
<p><img src="Images/Inheritance-ByteArrayDataInputStream.png" alt="Inheritance ByteArrayDataInputStream" /></p>
</div></section>
<p>Need a variation of <code>ByteArrayInputStream</code> capable of reading whole sentences and not just single bytes.
We could implement it as a subclass of <code>ByteArrayInputStream</code>. The blue part in the name of the class denotes the delta (<code>DataInputStream</code>) needed to implement this variation.</p>
<p>Further Variations that are conceivable:</p>
<ul>
<li><p>Reading whole sentences with other kinds of streams:</p>
<ul>
<li>FileInputStream objects that are able to read whole sentences.</li>
<li>PipedInputStream should read whole sentences too.
…</li>
</ul>
</li>
<li>Writing the given data back (“red” in the following slide)</li>
<li>Buffering content (“green” in the following slide),</li>
<li>Counting the numbers of lines processed,</li>
<li>…	</li>
</ul>
<section class="slide" data-title="Non-Reusable, Hard-to-Compose Extensions"><div class="section-body"><h1>Non-Reusable, Hard-to-Compose Extensions</h1>
<p>An Extract from Java’s Stream Hierarchy --  <strong>A Simple Variation</strong></p>
<p><img src="Images/Inheritance-Complex.png" alt="Inheritance Complex" /></p>
<blockquote><p>Each kind of variation would have to be re-implemented 
for all kinds of streams,
for all meaningful combinations of variations</p>
</blockquote>
</div></section>
<p>Assessment: The design is complex and suffers from a huge amount of code duplication.</p>
<section class="slide" data-title="Non-Reusable, Hard-to-Compose Extensions"><div class="section-body"><h1>Non-Reusable, Hard-to-Compose Extensions</h1>
<div class="statement">Extensions defined in subclasses of a base class cannot be reused with other base classes.</div>
<p>Result:</p>
<ul>
<li>Code duplication</li>
<li>Maintenance nightmare</li>
</ul>
</div></section>
<p>A particular type of variation needs to be re-implemented for all siblings of a base type which results in code duplication.</p>
<p>Large number of independent extensions are possible:</p>
<ul>
<li>For every new functionality we want.</li>
<li>For every combination of every functionality we want.</li>
</ul>
<p>Maintenance nightmare: exponential growth of number of classes.</p>
<h3>Weak Support for Dynamic Variability</h3>
<section class="slide" data-title="Weak Support for Dynamic Variability"><div class="section-body"><h1>Weak Support for Dynamic Variability</h1>
<div class="statement">Variations supported by an object are fixed at object creation time and cannot be (re-)configured dynamically.</div>
</div></section>
<section class="slide" data-title="Dynamic Variability Illustrated"><div class="section-body"><h1>Dynamic Variability Illustrated (I)</h1>
<h2>The configuration of an object’s implementation may depend on values from the runtime context.</h2>
<p><strong>Potential Solution:</strong><br />
Mapping from runtime values to classes to be instantiated can be implemented by conditional statements.</p>
<p><strong>Issue:</strong> 
Such a mapping is error-prone and not extensible.<br />
When new variants of the class are introduced, the mapping from configuration variables to classes to instantiate must be changed.</p>
</div></section>
<p><strong>Example:</strong>
Table widget options may come from some dynamic configuration panel; depending on the configuration options, different compositions of table widget features need to be instantiated.</p>
<section class="slide"><div class="section-body"><h1>Dynamic Variability Illustrated (II)</h1>
<h2>The behavior of an object may vary depending on its state or context of use.</h2>
<p><strong>Potential Solution:</strong><br />
Mapping from runtime values to object behavior can be implemented by conditional statements in the implementation of object’s methods.</p>
<p><strong>Issue:</strong>  <br />
Such a mapping is error-prone and not extensible.<br />
When new variants of the behavior are introduced, the mapping from dynamic variables to implementations must be changed.</p>
</div></section>
<p><strong>Example:</strong>
An account object’s behavior may vary depending on the amount of money available. The behavior of a service then may need to vary depending on the client’s capabilities.</p>
<h3>The Fragile Base Class Problem</h3>
<p>Cf. <code>Item 17</code> of Joshua Bloch&apos;s, <strong>Effective Java</strong>.</p>
<h4>The Fragile Base Class Problem Illustrated</h4>
<section class="slide" data-title="The Fragile Base Class Problem Illustrated"><div class="section-body"><h1>The Fragile Base Class Problem Illustrated</h1>
<h2>An Instrumented HashSet</h2>
<pre><code class="Java">import java.util.*;
public class InstrumentedHashSet&lt;E&gt; extends HashSet&lt;E&gt; {
  private int addCount = 0;    
  public InstrumentedHashSet() {    } 
  public InstrumentedHashSet(int initCap, float loadFactor) {
    super(initCap, loadFactor);
  }    

  @Override public boolean add(E e) { addCount++; return super.add(e); }
  @Override public boolean addAll(Collection&lt;? extends E&gt; c) {
    addCount += c.size();
    return super.addAll(c);
  }
  public int getAddCount() { return addCount; }

  public static void main(String[] args) {
    InstrumentedHashSet&lt;String&gt; s = new InstrumentedHashSet&lt;String&gt;();
    s.addAll(Arrays.asList(&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;));
    System.out.println(s.getAddCount());
  }
}
</code></pre>
<footer><div class="footer-body"><p>What is printed on the screen?</p>
</div></footer>
</div></section>
<p>Suppose we want to implement <code>HashSets</code> that know the number of their elements.</p>
<p>We implement a class <code>InstrumentedHashSet</code> that inherits from <code>HashSet</code> and overrides methods that change the state of a <code>HashSet</code> … </p>
<p>The answer to the question is 6 because the implementation of <code>addAll</code> in <code>HashSet</code> internally calls <code>this.add(...)</code>.  Hence, added elements are counted twice.</p>
<section class="slide"><div class="section-body"><h1>The Fragile Base Class Problem Illustrated</h1>
<h2>An Instrumented HashSet</h2>
<pre><code class="Java">import java.util.*;
public class InstrumentedHashSet&lt;E&gt; extends HashSet&lt;E&gt; {
  private int addCount = 0;    
  public InstrumentedHashSet() {    } 
  public InstrumentedHashSet(int initCap, float loadFactor) {
    super(initCap, loadFactor);
  }    

  @Override public boolean add(E e) { addCount++; return super.add(e); } 
  // @Override public boolean addAll(Collection&lt;? extends E&gt; c) {
  //  addCount += c.size();
  //  return super.addAll(c);
  // }
  public int getAddCount() { return addCount; }

  public static void main(String[] args) {
    InstrumentedHashSet&lt;String&gt; s = new InstrumentedHashSet&lt;String&gt;();
    s.addAll(Arrays.asList(“aaa&quot;, “bbb&quot;, “ccc&quot;));
    System.out.println(s.getAddCount());
  }
}
</code></pre>
<footer><div class="footer-body"><p>Is the counting problem solved, by not overriding <code>addAll</code>?</p>
</div></footer>
</div></section>
<p><strong>For the moment</strong> yes. But, not principally. </p>
<p>What if in the future the designers of <code>HashSet</code> decide to re-implement <code>addAll</code> to insert the elements of the parameter collection as a block rather than by calling <code>add</code> on each element of the collection? Might be necessary for efficiency reasons.</p>
<h4>The Fragile Base Class Problem in a Nutshell</h4>
<section class="slide" data-title="The Fragile Base Class Problem in a Nutshell"><div class="section-body"><h1>The Fragile Base Class Problem in a Nutshell</h1>
<div class="statement">Changes in base classes may lead to unforeseen problems in subclasses. </div>
<p><strong>“Inheritance Breaks Encapsulation”</strong></p>
</div></section>
<p><em>You can modify a base class in a seemingly safe way</em>. But this modification, when inherited by the derived classes, might cause them to malfunction.</p>
<p>You can&apos;t tell whether a base class change is safe simply by examining the base class&apos; methods in isolation. You must look at (and test) all derived classes as well.
You must check all code that uses the base class and its derived classes; this code might also be broken by the changed behavior.</p>
<p>A simple change to a key base class can render an entire program inoperable.</p>
<section class="slide"><div class="section-body"><h1>The Fragile Base Class Problem in a Nutshell</h1>
<h2>Fragility by dependencies on the self-call structure</h2>
<ul>
<li>The fragility considered so far is caused by dependencies on the self-call structure of the base class.</li>
<li>Subclasses make assumptions about the calling relationship between <code>public</code> and <code>protected</code> methods of the base class. </li>
<li>These assumptions are implicitly encoded in the overriding decisions of the subclass.</li>
<li>If these assumptions are wrong or violated by future changes of the structure of superclass’ self-calls, the subclass’s behavior is broken.</li>
</ul>
<footer><div class="footer-body"><p>Is it possible to solve the fragile-base class problem by avoiding assumptions about the self-call structure of the base class in the implementations of the subclasses?</p>
</div></footer>
</div></section>
<section class="slide"><div class="section-body"><h1>The Fragile Base Class Problem in a Nutshell</h1>
<h2>Fragility by addition of new methods.</h2>
<p>Another kind of fragility is caused by extensions of the base class with new methods that were not there when the class was subclassed. </p>
<p><strong>Example:</strong></p>
<ul>
<li>Consider a base collection class.</li>
<li>To ensure some (e.g., security) property, we want to enforce that all elements added to the collection satisfy a certain predicate.</li>
<li>We override <em>every method</em> that is relevant for ensuring the security property to consistently check the predicate.</li>
<li>Yet, the <strong>security may be defeated unintentionally</strong> if a new method is added to the base class which is relevant for the (e.g., security) property.</li>
</ul>
</div></section>
<p>Several holes of this nature had to be fixed when <code>Hashtable</code> and <code>Vector</code> were retrofitted to participate in the Java Collection Frameworks.</p>
<section class="slide"><div class="section-body"><h1>The Fragile Base Class Problem in a Nutshell</h1>
<h2>Fragility by addition of new methods.</h2>
<p><strong>Accidental method capture</strong>: A new release of the base class accidentally includes a method with the same name.</p>
<p>Your code does not compile because the new method in the base class has the same signature but a different return type.</p>
<p>Your methods get involved in things you never thought about because the added method has the same signature and return type.</p>
</div></section>
<h3>Taming Inheritance</h3>
<section class="slide" data-title="Taming Inheritance"><div class="section-body"><h1>Taming Inheritance</h1>
<div class="statement"><strong>Implementation inheritance</strong> (<code>extends</code>) is a powerful way to achieve code reuse.</div>
<hr />
<div class="statement">But, if used inappropriately, it leads to fragile software.</div>
</div></section>
<p>Next, we discuss rules of thumb for making &quot;good use&quot; of inheritance.</p>
<section class="slide" data-title="Dos and Don&apos;ts"><div class="section-body"><h1>Dos and Don&apos;ts</h1>
<ul>
<li><p>It is always safe to use inheritance within a package.<br />
The subclass and the superclass implementation are under the control of the same programmers.</p>
</li>
<li><p>It is also OK to extend classes specifically designed and documented for extension.</p>
</li>
<li><p>Avoid inheriting from concrete classes not designed and documented for inheritance across package boundaries.</p>
</li>
</ul>
</div></section>
<section class="slide" data-title="Document for Inheritance"><div class="section-body"><div class="statement">Design and document for inheritance or else prohibit it.</div>
<p><strong>Joshua Bloch, Effective Java</strong></p>
</div></section>
<section class="slide" data-title="Documenting Self-Use"><div class="section-body"><h1>Classes Must Document Self-Use</h1>
<ul>
<li><p>Each public/protected method/constructor must indicate self-use:</p>
<ul>
<li>Which overridable methods it invokes.</li>
<li>In what sequence.</li>
<li>How the results of each invocation affect subsequent processing.</li>
</ul>
</li>
<li>A class must document any circumstances under which it might invoke an overridable method.  (Invocations might come from background threads or static initializers.)</li>
</ul>
<hr />
<h1>Common Conventions for Documenting Self-Use</h1>
<ul>
<li><p>The description of self-invocations to overridable methods is given at the end of a method’s documentation comment.</p>
</li>
<li><p>The description starts with “This implementation …”. <br />
Indicates that the description tells something about the internal working of the method. </p>
</li>
</ul>
</div></section>
<p>Overridable method = non-final and either public or protected</p>
<section class="slide" data-title="Example of Documentation On Self-Invocation"><div class="section-body"><h1>Example of Documentation On Self-Invocation</h1>
<h2>Taken from: <code>java.util.AbstractCollection</code></h2>
<pre><code class="Java">public boolean remove(Object o)
</code></pre>
<blockquote><p>Removes a single instance of the specified element from this collection.<br />
…<br />
<strong>This implementation removes the element from the collection using the iterator&apos;s remove method.</strong>
Note that this implementation throws an UnsupportedOperationException if the iterator returned by this collection&apos;s iterator() method does not implement the remove(…) method.</p>
</blockquote>
<footer><div class="footer-body"><p>This documents the contract.</p>
</div></footer>
</div></section>
<p>The documentation makes explicit that overriding <code>iterator()</code> will affect the behavior of <code>remove</code> and what the effect would be.</p>
<section class="slide" data-title="Documenting Self-Use In API Documentation"><div class="section-body"><h1>Documenting Self-Use In API Documentation</h1>
<div class="statement">Do implementation details have a rightful place in a good API documentation?</div>
</div></section>
<p>The answer is simple: It depends!</p>
<ul>
<li><p>Keep in mind: There are two kinds of clients of an extensible class:</p>
<ul>
<li>Ordinary clients create instances of the class and call methods in its interface (black-box use).</li>
<li>Clients that extend the class via inheritance.</li>
</ul>
</li>
<li><p>Ordinary clients should not know such details.<br />
… At least as long as a mechanism for LSP is in place.</p>
</li>
<li>Subclassing clients need them. That’s their &quot;interface&quot;.</li>
</ul>
<p><strong>Current documentation techniques and tools lack proper means of separating the two kinds of API documentations.</strong></p>
<section class="slide" data-title="Provide And Document Hooks To Internals"><div class="section-body"><h1>Provide And Document Hooks To Internals</h1>
<h2>Example taken from: <code>java.util.AbstractList</code></h2>
<pre><code class="Java">protected void removeRange(int fromIndex, int toIndex)
</code></pre>
<blockquote><p>Removes from a list …</p>
<p>This method is called by the clear operation on this list and its sub lists. Overriding this method to take advantage of the internals of the list implementation can substantially improve the performance of the clear operation on this list and its sub lists…<br />
This implementation gets a list iterator positioned before <code>fromIndex</code> and repeatedly calls <code>ListIterator.next</code> and <code>ListIterator.remove</code>. Note: If <code>ListIterator.remove</code> requires linear time, this implementation requires quadratic time.</p>
</blockquote>
</div></section>
<p>A class must document the supported hooks to its internals. These internals are irrelevant for ordinary users of the class. But, they are crucial for enabling subclasses to specialize the functionality in an effective way.</p>
<section class="slide" data-title="Carefully Design and Test Hooks To Internals"><div class="section-body"><h1>Carefully Design and Test Hooks To Internals</h1>
<ul>
<li>Provide <strong>as few protected methods and fields as possible</strong></li>
<li>Each of them represents a commitment to an implementation detail.</li>
<li>Designing a class for inheritance places limitations on the class.</li>
<li>Do not provide too few hooks.<br />
A missing protected method can render a class practically unusable for inheritance.</li>
</ul>
<footer><div class="footer-body"><p>How to decide about the protected members to expose?</p>
</div></footer>
</div></section>
<p>W.r.t. designing the internal hooks and making decisions about the kind and number of internal hooks, no silver bullet exists. You have to think hard, take your best guess, and test.</p>
<p>Test your class for extensibility before releasing them. By writing test subclasses (At least one subclass should be written by someone other than the superclass author).</p>
<section class="slide" data-title="Constructors Must Not Invoke Overridable Methods"><div class="section-body"><div class="statement">Constructors Must Not Invoke Overridable Methods</div>
</div></section>
<section class="slide"><div class="section-body"><h1>Constructors Must Not Invoke Overridable Methods</h1>
<p><strong>Java Example</strong></p>
<pre><code class="Java">class JavaSuper {
  public JavaSuper() { printState(); }

  public void printState() { System.out.println(&quot;no state&quot;); }
}

class JavaSub extends JavaSuper {
    private int x = 42; // the result of a tough computation

    public void printState() { System.out.println(&quot;x = &quot; + x); }
}

class JavaDemo {
    public static void main(String[] args) {
        JavaSuper s = new JavaSub();
        s.printState();
    }
}
</code></pre>
<footer><div class="footer-body"><p>What is printed? (<code>printState</code> is called two times.)</p>
</div></footer>
</div></section>
<p>The result is (<a href="Code/src/inheritance/constructors/JavaSuper.java">The complete code.</a>):</p>
<pre><code>x = 0
x = 42
</code></pre>
<p><strong>Problem</strong>: 
An overridable method called by a constructor may get invoked on a non-initialized receiver.
As a result a failure may occur.</p>
<p><strong>Reason</strong>: </p>
<ul>
<li>The superclass constructor runs before the subclass constructor. </li>
<li>The overridden method will get invoked before the subclass constructor has been invoked. </li>
<li>The overridden method will not behave as expected if it depends on any initialization done by the subclass constructor.</li>
</ul>
<section class="slide"><div class="section-body"><h1>Constructors Must Not Invoke Overridable Methods</h1>
<p><strong>Scala Example (One-to-one translation of the Java code)</strong></p>
<div style="position:absolute;bottom:20px;right:100px;background:#bbb;padding:1em">
Result:
  <code><pre>
  <strong><s>x = 0</s></strong>
  x = 42
  </pre></code>
</div>
<div style="position:absolute;bottom:245px;right:100px;background:#ffffaa;padding:1em">
Not idiomatic Scala code!
</div>
<pre><code class="Scala">class ScalaSuper {

    // executed at the end of the initialization
    printState();

    def printState() {
        println(&quot;no state&quot;)
    }
}

class ScalaSub extends ScalaSuper {
    var y: Int = 42 // What was the question?

    override def printState() { println(&quot;y = &quot;+y) }
}

object ScalaDemo extends App {
    val s = new ScalaSub
    s.printState() // after initialization
}
</code></pre>
</div></section>
<p>The complete code: <a href="Code/src/inheritance/constructors/SuperSubNonIdiomatic.scala">SuperSubNonIdiomatic.scala</a>.</p>
<p>For further details: <a href="http://www.scala-lang.org/docu/files/ScalaReference.pdf">Scala Language Specification</a></p>
<section class="slide"><div class="section-body"><h1>Constructors Must Not Invoke Overridable Methods</h1>
<p><strong>Scala Example (Refined using an early field definition clause.)</strong></p>
<div style="position:absolute;bottom:20px;right:100px;background:#bbb;padding:1em">
Result:<code><pre>
<strong>x = 42</strong>
x = 42
</pre></code></div>
<div style="position:absolute;bottom:200px;right:100px;background:#ffffaa;padding:1em">
Idiomatic Scala code!<br>
An <em>early field definition clause</em><br> is used to define the field value<br> before the supertype<br> constructor is called.
</div>
<pre><code class="Scala">class Super {

    // executed at the end of the initialization
    printState();

    def printState() {
        println(&quot;no state&quot;)
    }
}

class Sub(var y: Int = 42) extends Super {
    override def printState() {
        println(&quot;y = &quot;+y)
    }
}

object Demo extends App {
    val s = new Sub
    s.printState() // after initialization
}
</code></pre>
</div></section>
<p>The complete code: <a href="Code/src/inheritance/constructors/SuperSub.scala">SuperSub.scala</a>.</p>
<p>For further details: <a href="http://www.scala-lang.org/docu/files/ScalaReference.pdf">Scala Language Specification (5.1.6 Early Definitions)</a></p>
<p>Recommended reading: <a href="http://spot.colorado.edu/~reids/papers/how-scala-experience-improved-our-java-development-reid-2011.pdf">How Scala Experience Improved Our Java Development</a></p>
<h3>Variations At The Level Of Multiple Objects</h3>
<section class="slide" data-title="Variations at the Level of Multiple Objects"><div class="section-body"><h1>Variations at the Level of Multiple Objects</h1>
<p>So far:<br />
<strong>We considered variations, whose scope are individual classes.</strong></p>
<div class="statement">But, no class is an island!</div>
</div></section>
<p>Examples of class groupings:</p>
<ul>
<li>data structures such as trees and graphs,</li>
<li>sophisticated frameworks,</li>
<li>the entire application.</li>
</ul>
<p>Classes in a group may be related in different ways: </p>
<ul>
<li>by references to each other, </li>
<li>by signatures of methods and fields, </li>
<li>by instantiation, </li>
<li>by inheritance, </li>
<li>by shared state and dependencies. </li>
</ul>
<h4>Illustrative Example: Window Menus</h4>
<section class="slide" data-title="Illustrative Example: Window Menus"><div class="section-body"><h1>Illustrative Example: Window Menus</h1>
<p>  <img src="Images/Inheritance-ConcreteMenu.png" style="position:absolute;top:10px;right:5px"></p>
<p><img src="Images/Inheritance-Menus.png" alt="Inheritance Menus" /></p>
</div></section>
<p>For illustration, we will consider variations of menu structures:</p>
<ul>
<li>A menu is a GUI component consisting of a list of menu items corresponding to different application-specific actions. </li>
<li>Menus are usually organized hierarchically: a menu has several menu items.</li>
<li>There may be different variants of menus (popup, menu bar).</li>
<li>There may be different variants of menu items.</li>
<li>A menu item can be associated with a cascade menu which pops up when the item is selected.</li>
</ul>
<p>Menu and menu item objects are implemented by multiple classes that are organized in inheritance hierarchies to represent variations of the elements of the object structure.</p>
<ul>
<li>A menu represented by class <code>Menu</code> maintains a list of menu items. </li>
<li>Subclasses of <code>Menu</code> implement specialized menus.</li>
<li>A <code>PopupMenu</code> is a subclass of <code>Menu</code> implementing pop-up menus. </li>
<li><code>MenuBar</code> is a subclass of <code>Menu</code>, implementing a menu bar which is usually attached at the top edge of a window and serves as the top level menu object of the window.</li>
<li>Simple menu items are implemented by class <code>MenuItem</code>`</li>
<li><p>Subclasses of <code>MenuItem</code> implement specialized menu items: </p>
<ul>
<li>class <code>CheckMenuItem</code> for check-box menu items, </li>
<li>class <code>RadioMenuItem</code> for radio-button menu items, </li>
<li><code>CascadeMenuItem</code> for menu items that open cascade menus. It contains a reference to an instance of a <code>PopupMenu</code>, a subclass of <code>Menu</code> implementing pop-up menus. </li>
</ul>
</li>
</ul>
<section class="slide"><div class="section-body"><h1>Different Kinds of Menus</h1>
<pre><code class="Java">abstract class Menu { 
  List&lt;MenuItem&gt; items; 

  MenuItem itemAt(int i) { 
    return items.get(i); 
  } 

  int itemCount() { return items.size(); } 
  void addItem(MenuItem item) { items.add(item); } 
  void addAction(String label, Action action) { 
    items.add(new MenuItem(label, action)); 
  } 
   ... 
} 

class PopupMenu extends Menu { ... } 

class MenuBar extends Menu { ... } 
</code></pre>
</div></section>
<p>Classes involved in the implementation of menu functionality refer to each other in the declarations and implementations of their ﬁelds and methods. </p>
<section class="slide" data-title="Different Kinds of Menu Items"><div class="section-body"><h1>Different Kinds of Menu Items</h1>
<pre><code class="Java">class MenuItem { 
  String label; 
  Action action; 

  MenuItem(String label, Action action) {
    this.label = label; 
    this.action = action; 
  } 

  String displayText() { return label; } 

  void draw(Graphics g) { … displayText() … }
} 

class CascadeMenuItem extends MenuItem { 
  PopupMenu menu; 

  void addItem(MenuItem item) { menu.addItem(item); } 
  …
} 

class CheckMenuItem extends MenuItem { … }  

class RadioMenuItem extends MenuItem { … }
</code></pre>
</div></section>
<section class="slide" data-title="Inheritance for Optional Features of Menus"><div class="section-body"><h1>Inheritance for Optional Features of Menus</h1>
<ul>
<li>Variations of menu functionality affect multiple objects constituting the menu structure.</li>
<li>Since these objects are implemented by different classes, we need several new subclasses to express variations of menu functionality.</li>
<li><strong>This technique has several problems</strong>, which will be illustrated in the following by a particular example variation: Adding accelerator keys to menus. </li>
</ul>
</div></section>
<p>Various optional features related to functionality of menus: </p>
<ul>
<li>Support for accelerator keys for a quick selection of a menu item using a specific key stroke, </li>
<li>Support for multi-lingual text in menu items,</li>
<li>Support for context help, </li>
</ul>
<section class="slide" data-title="Menu Items with Accelerator Keys"><div class="section-body"><h1>Menu Items with Accelerator Keys</h1>
<pre><code class="Java">class MenuItemAccel extends MenuItem { 
  KeyStroke accelKey; 

  boolean processKey(KeyStroke ks) { 
    if (accelKey != null &amp;&amp; accelKey.equals(ks)) {  
      performAction(); 
      return true; 
    } 
    return false; 
  } 

  void setAccelerator(KeyStroke ks) { accelKey = ks; }

  void draw(Graphics g) { 
    super.draw(g); 
    displayAccelKey(); 
  }  
  … 
} 
</code></pre>
</div></section>
<p>The extension of menu items with accelerator keys is implemented in class <code>MenuItemAccel</code>, a subclass of <code>MenuItem</code>. </p>
<p>The extension affects both the implementation of existing methods as well as the structure and interface of menu items. E.g., the implementation of the <code>draw</code> method needs to be extended to display the accelerator key besides the label of the item.</p>
<p>New attributes and methods are introduced </p>
<ul>
<li>to store the key associated to the menu item, </li>
<li>to change this association, </li>
<li>to process an input key,</li>
<li>to display the accelerator key </li>
</ul>
<section class="slide" data-title="Menus with Accelerator Keys"><div class="section-body"><h1>Menus with Accelerator Keys</h1>
<pre><code class="Java">abstract class MenuAccel extends Menu {

  boolean processKey(KeyStroke ks) { 
    for (int i = 0; i &lt; itemCount(); i++) { 
      if (((MenuItemAccel) itemAt(i)).processKey(ks)) return true;  
    } 
    return false; 
  }

  void addAction(String label, Action action) { 
    items.add(new MenuItemAccel(label, action));
  } 
  …
} 
</code></pre>
</div></section>
<p><code>MenuAccel</code> implements the extension of menus with accelerator keys: </p>
<ul>
<li>adds the new method <code>processKey</code> for processing keys</li>
<li>overrides method <code>addAction</code> to ensure that the new item added for an action supports accelerator keys</li>
</ul>
<h4>Non-Explicit Covariant Dependencies</h4>
<section class="slide" data-title="Non-Explicit Covariant Dependencies"><div class="section-body"><h1>Non-Explicit Covariant Dependencies</h1>
<p><strong>Covariant dependencies between objects:</strong><br />
The varying functionality of an object in a group may need to access the corresponding varying functionality of another object of the group.</p>
<p>The type declarations in our design do not express covariant dependencies between the objects of a group. </p>
<p>References between objects are typed by invariant types, which provide a fixed interface.</p>
<p><em>Covariant dependencies are emulated by type-casts</em>.</p>
<pre><code class="Java">abstract class MenuAccel extends Menu {

  boolean processKey(KeyStroke ks) { 
    for (int i = 0; i &lt; itemCount(); i++) { 
      if (((MenuItemAccel) itemAt(i)).processKey(ks)) return true;  
    } 
    return false; 
  }
  …
} 
</code></pre>
<p>  <img src="Images/InTheRain.png" style="position:absolute;bottom:60px;right:20px"></p>
</div></section>
<p>The method <code>processKey</code> in a menu with accelerator keys needs to call <code>processKey</code> on its items.</p>
<ul>
<li>Items of a menu are accessed by calling the method <code>itemAt</code>. </li>
<li>The method <code>itemAt</code> is inherited from class <code>Menu</code>, where it was declared with return type <code>MenuItem</code>. </li>
<li>Thus, to access the extended functionality of menu items, <strong>we must cast the result</strong> of <code>itemAt</code> to <code>MenuItemAccel</code>. </li>
</ul>
<p>The design <strong>cannot guarantee that such a type cast will always be successful</strong>, because items of <code>MenuAccel</code> are added over the inherited method <code>addItem</code>, which accepts all menu items, both with and without the accelerator functionality.</p>
<p><strong>Potential for LSP violation!</strong></p>
<h4>Instantiation-Related Reusability Problems</h4>
<section class="slide" data-title="Instantiation-Related Reusability Problems"><div class="section-body"><h1>Instantiation-Related Reusability Problems</h1>
<p><strong>Code that instantiates the classes of an object group cannot be reused with different variations of the group.</strong></p>
<pre><code class="Java">abstract class Menu { 

  void addAction(String label, Action action) { 
    items.add(new MenuItem( // &lt;= Creates a MenuItem
      label, action
    )); 
  } 
  … 
} 
</code></pre>
<pre><code class="Java">abstract class MenuAccel extends Menu { 

  void addAction(String label, Action action) { 
    items.add(new MenuItemAccel( // &lt;= Creates a MenuItemAccel
    	label, action
    ));
  } 
  …
}
</code></pre>
<p><strong>Instantiation code can be spread all over the application.</strong></p>
</div></section>
<ul>
<li><code>MenuItem</code> is instantiated in <code>Menu.addAction(...)</code>. </li>
<li>In <code>MenuAccel</code>, we override <code>addAction(...)</code>, so that it instantiates <code>MenuItemAccel</code>. </li>
</ul>
<p>A menu of an application can be built from different reusable pieces, provided by different menu contributors.</p>
<section class="slide" data-title="Menu Contributor for Operations on Files"><div class="section-body"><h1>Menu Contributor for Operations on Files</h1>
<p><strong>A menu of an application can be built from different reusable pieces, provided by different menu contributors.</strong></p>
<pre><code class="Java">interface MenuContributor { 
   void contribute(Menu menu); 
} 
</code></pre>
<pre><code>class FileMenuContrib implements MenuContributor { 

  void contribute(Menu menu) { 
    CascadeMenuItem openWith = new CascadeMenuItem(”Open With”);       
    menu.addItem(openWith);
    MenuItem openWithTE = 
	 new MenuItem(”Text Editor”, createOpenWithTEAction());        
    openWith.addItem(openWithTE);

    MenuItem readOnly = 
        new CheckMenuItem(”Read Only”, createReadOnlyAction()); 
    menu.addItem(readOnly) 
    …  
   } 
   …  
}
</code></pre>
</div></section>
<p>The code shows the implementation of a menu contributor for operations on ﬁles. It implements the method contribute, which extends the given menu object with menu items to open ﬁles with diﬀerent text editors, to change the read-only ﬂag of the ﬁle, and so on. Since the menu items are created by directly instantiating the respective classes, this piece of code cannot be reused for menus with support for key accelerators or any other extensions of the menu functionality. </p>
<section class="slide"><div class="section-body"><h1>Instantiation-Related Reusability Problem</h1>
<ul>
<li>In some situations, overriding of instantiation code can cause a cascade effect. </li>
<li>An extension of class C mandates extensions of all classes that instantiate C.</li>
<li>This in turn mandates extensions of further classes that instantiate classes that instantiate C. </li>
</ul>
<footer><div class="footer-body"><p>Can you imagine a workaround to address instantiation-related problems?</p>
</div></footer>
</div></section>
<section class="slide" data-title="Abstract Factory Pattern"><div class="section-body"><h1>Abstract Factory Pattern</h1>
<p><img src="Images/Inheritance-AbstractFactory.png" alt="Inheritance AbstractFactory" /></p>
</div></section>
<section class="slide" data-title="Factories for Instantiating Objects"><div class="section-body"><h1>Factories for Instantiating Objects</h1>
<pre><code class="Java">interface MenuFactory { 
  MenuItem createMenuItem(String name, Action action); 
  CascadeMenuItem createCascadeMenuItem(String name); 
  … 
} 
</code></pre>
<p>The <em>Abstract Factory design pattern</em> enables abstraction from group variations by late-bound instantiation of the classes of the group’s objects.</p>
</div></section>
<section class="slide"><div class="section-body"><h1>Factories for Instantiating Objects</h1>
<pre><code class="Java">class FileMenuContrib implements MenuContributor { 

  void contribute(
      Menu menu, 
      MenuFactory factory // &lt;= we need a reference to the factory
  ) { 
    MenuItem openWith = 
        factory.createCascadeMenuItem(”Open With”);
    menu.addItem(openWith); 
    MenuItem openWithTE = factory.createMenuItem(...); 
    openWith.addItem(openWithTE); 
    … 
    MenuItem readOnly = factory.createCheckMenuItem(...);
    menu.addItem(readOnly) 
    … 
  } 
  … 
} 
</code></pre>
</div></section>
<p>The code of <code>FileMenuContrib</code> can be reused with different variations of menu functionality, by using it with different factory implementations.</p>
<section class="slide"><div class="section-body"><h1>Factories for Instantiating Objects</h1>
<pre><code class="Java">class BaseMenuFactory implements MenuFactory { 

  MenuItem createMenuItem(String name, Action action) {     
    return new MenuItem(name, action);  
  }

  CascadeMenuItem createCascadeMenuItem(String name) { 
    return new CasadeMenuItem(name); 
  } 
  …
} 
</code></pre>
<hr />
<pre><code class="Java">class AccelMenuFactory implements MenuFactory { 

  MenuItemAccel createMenuItem(String name, Action action) { 
    return new MenuItemAccel(name, action); 
  } 

  CascadeMenuItemAccel createCascadeMenuItem(String name) {
    return new CasadeMenuItemAccel(name); 
  } 
  …
} 
</code></pre>
</div></section>
<section class="slide" data-title="Deficiencies Of The Factory Pattern"><div class="section-body"><h1>Deficiencies Of The Factory Pattern</h1>
<ul>
<li>The infrastructure for the design pattern must be implemented and maintained. </li>
<li>Increased complexity of design.</li>
<li><p>Correct usage of the pattern cannot be enforced: </p>
<ul>
<li>No guarantee that classes are instantiated exclusively over factory methods, </li>
<li>No guarantee that only objects are used together that are instantiated by the same factory. </li>
</ul>
</li>
<li><p>Issues with managing the reference to the abstract factory. </p>
<ul>
<li>The factory can be implemented as a Singleton for convenient access to it within entire application.<br />
This solution <strong>would allow to use only one specific variant</strong> of the composite within the same application. </li>
<li>A more flexible solution requires explicit passing of the reference to the factory from object to object.<br />
<strong>Increased complexity of design.</strong></li>
</ul>
</li>
</ul>
</div></section>
<p>Several studies have shown that the comprehensibility of some code/framework  significantly decreases, when it is no longer possible to directly instantiate objects.</p>
<h4>Combining Composite &amp; Individual Variations</h4>
<section class="slide" data-title="Combining Composite &amp; Individual Variations"><div class="section-body"><h1>Combining Composite &amp; Individual Variations</h1>
<div class="statement">Problem: How to combine variations of individual classes with those of features of a class composite.</div>
<p>Feature variations at the level of object composites (e.g., accelerator key support).</p>
<p>Variations of individual elements of the composite (e.g., variations of menus and items).</p>
</div></section>
<section class="slide" data-title="Menu Items with Accelerator Keys"><div class="section-body"><h1>Menu Items with Accelerator Keys</h1>
<pre><code class="Java">class MenuItemAccel extends MenuItem { 
</code></pre>
<pre><code class="no-highlight">    KeyStroke accelKey; 
    boolean processKey(KeyStroke ks) { 
      if (accelKey != null &amp;&amp; accelKey.equals(ks)) {  
        performAction(); 
        return true; 
      } 
      return false; 
    } 
    void setAccelerator(KeyStroke ks) { accelKey = ks; } 
    void draw(Graphics g) { super.draw(g); displayAccelKey(); }  
    …
</code></pre>
<pre><code class="Java">} 

class CascadeMenuItemAccel extends ???
class CheckMenuItemAccel extends ???
class RadioMenuItemAccel extends ???
</code></pre>
<footer><div class="footer-body"><p>How to extend subclasses of <code>MenuItem</code> for different variants of items with the accelerator key feature? </p>
<p>We need subclasses of them that also inherit the additional functionality in <code>MenuItemAccel</code>.</p>
</div></footer>
</div></section>
<section class="slide" data-title="Menus with Accelerator Keys"><div class="section-body"><h1>Menus with Accelerator Keys</h1>
<pre><code class="Java">abstract class MenuAccel extends Menu { 
</code></pre>
<pre><code class="no-highlight">  boolean processKey(KeyStroke ks) { 
    for (int i = 0; i &lt; itemCount(); i++) { 
      if (((MenuItemAccel) itemAt(i)).processKey(ks)) return true;  
    } 
    return false; 
  } 

  void addAction(String label, Action action) { 
    items.add(new MenuItemAccel(label, action));
  } 
  …
</code></pre>
<pre><code class="Java">}

class PopupMenuAccel extends ??? 
class MenuBarAccel extends ???
</code></pre>
<footer><div class="footer-body"><p>How to extend subclasses of Menu with the accelerator key feature? </p>
<p>We need subclasses of them that also inherit the additional functionality in <code>MenuAccel</code>.</p>
</div></footer>
</div></section>
<section class="slide" data-title="Combining Composite &amp; Individual Variations"><div class="section-body"><div class="statement">In languages with single inheritance, such as Java, combining composite &amp; individual variations is non-trivial and leads to code duplication.</div>
</div></section>
<section class="slide" data-title="The Problem in a Nutshell"><div class="section-body"><h1>The Problem in a Nutshell</h1>
<p><img src="Images/Inheritance-AbstractExample.png" alt="Inheritance AbstractExample" /></p>
<ul>
<li>We need to extend <code>A</code> (and parallel to it also its subclasses <code>B</code> and <code>C</code>) with an optional feature (<em>should not necessarily be visible to existing clients</em>).</li>
<li>This excludes the option of modifying <code>A</code> in-place, which would be bad anyway because of OCP.</li>
</ul>
</div></section>
<section class="slide"><div class="section-body"><h1>Alternative Designs</h1>
<p><img src="Images/Inheritance-AbstractExampleAlternativesI.png" alt="Inheritance AbstractExampleAlternativesI" /> </p>
<hr />
<p><img src="Images/Inheritance-AbstractExampleAlternativesII.png" alt="Inheritance AbstractExampleAlternativesII" /></p>
</div></section>
<p>There are two possibilities ( (I) creating a parallel hierarchy or (II) creating additional subclasses of <code>B</code> and <code>C</code>) to add an optional feature to <code>A</code> incrementally without affecting clients in a single inheritance setting. </p>
<p>In both cases, code needs to be duplicated which leads to a maintenance problem.</p>
<section class="slide"><div class="section-body"><h1>Combining Composite and Individual Variations</h1>
<h2>Using some form of multiple inheritance</h2>
<pre><code class="Java">class PopupMenuAccel extends PopupMenu, MenuAccel { } 
class MenuBarAccel extends MenuBar, MenuAccel { }
</code></pre>
<pre><code class="Java">class CascadeMenuItemAccel extends CascadeMenuItem, MenuItemAccel {    
  boolean processKey(KeyStroke ks) { 
    if (((PopupMenuAccel) menu).processKey(ks) ) return true;  
    return super.processKey(ks); 
  } 
} 

class CheckMenuItemAccel extends CheckMenuItem, MenuItemAccel { ... }
class RadioMenuItemAccel extends RadioMenuItem, MenuItemAccel { ... }
</code></pre>
<footer><div class="footer-body"><p>Does this solve our problem?</p>
</div></footer>
</div></section>
<div class="statement">The design with multiple inheritance has its problems.</div>
<p>It requires additional class declarations that explicitly combine the extended element class representing the composite variation with sub-classes that describe its individual variations. </p>
<ul>
<li>Such a design produces an excessive number of classes.</li>
<li>The design is also not stable with respect to extensions with new element types.</li>
<li>The developer must not forget to extend the existing variations of the composite with combinations for the new element types. </li>
</ul>
<h4>Summary</h4>
<section class="slide" data-title="Summary"><div class="section-body"><h1>Summary</h1>
<ul>
<li><p>General agreement in the early days of OO:<br />
<strong>Classes are the primary unit of organization.</strong></p>
<ul>
<li>Standard inheritance operates on isolated classes.</li>
<li>Variations of a group of classes can be expressed by applying inheritance to each class from the group separately. </li>
</ul>
</li>
<li><p>Over the years, it turned out that sets of collaborating classes are also units of organization. In general, extensions will generally affect a set of related classes.</p>
</li>
</ul>
</div></section>
<section class="slide"><div class="section-body"><div class="statement">(Single-) Inheritance does not appropriately support OCP with respect to changes that affect a set of related classes!</div>
<p>Mainstream OO languages have only insufficient means for organizing collaborating classes: packages, name spaces, etc. These structures have serious problems:</p>
<ul>
<li>No means to express variants of a collaboration.</li>
<li>No polymorphism.</li>
<li>No runtime semantics.</li>
</ul>
<div class="statement">Almost all features that proved useful for single classes are not available for sets of related classes.</div>
</div></section>
<section class="slide" data-title="Desired Features"><div class="section-body"><h1>Desired Features</h1>
<ul>
<li><p><strong>Incremental programming at the level of sets of related classes.</strong><br />
In analogy to incremental programming at the level of individual classes enabled by inheritance. <em>(I.e., we want to be able to model the accelerator key feature by the difference to the default menu functionality.)</em></p>
</li>
<li><p><strong>Polymorphism at the level of sets of related classes → Family polymorphism.</strong><br />
In analogy to subtype polymorphism at the level of individual classes.
<em>(I.e., we want to be able to define behavior that is polymorphic with respect to the particular object group variation.)</em></p>
</li>
</ul>
</div></section>
<section class="slide" data-title="Family Polymorphism"><div class="section-body"><h1>&quot;Family Polymorphism&quot;</h1>
<p><img src="Images/Inheritance-MenusFamilyPolymorphism.png" alt="Inheritance MenusFamilyPolymorphism" /></p>
<p>We want to avoid:</p>
<ul>
<li>code duplication</li>
<li>casts</li>
<li>the necessity to re-implement methods (e.g. <code>addAction</code>)</li>
</ul>
<p><strong>Ideally would like to have several versions of class definitions - one per responsibility - which can be mixed and matched on-demand.</strong></p>
<p>   <div style="position:absolute;bottom:0;right:0;background:#bbb;border:0 0;margin: 0 0;padding: 0.5em 0.5em">
Recall the SmartHome example.
   </div></p>
</div></section>
<p>The question may arise whether this is this a real problem or not. As we will see in the following it is a very real problem which even shows up in mature deployed software.</p>
<h4>Case Study: Java AWT and Swing</h4>
<p>Some of the material used in the following originally appeared in the paper: Bergel et al, <em>Controlling the Scope of Change in Java</em>, <strong>International Conference on Object-Oriented Programming Systems Languages and Applications 2005</strong></p>
<p>AWT is a GUI framework that was included in the first Java release and which directly interfaces the underlying operating system. Therefore, only a small number of widgets are supported to make code easier to port.</p>
<p>Swing extends AWT core classes (by subclassing) with functionality such as: &quot;pluggable look and feel&quot; and &quot;double buffering&quot;. The Swing-specific support for double buffering to provide smooth flicker-free animation is implemented, among others, in the methods <code>update()</code>, <code>setLayout()</code>, etc.. Furthermore, Swing adds more widgets.</p>
<section class="slide" data-title="The Design of AWT and Swing"><div class="section-body"><h1>The Design of AWT and Swing</h1>
<p>  <img src="Images/Inheritance-CaseStudyAWTSwing.png" style="float:right;padding:0 0" ></p>
<p>A small subset of the core of AWT (<code>Component</code>, <code>Container</code>, <code>Frame</code>, <code>Window</code>) and Swing.</p>
</div></section>
<p><strong>Issues:</strong></p>
<ul>
<li>Features defined in <code>JWindow</code> are duplicated in <code>JFrame</code>. Due to the absence of an inheritance link between <code>JFrame</code> and <code>JWindow</code> (<code>JWindow</code>: 551 LOC; <code>JFrame</code>: 829 LOC, 241 lines of code are duplicated; 43% of <code>JWindow</code> reappears as 29% of <code>JFrame</code>.</li>
<li>While a <code>Window</code> is a <code>Component</code> in AWT, a <code>JWindow</code> is not a <code>JComponent</code> in Swing.</li>
<li>While a <code>Button</code> is a Component and <code>JButton</code> is a <code>JComponent</code>, a <code>JButton</code> is not a <code>Button</code>!</li>
<li>A Swing <code>Component</code> is a <code>Container</code> for other components.<br />
<em>Feature inherited from <code>Container</code> (<code>JComponent extends Container</code>).</em></li>
<li>Types of subcomponents in <code>Container</code> are <code>Component</code> not <code>JComponent</code>.</li>
<li>Ubiquitous runtime type checks and type casts are the result!</li>
</ul>
<section class="slide" data-title="AWT Code"><div class="section-body"><h1>AWT Code</h1>
<pre><code class="Java">public class Container extends Component {
  int ncomponents;
  Component components[] = new Component[0];
   
  public Component add (Component comp) {
    addImpl(comp, null, -1);
    return comp;
  }

  protected void addImpl(Component comp, Object o, int ind) {
    …
    component[ncomponents++] = comp;
    …
  }

  public Component getComponent(int index) {
    return component[index];
  }
}
</code></pre>
<footer><div class="footer-body"><p>The code contains no type checks and/or type casts.</p>
</div></footer>
</div></section>
<section class="slide" data-title="Swing Code"><div class="section-body"><h1>Swing Code</h1>
<pre><code class="Java">public class JComponent extends Container {

  public void paintChildren (Graphics g) {
    …
    for (; i &gt; = 0 ; i--) {
      Component comp = getComponent (i);
      isJComponent = (comp instanceof JComponent); // type check
      …
      ((JComponent)comp).getBounds(); // type cast
      …
    }
  }
}
</code></pre>
<footer><div class="footer-body"><p>The code contains (many) type checks and/or type casts.</p>
</div></footer>
</div></section>
<section class="slide" data-title="About the Development of Swing"><div class="section-body"><h1>About the Development of Swing</h1>
<blockquote><p>“In the absence of a large existing base of clients of AWT, Swing might have been designed differently, with AWT being refactored and redesigned along the way.</p>
<p>Such a refactoring, however, was not an option and we can witness various anomalies in Swing, such as duplicated code, sub-optimal inheritance relationships, and excessive use of run-time type discrimination and downcasts.”</p>
</blockquote>
</div></section>
<h2>Takeaway</h2>
<section class="slide" data-title="Takeaway"><div class="section-body"><h1>Takeaway</h1>
<ul>
<li><p>Inheritance is a powerful mechanism for supporting variations and stable designs in presence of change.<br />
Three desired properties:</p>
<ul>
<li><strong>Built-in support for OCP</strong> and reduced need for preplanning and abstraction building.</li>
<li><strong>Well-modularized</strong> implementations of variations.</li>
<li><strong>Support for variation of structure/interface</strong> in addition to variations of behavior.</li>
<li><strong>Variations</strong> can participate in <strong>type declarations</strong>.</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li><p>Inheritance has also deficiencies</p>
<ul>
<li><p><strong>Variation implementations are not reusable and not easy to compose.</strong></p>
<ul>
<li>Code duplication.</li>
<li>Exponential growth of the number of classes; complex designs.</li>
</ul>
</li>
<li><strong>Inheritance does not support dynamic variations</strong> – configuring the behavior and structure of an object at runtime.</li>
<li><strong>Fragility of designs</strong> due to lack of encapsulation between parents and heirs in an inheritance hierarchy.</li>
<li><strong>Variations that affect a set of related classes are not well supported.</strong><br /></li>
</ul>
</li>
</ul>
</div></section>
<h1>Design Patterns</h1>
<h2>Introduction to Design Patterns</h2>
<section class="slide" data-title="What is a Design Pattern"><div class="section-body"><h1>What is a Design Pattern</h1>
<blockquote><p>A design pattern describes:</p>
<ul>
<li><p>A problem that occurs over and over again in our environment.</p>
</li>
<li><p>The core of the solution to that problem, </p>
</li>
<li>in such a way that you can use this solution a million times over, without ever doing it the same way twice.</li>
</ul>
<p><strong>Christopher Alexander, professor of architecture.</strong></p>
</blockquote>
</div></section>
<section class="slide"><div class="section-body"><h1>What is a Design Pattern</h1>
<div class="statement">Aggressive disregard for originality.</div>
<p><strong>Rule of three:</strong></p>
<ul>
<li>Once is an event.</li>
<li>Twice is an incident.</li>
<li>Thrice it’s a pattern. </li>
</ul>
</div></section>
<section class="slide" data-title="Motivation for Software Design Patterns"><div class="section-body"><h1>Motivation for Software Design Patterns</h1>
<p>  <img src="Images/Cover-DesignPatterns.jpg" style="float:right"></p>
<ul>
<li><p><strong>Designing reusable software is hard! (Originality is Overrated)</strong></p>
</li>
<li><p><strong>Some design solutions reoccur. Understanding their core is beneficial.</strong></p>
</li>
<li><p><strong>Systematic software-development</strong></p>
</li>
</ul>
</div></section>
<ul>
<li><p>Designing reusable software is hard! (Originality is Overrated)<br /></p>
<ul>
<li>Novices are overwhelmed.</li>
<li>Experts draw from experience.</li>
</ul>
</li>
<li><p>Some design solutions reoccur. Understanding their core is beneficial.</p>
<ul>
<li>Know when to apply.</li>
<li>Know how to establish them in a generic way.</li>
<li>Know the consequence (trade-offs).</li>
</ul>
</li>
<li><p>Systematic software-development</p>
<ul>
<li>Documenting expert knowledge.</li>
<li>Use of generic solutions.</li>
<li>Use of shared vocabulary.</li>
<li>Raising the abstraction level.</li>
</ul>
</li>
</ul>
<section class="slide" data-title="Design Patterns and Change"><div class="section-body"><h1>Design Patterns and Change</h1>
<p>  <img src="Images/Cover-DesignPatterns.jpg" style="float:right"></p>
<ul>
<li><p><strong>Most patterns address issues of software change.</strong></p>
<ul>
<li><p>Most patterns allow some part of the system to vary independent of the other parts.</p>
</li>
<li><p>We often try to identify what varies in a system and encapsulate it.</p>
</li>
</ul>
</li>
</ul>
</div></section>
<section class="slide" data-title="Elements of Design Patterns"><div class="section-body"><h1>Elements of Design Patterns</h1>
<p>  <img src="Images/Cover-DesignPatterns.jpg" style="float:right"></p>
<ul>
<li><p><strong>Pattern Name</strong></p>
</li>
<li><p><strong>Intent</strong></p>
</li>
<li><p><strong>Solution</strong></p>
</li>
<li><p><strong>Consequences</strong></p>
</li>
</ul>
</div></section>
<ul>
<li><strong>Pattern Name</strong>: A short mnemonic to increase your design vocabulary.</li>
<li><strong>Intent</strong>: Description when to apply the pattern (conditions that have to be met before it makes sense to apply the pattern).</li>
<li><strong>Solution</strong>: The elements that make up the design, their relationships, responsibilities, and collaborations.</li>
<li><strong>Consequences</strong>: Costs and benefits of applying the pattern. Language and implementation issues as well as impact on system flexibility, extensibility, or portability.<br />
The goal is to help understand and evaluate a pattern.</li>
</ul>
<section class="slide" data-title="R. Martin&apos;s Chess Analogy"><div class="section-body"><h1>R. Martin&apos;s Chess Analogy</h1>
<ul>
<li><p>When people begin to play chess they learn the rules and physical requirements of the game.</p>
</li>
<li><p>As they progress, they learn the principles.</p>
</li>
<li><p>However, to become a master of chess, one must study games of other masters.</p>
</li>
</ul>
<hr />
<ul>
<li><p>So it is with software. First one learns the rules. The algorithms, data structures, and languages of software.<br /></p>
</li>
<li><p>Later, one learns the principles of software design.<br /></p>
</li>
<li><p>But to truly master software design, one must study the designs of other masters. </p>
</li>
</ul>
</div></section>
<section class="story"><div class="section-body"><h1>R. Martin‘s Chess Analogy</h1>
<p>When people begin to play chess they learn the rules and physical requirements of the game. They learn the names of the pieces, the way they move and capture, the board geometry and orientation. 
At this point, people can play chess, although they will probably not be very good players. </p>
<p>As they progress, they learn the principles. They learn the value of protecting the pieces and their relative value. They learn the strategic value of the center squares and the power of a threat…</p>
<p>At this point, they can play a good game. They know how to reason through the game and can recognize “stupid” mistakes.</p>
<p>However, to become a master of chess, one must study games of other masters. Buried in those games are patterns that must be understood, memorized, and applied repeatedly until they become second nature. </p>
<p>There are thousands upon thousands of these patterns. Opening patterns are so numerous that there are books dedicated to their variations. Midgame patterns and ending patterns are also prevalent, and the master must be familiar with them all. </p>
<p>So it is with software. First one learns the rules. The algorithms, data structures, and languages of software. 
At this point, one can write programs, albeit not very good ones. </p>
<p>Later, one learns the principles of software design. One learns the 
importance of cohesion and coupling, of information hiding and dependency management. </p>
<p>But to truly master software design, one must study the designs of other masters. Deep within those designs 
are patterns that can be used in other designs. Those patterns must be understood, memorized, and applied 
repeatedly until they become second nature. </p>
</div></section>
<section class="slide" data-title="Software Patterns"><div class="section-body"><h1>Software Patterns</h1>
<p>Some selected books:</p>
<p><img src="Images/Cover-DesignPatterns.jpg" alt="Cover DesignPatterns" />
<img src="Images/Cover-HeadsFirstDesignPatterns.jpg" alt="Cover HeadsFirstDesignPatterns" />
<img src="Images/Cover-PatternsOfEAA.jpg" alt="Cover PatternsOfEAA" />
<img src="Images/Cover-SystemOfPatterns.jpg" alt="Cover SystemOfPatterns" /></p>
<p>(And many more books!)</p>
</div></section>
<section class="slide" data-title="Patterns in Architecture"><div class="section-body"><h1>Patterns in Architecture</h1>
<p><img src="Images/DP-PatternsInArchitecture.png" alt="DP PatternsInArchitecture" /></p>
</div></section>
<p>In architecture there are also rules (e.g., specification of required amount of light in a room) as in software design (e.g., low coupling, high cohesion, number of parameters per method), but in both cases these rules allow to judge an existing configuration but do not generate solutions. Patterns are working solutions and represent solutions that obey design rules and, moreover, suggest a specific solution (dining corner with light from three sides, curved entry path).</p>
<div class="statement">Patterns are ubiquitous.</div>
<section class="slide" data-title="Patterns Taught in SED&amp;C"><div class="section-body"><h1>Patterns Taught in SED&amp;C</h1>
<ul>
<li>Quick warm up with the Template Method Pattern</li>
<li>The Strategy Pattern</li>
<li>The Decorator Pattern</li>
<li>The Proxy Pattern</li>
<li>The Visitor Pattern</li>
<li>The Bridge Pattern</li>
<li>The Adapter Pattern</li>
<li>The Builder Pattern</li>
<li>The Command Pattern</li>
</ul>
</div></section>
<h2>Template-Method Design Pattern</h2>
<section class="slide" data-title="The Template-Method Pattern in a Nutshell"><div class="section-body"><h1>The Template-Method Pattern in a Nutshell</h1>
<p><strong>Intent:</strong></p>
<ul>
<li>Separate high-level policies from detailed low-level mechanisms.</li>
<li>Separate invariant from variant parts.</li>
</ul>
<p>  <img src="Images/DP-TemplateMethod-Structure.png" style="float:right"></p>
<p><strong>Solution Idea</strong><br />
Use abstract classes to: </p>
<ul>
<li>Define interfaces to detailed mechanisms and variant parts.</li>
<li>Implement high-level policies and invariant parts to these interfaces.</li>
<li>Control sub-class extensions.</li>
<li>Avoid code duplication.</li>
</ul>
</div></section>
<p>The Template-Method Pattern plays a key role in the design of object-oriented frameworks.</p>
<section class="slide" data-title="Example Application of Template Method"><div class="section-body"><h1>Example Application of Template Method</h1>
<p><strong>Functional requirements:</strong></p>
<ul>
<li>Need a family of sorting algorithms …
(bubble sort, quick sort, etc.)</li>
<li>for different kinds of data (int, double, etc.)</li>
<li>Clients that use sorting algorithms should be reusable with the variety of specific algorithms.</li>
</ul>
<p><strong>Non-functional requirements on the design</strong></p>
<ul>
<li>Need to separate the high-level „sorting“ policies from low-level mechanisms.</li>
<li><p>Low-level mechanisms are responsible for:</p>
<ul>
<li>deciding when an element is out of order,</li>
<li>swapping out-of-order elements.</li>
</ul>
</li>
</ul>
</div></section>
<section class="slide" data-title="Separating the Policy of Sorting"><div class="section-body"><h1>Separating the Policy of Sorting</h1>
<p>  <img src="Images/DP-TemplateMethodBubbleSorter.png" style="float:right"></p>
<pre><code class="Java">public abstract class BubbleSorter {
  protected int length = 0;
</code></pre>
<p>  <em>Policy</em>:<br /></p>
<pre><code class="Java">  protected void sort() {
    if (length &lt;= 1) return;
      for (int nextToLast = length - 2; nextToLast &gt;= 0; nextToLast--)
        for (int index = 0; index &lt;= nextToLast; index++)
          if (outOfOrder(index)) swap(index);
  }
</code></pre>
<p>  <em>Mechanisms</em>:</p>
<pre><code class="Java">  protected abstract void swap(int index);
  protected abstract boolean outOfOrder(int index);
</code></pre>
<pre><code class="Java">}
</code></pre>
</div></section>
<p>Implement the sorting policy in a template method, <code>sort</code>. Hide mechanisms needed for implementing the sorting policy behind abstract methods (<code>outOfOrder</code> and <code>swap</code>), which are called by the template method.</p>
<section class="slide" data-title="Filling the Template for Specific Algorithns"><div class="section-body"><h1>Filling the Template for Specific Algorithns</h1>
<p>  <img src="Images/DP-TemplateMethodBubbleSorter.png" style="float:right"></p>
<pre><code class="Code">public class IntBubbleSorter 
  extends BubbleSorter {
	  
  private int[] array = null;

  public void sort(int[] theArray) {
    array = theArray;
	length = array.length;
    super.sort();
  }
  protected void swap(int index) {
    int temp = array[index];
    array[index] = array[index + 1];
    array[index + 1] = temp;
  }
  protected boolean outOfOrder(int index) {
    return (array[index] &gt; array[index + 1]);
  }
}
</code></pre>
<footer><div class="footer-body"><p>What are the advantages and deficiencies of the Template-Method Pattern?</p>
</div></footer>
</div></section>
<p>The advantages and deficiencies of the Template-Method Pattern are basically those of inheritance:
<strong>Template method forces mechanisms to extend a specific policy.</strong></p>
<ul>
<li>Implementation of low-level mechanisms depends on the template.</li>
<li>Cannot re-use low-level mechanisms functionality.<br />
<code>swap</code> and <code>outOfOrder</code> implemented in <code>IntBubbleSorter</code> may be useful in other contexts as well, e.g., for quick sort.</li>
</ul>
<section class="slide" data-title="Template Method Pattern in Log4J"><div class="section-body"><h1>Template Method Pattern in Log4J</h1>
<p>  <img src="Images/DP-Log4J.png" style="float:right"></p>
<p><strong><code>interface Appender</code></strong><br />
Implement this interface for your own strategies for outputting log statements.
[…] <br /></p>
<ul>
<li><p><code>public void doAppend(LoggingEvent event)</code><br />
Log in Appender specific way.</p>
</li>
</ul>
<p><strong><code>abstract class AppenderSkeleton implements Appender</code></strong><br />
Abstract superclass of the other appenders. This class provides the code for common functionality, such as support for threshold filtering and support for general filters.
[…]<br /></p>
<ul>
<li><code>protected abstract void append(LoggingEvent event)</code><br />
Subclasses should implement this method to perform actual logging.</li>
<li><code>public void doAppend(LoggingEvent event)</code><br />
This method performs threshold checks and invokes filters before delegating actual logging to the append(LoggingEvent) method.</li>
</ul>
</div></section>
<section class="slide" data-title="Functional Counterpart of Template"><div class="section-body"><h1>Functional Counterpart of Template</h1>
<p>One can look at the Template-Method Pattern as a style for emulating higher-order functions available in programming languages that support functional-style programming.</p>
<hr />
<p>Alternative design for Log4J in Scala<strong>?</strong></p>
<pre><code class="Scala">class AppenderSkeleton(
  private val append : (LoggingEvent) =&gt; Unit
) {
  def doAppend(loggingEvent : LoggingEvent) {
    // filtering, threshold checks, …
    append(loggingEvent)
  }
}
</code></pre>
<aside data-title="Higher-order Functions"><div class="aside-body"><p><strong><em>Higher-order function</em>: A function parameterized by other functions.</strong></p>
<ul>
<li><em>First-order functions</em> abstract over variations in data.</li>
<li><em>Higher-order functions</em> abstract over variations in sub-computations.</li>
<li><em>First-class functions</em> are values that can be passed as parameters and returned as results. </li>
</ul>
</div></aside>
</div></section>
<p>Whether this is a feasible design or not requires a detailed analysis of the context; i.e., the <code>AppenderSkeleton</code> class. In this case, the method <code>close</code> indicates that an <code>Appender</code> may be in different states which suggests that the standard implementation approach is best suited (also in Scala).</p>
<section class="slide" data-title="A &quot;repeat&quot; Abstraction in Scala"><div class="section-body"><h1>A <code>repeat</code> Abstraction in Scala</h1>
<p>Policy: Repeat the same operation n-times and store the results in an array.<br /></p>
<pre><code class="Scala">object RepeatAbstraction {
  def repeat[T: scala.reflect.ClassTag](times: Int)(f: ⇒ T): Array[T] = {
    val array = new Array[T](times)
    var i = 0
    while (i &lt; times) { array(i) = f ; i += 1 }
    array
} }
</code></pre>
<p><em>Example usage</em> (e.g., using the Scala REPL):</p>
<pre><code class="Scala">import RepeatAbstraction._

val result: Array[Int] = repeat(3) { System.in.read() }
// Long version:
// val body /*: () ⇒ Int*/ = () ⇒ { System.in.read() }
// val result : Array[Int] = repeat(3)(/*f =*/ body())

println(&quot;Charcodes: &quot;+result.mkString(&quot; &quot;))
</code></pre>
</div></section>
<p>This solution allows us to reuse our <em>low-level mechanism</em>.</p>
<h2>Strategy Design Pattern</h2>
<h3>The Strategy Pattern in a Nutshell</h3>
<section class="slide" data-title="The Strategy Pattern in a Nutshell"><div class="section-body"><h1>The Strategy Pattern in a Nutshell</h1>
<p><img src="Images/DP-Strategy-Structure.png" alt="DP Strategy Structure" /></p>
<p><em>Intent</em>:</p>
<ul>
<li>Define a family of algorithms,</li>
<li>Encapsulate each one,</li>
<li>Make them interchangeable at runtime.</li>
</ul>
<div class="statement">Strategy lets the algorithm vary dynamically and independently from clients that use it.</div>
</div></section>
<section class="slide" data-title="When to Use the Strategy Pattern"><div class="section-body"><h1>When to Use the Strategy Pattern</h1>
<p><img src="Images/DP-Strategy-Structure.png" alt="DP Strategy Structure" /></p>
<ul>
<li><p>You need different variants of an algorithm.</p>
</li>
<li><p>You need to select the variant of an algorithm dynamically.</p>
</li>
</ul>
</div></section>
<p><strong>You need different variants of an algorithm.</strong></p>
<ul>
<li>Strategies can be used when variants of algorithms are implemented as a class hierarchy.</li>
<li>Many related classes differ only in their behavior rather than implementing different related abstractions (types).</li>
<li>Strategies allow to configure a class with one of many behaviors.</li>
</ul>
<p><strong>You need to select the variant of an algorithm dynamically.</strong></p>
<ul>
<li>There are classes in your design that define many behaviors that appear as multiple conditional statements in its operations.</li>
<li>Move related conditional branches into a strategy.</li>
</ul>
<section class="slide" data-title="Strategy as an Alternative to Inheritance"><div class="section-body"><h1>Strategy as an Alternative to Inheritance</h1>
<p>The Strategy Pattern represents an alternative to modeling different algorithms (sub-behaviors) as subclasses of a usage Context.</p>
<p>Inheritance mixes an algorithm‘s implementation with that of the Context. The Context may become harder to understand, maintain, extend.</p>
<p>Inheritance results in many related classes which only differ in the algorithm or behavior they employ.</p>
<p>When using subclassing we cannot vary the algorithm dynamically.</p>
</div></section>
<p>Encapsulating the algorithm in a Strategy:</p>
<ul>
<li>Lets you vary the algorithm independently of its usage context.</li>
<li>Makes it easier to switch, understand, and extend the algorithm.</li>
</ul>
<section class="slide" data-title="Sorting Example with Strategy"><div class="section-body"><h1>Sorting Example with Strategy</h1>
<p><img src="Images/DP-Strategy-Example.png" alt="DP Strategy Example" /></p>
</div></section>
<p><code>BubbleSorter</code> and <code>QuickSorter</code> embody different high-level policies for sorting the elements of a list. They outsource to <code>SortHandle</code> the decision about the concrete mechanisms for element ordering and for swapping. <code>SortHandle</code> declares the common interface of low-level sorting mechanisms. <code>IntSortHandle</code> and <code>DoubleSortHandle</code> implement this interface in different ways.</p>
<p>Not only are sorting policies reusable with (independent of) different ordering and swapping mechanisms; the latter become reusable with (independent of) different high-level sorting policies. </p>
<p>Furthermore, it is possible to customize the mechanisms dynamically.</p>
<p><strong>Recall the dependency-inversion principle: High-level policies should not depend on low-level mechanisms. Both should depend on abstractions.</strong></p>
<section class="slide" data-title="Example: LayoutManager in Swing"><div class="section-body"><h1>Concrete Example: LayoutManager in Swing</h1>
<p><img src="Images/DP-Strategy-LayoutManager.png" alt="DP StrategyLayoutManager" /></p>
<pre><code class="Java">class Container extends Component{
  LayoutManager layoutMgr;
  … 
  public LayoutManager getLayout() {
    return layoutMgr;
  }
  
  public void layout() {
    layoutMgr.layoutContainer(this);
  }
  … 
}  
</code></pre>
</div></section>
<p>For illustration, consider Java Containers with dynamically customizable strategies for laying out its components.</p>
<p>To keep the design open for future extensions, we „outsource“ the variable layout functionality to a strategy object of type <code>LayoutManager</code>. </p>
<p>Container objects hold a reference <code>layoutMgr</code> to a Container object and implement operations for managing this reference. </p>
<p>All operations, whose implementations depend on layout functionality, call specific methods in the interface of <code>LayoutManager</code>.</p>
<section class="slide" data-title="Functional Counterpart of Strategies"><div class="section-body"><h1>Functional Counterpart of Strategies</h1>
<p>One can look at the Strategy pattern as a style for emulating first-class functions available in functional programming languages.</p>
<aside data-title="First-class Functions"><div class="aside-body"><p>First-class functions are values that can be passed as parameters and returned as results.</p>
</div></aside>
<p><strong>Strategy objects</strong> encapsulate sub-computations in first-class values that can be passed as parameters and returned as results of other computations (methods).</p>
</div></section>
<h3>The Cost of the Strategy Pattern</h3>
<p>There are trade-offs to be made to profit from the advantages of the Strategy pattern.</p>
<p>These trade-offs must be known and carefully considered when using the Strategy. </p>
<section class="slide" data-title="Footprint of Variations in Base Functionality"><div class="section-body"><h1>Footprint of Variations in Base Functionality</h1>
<pre><code class="Java">class Container extends Component{
  LayoutManager layoutMgr;
  … 
  public LayoutManager getLayout() {
    return layoutMgr;
  }
  
  public void layout() {
    layoutMgr.layoutContainer(this);
  }
  … 
}  
</code></pre>
<ul>
<li>The field <code>layoutMgr</code></li>
<li>Methods to manage strategy objects; e.g., <code>setLayout</code></li>
<li>Facade methods forwarding functionality to strategy, e.g., <code>layout</code></li>
</ul>
</div></section>
<p>There may be clients which are not interested in layout functionality. Hence, this can be considered as a violation of the Single-Responsibility Principle and the Interface-Segregation Principle.</p>
<section class="slide" data-title=" Structural Variation is not Supported"><div class="section-body"><h1>Structural Variation is not Supported</h1>
<ul>
<li><p>The Strategy interface must <strong>fit the needs of all possible variations</strong> of the outsourced feature.</p>
</li>
<li><p>This may lead to bloated („One Size Fits All“) interfaces. <br />
The interfaces might be too complicated for some clients not interested in sophisticated variations of a feature.</p>
</li>
<li><p>Careful anticipation of the needs of future variations is needed when designing the interface. </p>
</li>
<li>Aggravates extensibility.</li>
</ul>
</div></section>
<section class="slide" data-title="An Example „One Size Fits All“-Interface"><div class="section-body"><h1>An Example „One Size Fits All“-Interface</h1>
<pre><code class="Java">interface ListSelectionModel { 
  int SINGLE_SELECTION = 0; 
  int SINGLE_INTERVAL_SELECTION = 1; 
  int MULTIPLE_INTERVAL_SELECTION = 2; 

  /** … 
   * In {@code SINGLE_SELECTION} selection mode, 
   * this is equivalent to calling {@code setSelectionInterval}, 
   * and only the second index is used. 
   * In {@code SINGLE_INTERVAL_SELECTION} selection mode, 
   * this method behaves like {@code setSelectionInterval}, 
   * unless the given interval is immediately 
   * adjacent to or overlaps the existing selection, 
   * and can therefore be used to grow the selection. 
   * … 
   */ 
   void addSelectionInterval(int index0, int index1); 
   … 
} 
</code></pre>
</div></section>
<p>Consider the list selection feature in Java’s Swing library. This feature is outsourced to the class <code>ListSelectionModel</code>. The interface of <code>ListSelectionModel</code> is designed to satisfy the needs of the most flexible selection model (multiple interval selection). As a result, the interface is too complicated for clients of simpler selection models. See the comments of the methods in the interface. </p>
<p>Yet, the design is not flexible enough, e.g., to cover the needs of extensions of the selection model with arbitrary cell range selection.</p>
<section class="slide" data-title="When the „One Size Fits All“-Interface doesn&apos;t fit!"><div class="section-body"><h1>When the „One Size Fits All“-Interface Doesn&apos;t fit!</h1>
<h2>Example from Java Swing&apos;s <code>JComponent</code></h2>
<p>  <img src="Images/DP-Strategy-LayoutManagerRefinement.png"></p>
<pre><code class="Java">// javax.swing.JComponent - OpenJDK / 6-b14
1804  public float getAlignmentY() {
1805    float yAlign;
1806    if (layoutMgr instanceof LayoutManager2) {
1807      synchronized (getTreeLock()) {
1808        LayoutManager2 lm = (LayoutManager2) layoutMgr;
1809        yAlign = lm.getLayoutAlignmentY(this);
1810      }
1811    } else {
1812      yAlign = super.getAlignmentY();
1813    }
1814    return yAlign;
1815  }
</code></pre>
</div></section>
<p>At some point, the designers of the <code>LayoutManager</code> were forced to evolve the interface to satisfy new/additional requirements posed by tool builders. This required a new interface that inherits from the original interface. Eventually, type checks and typecasts become necessary and significantly hamper code comprehension, maintainability, testability, and extensibility.</p>
<section class="slide" data-title="Communication Overhead"><div class="section-body"><h1>Communication Overhead</h1>
<ul>
<li><p>Some concrete strategies won&apos;t use all information passed to them.</p>
<ul>
<li>Simple concrete strategies may use none of it.</li>
<li>Context creates/initializes parameters that never get used.</li>
</ul>
</li>
<li><p>If this is an issue, consider using a tighter coupling between Strategy and Context. Let Strategy know about Context.<br />
<strong>Two Ways of Strategy-Context Interaction:</strong></p>
<ol>
<li><p>Pass the needed information as a parameter.</p>
<ul>
<li>Context and Strategy decoupled.</li>
<li>Interaction overhead.</li>
<li>Algorithm can’t be adapted to specific needs of context.</li>
</ul>
</li>
<li><p>Context passes itself as a parameter or Strategy has a reference to its Context.</p>
<ul>
<li>Reduced interaction overhead.</li>
<li>Context must define a more elaborate interface to its data.</li>
<li>Closer coupling of Strategy and Context.</li>
</ul>
</li>
</ol>
</li>
</ul>
</div></section>
<section class="slide" data-title="Variations with Fixed Interface"><div class="section-body"><h1>Variations with Fixed Interface</h1>
<div class="statement">Strategy objects are effective in modeling features of an object with dynamically varying implementations but fixed interfaces.</div>
</div></section>
<section class="slide" data-title="Increased Number of Objects"><div class="section-body"><h1>Increased Number of Objects</h1>
<p>Potentially many strategy objects need to be instantiated.</p>
<hr />
<p>To alleviate this problem you may use <strong>Stateless Strategies</strong> (<em>Services</em>):</p>
<ul>
<li>The number of strategy objects can sometimes be reduced by stateless strategies that several Contexts can share.</li>
<li>Any state is maintained by Context.</li>
<li>Context passes it in each request to the Strategy object.<br />
(No / less coupling between Strategy implementations and Context.)</li>
<li>Shared strategies should not maintain state across invocations.</li>
<li>They are Services.</li>
</ul>
</div></section>
<section class="slide" data-title="Composition of Multiple Variations"><div class="section-body"><h1>Composition of Multiple Variations</h1>
<div class="statement">Strategy objects cannot be effectively used to model interdependent variations. </div>
<p><strong>Illustrative example</strong>:</p>
<section class="story"><div class="section-body"><p>The <code>JTable</code> class in Java’s Swing library uses the interface <code>TableCellRenderer</code> to abstract from different ways in which table cells can be rendered.</p>
<p>But, cell rendering may depend on other kinds of variations of table functionality, e.g., on the presence of selection or drag-and-drop functionality. </p>
<p>Selected cells and drag-and-drop targets must be rendered in a special way. </p>
</div></section>
<p>Such interdependencies between different variation dimensions cannot be properly modularized using strategy objects only. </p>
</div></section>
<h3>Takeaway</h3>
<section class="slide" data-title="Takeaway"><div class="section-body"><h1>Takeaway</h1>
<p>The core of the Strategy Pattern is to model variability of object features by 
outsourcing the implementation of these features in “helper” (strategy) objects
Exploiting “implementation to interfaces” and subtype polymorphism for abstracting over variations of the outsourced feature. </p>
<p>The Strategy pattern addresses two problems of inheritance:</p>
<ul>
<li>Variations become reusable. </li>
<li>Dynamic variations of features becomes possible.</li>
</ul>
</div></section>
<p>Technically, a combination of object composition and inheritance is used instead of inheritance only.</p>
<p><strong>The Strategy pattern has its costs</strong>:</p>
<ul>
<li>Variations leave a footprint in the base implementation of the object.</li>
<li>Structural variations are not supported.</li>
<li>Careful planning of a one-size-fits-all interface is needed.</li>
<li>Bloated interfaces and interaction overhead between strategy objects and their usage contexts.</li>
<li>Increased number of objects.</li>
<li>Multiple interdependent variations not properly supported. </li>
</ul>
<h2>Filing the Design Space between Template and Strategy</h2>
<section class="slide" data-title="Filing the Design Space between Template and Strategy"><div class="section-body"><p><strong>Using mixin-composition and self-type annotations widens the design space.</strong></p>
<pre><code class="Scala">trait Component

trait LayoutEngine {
    def layout(components: Array[Component])
}

trait BasicLayoutEngine extends LayoutEngine {
    def layout(components: Array[Component]) { /*Basic means nothing..*/ }
}

class Container(private val components: Array[Component]) { 
  this: LayoutEngine ⇒ // &lt;= Self-type annotation
  def doLayout() {
    layout(components);
  }
}

object LayoutEngineDemo extends App {
    val c : Container = new Container(Array()) with BasicLayoutEngine
    //c.layout (won&apos;t compile!)
    c.doLayout 
    println(c)
}
</code></pre>
</div></section>
<p>Using this approach the solution is type-safe and variations are (still) reusable. However, dynamic variations of features are no longer possible. </p>
<p>Overall, we have the following advantages:</p>
<ul>
<li>LayoutEngine (low-level mechanism) is well modularized and reusable</li>
<li>Basically no overhead, because we do not have an additional object (as in case of Template Method)</li>
<li>The interface of <code>Container</code> is not polluted (conforms to the ISP)</li>
</ul>
<p>and the following disadvantage:</p>
<ul>
<li><p>&quot;strategy&quot; is not dynamically exchangeable</p>
</li>
</ul>
<h2>Decorator Design Pattern</h2>
<h3>Intent of the Decorator Pattern</h3>
<section class="slide" data-title="Intent of the Decorator Pattern"><div class="section-body"><h1>Intent of the Decorator Pattern</h1>
<p>We need to <strong>add functionality to existing objects</strong></p>
<ul>
<li><strong>dynamically</strong>, i.e., during runtime after the object is created,</li>
<li><strong>without having to implement conditional logic</strong> to use the new functionality.</li>
</ul>
</div></section>
<p>The usual way to add new functionality to an existing design is by means of inheritance. But, as we have already discussed, dynamic extensions are not supported, the extensions are non-reusable, and multiple extensions are hard to combine.</p>
<p>These problems are targeted by Decorator. Decorator is also suggested to solve the fragile base-class problem. </p>
<p>Decorator can be an alternative to Strategy with different trade-offs.</p>
<h3>The Decorator Pattern in a Nutshell</h3>
<section class="slide" data-title="The Structure of a Decorator-Based Design"><div class="section-body"><h1>The Structure of a Decorator-Based Design</h1>
<p><img src="Images/DP-Decorator-Structure.png" alt="DP Decorator Structure" /></p>
</div></section>
<ul>
<li><p><code>ConcreteComponent</code> is a representative for all classes whose objects should be dynamically extensible with new functionality.</p>
</li>
<li><p><code>Component</code> can be: </p>
<ul>
<li>an interface that declares all operations of <code>ConcreteComponent</code> objects whose functionality we want to extend dynamically (here represented by operation),</li>
<li>a common (abstract) superclass of all <code>ConcreteComponent</code> classes, which implements common functionality.</li>
</ul>
</li>
<li><p>Any <code>Decorator</code> is also a <code>Component</code>: </p>
<ul>
<li>Maintains a field <code>comp</code> of type <code>Component</code></li>
<li>Implements the operations declared in <code>Component</code></li>
<li>Default implementation forwards the same operation to <code>comp</code>.<br /></li>
<li>Special decorators perform some additional functionality  before or after forwarding to <code>comp</code>.</li>
</ul>
</li>
</ul>
<section class="slide" data-title="The Decorator Pattern by Example"><div class="section-body"><h1>The Decorator Pattern by Example</h1>
<p><img src="Images/DP-Decorator-java.io.png" alt="DP Decorator Java.Io" /></p>
<p><strong>Example Code</strong></p>
<pre><code class="Java">DataInputStream dis = new DataInputStream(new FileInputStream(file));

dis.readUnsignedByte();
</code></pre>
</div></section>
<p><code>java.io</code> abstracts various data sources and destinations.</p>
<p>It uses Decorator to modularize various processing algorithms that operate on raw data.</p>
<h3>Advantages of Decorator-Based Designs</h3>
<section class="slide" data-title="Each Variation Defined Once: No Code Duplication"><div class="section-body"><h1>Each Variation Defined Once</h1>
<h2>No Code Duplication</h2>
<div style="background-color:#fcc">
  Using inheritance only:
  <img src="Images/DP-Decorator-IOWithInheritanceOnly.png" style="width:750px;float:right"> 
</div>
<p>  <div style="clear:both"></div></p>
<hr />
<p>  <img src="Images/DP-Decorator-java.io.png" style="width:750px;float:right">
  Using the Decorator Pattern:</p>
</div></section>
<p>Decorator-based designs share the desired properties of corresponding designs based on inheritance only that <strong>variations are well modularized</strong>. We define one class per variation of base and decorative functionality.</p>
<p>Unlike inheritance-based designs, decorator-based designs yield <strong>variations that are reusable</strong> with any class in the Component hierarchy. Furthermore, <strong>variations are applied dynamically</strong>.</p>
<section class="slide" data-title="Improved Flexibility"><div class="section-body"><h1>Improved Flexibility</h1>
<ul>
<li><p>Decorative functionality can be added / removed at run-time.</p>
</li>
<li><p>Combining different decorator classes for a component class enables to mix and match responsibilities as needed.</p>
</li>
</ul>
<pre><code class="Java">…
is = new FileInputStream(file);
is.read(…);
…
DataInputStream dis = new DataInputStream(is);
dis.readUnsignedByte();
… 
(new BufferedInputStream(dis)).readLine(…);
</code></pre>
<ul>
<li><p>Easy to add functionality twice.<br />
E.g., given a class <code>BorderDecorator</code> for a <code>TextField</code>, to add a double border, attach two instances of <code>BorderDecorator</code>.</p>
</li>
</ul>
</div></section>
<section class="slide" data-title="Decorator Avoids Incoherent Classes"><div class="section-body"><h1>Decorator Avoids Incoherent Classes</h1>
<p>No need for feature-bloated classes positioned high up in the inheritance hierarchy to avoid code duplication.</p>
<p>Pay-as-you-go approach: Do not bloat, but extend using fine-grained Decorator classes.</p>
<ul>
<li>Functionality can be composed from simple pieces.</li>
<li>A client does not need to pay for features it does not use.</li>
</ul>
</div></section>
<section class="slide" data-title="Advantages of Decorator-Based Designs"><div class="section-body"><h1>Advantages of Decorator-Based Designs</h1>
<div class="statement">A fine-grained Decorator hierarchy is easy to extend.  </div>
<hr />
<div class="statement">Decorator helps to design software that better supports OCP.</div>
</div></section>
<h3>Problems of Decorator-Based Designs</h3>
<section class="slide" data-title="Problems of Decorator-Based Designs"><div class="section-body"><h1>Problems of Decorator-Based Designs</h1>
<p><strong>Lots of Little Objects</strong></p>
<hr />
<p><strong>A decorator and its component are not identical (Object identity)</strong></p>
<pre><code class="Java">FileInputStream fin = new FileInputStream(“a.txt”);
BufferedInputStream din = new BufferedInputStream(fin);
…
fin.read(); // NO BUFFERING
</code></pre>
<hr />
<p><strong>No Late Binding</strong></p>
<aside data-title="Forwarding vs. Delegation"><div class="aside-body"><div style="float:left;width:45%">
  <h1>Forwarding</h1>
  <img src="Images/DP-DecoratorForwarding.png" style="display:block;margin:auto">
  Forwarding with binding of this to method holder; "ask" an object to do something on its own.
  </div>
  <div style="float:right;width:45%">
  <h1>Delegation</h1>
  <img src="Images/DP-DecoratorDelegation.png" style="display:block;margin:auto">
  Binding of this to message receiver: “ask” an object to do something on behalf of the message receiver.
</div>	  
</div></aside>
</div></section>
<ul>
<li><p>Lots of little objects:</p>
<ul>
<li>A design that uses Decorator often results in systems composed of lots of little objects that all look alike. Objects differ only in the way they are interconnected, not in their interface or in the value of their variables. </li>
<li>Such systems are easy to customize by those who understand them, but can be hard to learn and debug. The responsibility for combining features is put on the shoulders of a library user.</li>
</ul>
</li>
<li><p>Object identity (A decorator and its component are not identical!):</p>
<ul>
<li>From an object identity point of view, a decorated component is not identical to the component itself.</li>
<li>You should not rely on object identity when you use decorators.</li>
<li>Easy to &quot;forget&quot; the &quot;decorative&quot; functionality.</li>
</ul>
</li>
<li><p>No late binding:</p>
<ul>
<li>A decorator and its component interact via forward semantics. </li>
<li>Forward semantics does not ensure late binding as we know from inheritance.</li>
<li>Delegation semantics is not available in mainstream class-based OO languages.</li>
</ul>
</li>
</ul>
<section class="slide" data-title="No Late Binding Illustrated"><div class="section-body"><h1>No Late Binding Illustrated</h1>
<p>  <img src="Images/DP-Decorator-AccountExampleExcerpt.png" style="float:left"></p>
<p><strong>Task</strong>:</p>
<p><em>Extend the design to enable online access to accounts.</em></p>
<p>Decorator seems to be the right choice!</p>
<p>Among other things, we decorate the description of accounts with the label “online”.</p>
<p>The way the history is calculated does not need to be decorated, hence, the decorator just forwards. </p>
</div></section>
<p>The diagram shows a simplified extract of the design of a banking application:</p>
<ul>
<li><p>There are two kinds of accounts: </p>
<ul>
<li>Checking accounts for day-to-day bank transactions.</li>
<li>Saving accounts for depositing money with a fixed interest rate.</li>
</ul>
</li>
<li>Accounts know how to return a string that describes them.</li>
<li>Accounts declare a method for printing a history of recently performed transactions.</li>
</ul>
<section class="slide"><div class="section-body"><h1>No Late Binding Illustrated</h1>
<p><img src="Images/DP-Decorator-AccountExample.png" alt="DP Decorator AccountExample" /></p>
<footer><div class="footer-body"><p>Do you see where we hit the &quot;no-late binding&quot; problem?</p>
</div></footer>
</div></section>
<section class="slide"><div class="section-body"><h1>No Late Binding Illustrated</h1>
<p>Consider the following client code:</p>
<p>  <img src="Images/DP-Decorator-AccountExample.png" style="float:right;width:60%"></p>
<pre><code class="Java">…
Account checkingAcc = 
  new CheckingAccount(…);

…
Account onlineAcc = 
  new OnlineAccount(
    checkingAccount);

…
onlineAcc.printHistory();
…
</code></pre>
<footer><div class="footer-body"><p>Does the call to <code>printHistory</code> on <code>onlineAcc</code> behave as expected?</p>
</div></footer>
</div></section>
<p><strong>Answer</strong>: OnlineDecorator decorates getType(). Yet, since CheckingAccount.printHistory() calls getType() via this, the execution escapes the decoration of getType().</p>
<blockquote><p>Call to onlineDec.printHistory().</p>
<p>a) Call to checkingAcc.printHistory() as the result of the forwarding by the call to account.printHistory() in the implementation of OnlineDecorator.printHistory().</p>
<p>b) Execution of CheckingAccount.printHistory(). Call to getType() inherited from Account, not OnlineAccount!</p>
</blockquote>
<h3>Implementation Issues</h3>
<section class="slide" data-title="Implementation Issues"><div class="section-body"><h1>Implementation Issues</h1>
<section class="highlight"><div class="section-body"><h2>Keep the common class (Component) lightweight!</h2>
<hr />
<h2>A decorator&apos;s interface must conform to the interface of the component it decorates.</h2>
<hr />
<p>There is no need to define an abstract Decorator class when you only need to add one responsibility.</p>
</div></section>
</div></section>
<p>The common class should focus on defining an interface. Defer defining data representation to subclasses. Otherwise, the complexity of Component might make the decorators too heavyweight to use in quantity.
Putting a lot of functionality into Component makes it likely that subclasses will pay for features they do not need.
These issues require pre-planning. Difficult to apply the decorator pattern to 3rd-party component class.</p>
<p>It is often the case that you do not need to define an abstract Decorator class when you&apos;re dealing with an existing class hierarchy rather than designing a new one. In this case, you can merge Decorator&apos;s responsibility for forwarding requests to the component into the concrete Decorator.</p>
<h3>Decorator and the Fragile Base-Class Problem</h3>
<section class="slide" data-title="Decorator and the Fragile Base-Class Problem"><div class="section-body"><h1>Decorator and the Fragile Base-Class Problem</h1>
<p>The Decorator pattern is suggested in several books (e.g., <em>Effective Java</em> by Joshua Bloch) as a solution to the fragile base-class problem.</p>
<div class="statement">Does the use of the Decorator Pattern solve the fragile base-class problem?</div>
</div></section>
<section class="slide"><div class="section-body"><h1>The <code>InstrumentedHashSet</code> again…</h1>
<pre><code class="Java">public class InstrumentedHashSet&lt;E&gt; extends java.util.HashSet&lt;E&gt; {
  private int addCount = 0;    
  …
  @Override public boolean add(E e) {        
    addCount++;
    return super.add(e);
  }    
  @Override public boolean addAll(java.util.Collection&lt;? extends E&gt; c) {
    addCount += c.size();
    return super.addAll(c);
  }
  public int getAddCount() {
    return addCount;
  }
}
…
public static void main(String[] args) {
  InstrumentedHashSet&lt;String&gt; s = new InstrumentedHashSet&lt;String&gt;();
  s.addAll(Arrays.asList(&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;));
  System.out.println(s.getAddCount());
}
</code></pre>
<footer><div class="footer-body"><p>Ask yourself (again): What is printed on the screen?</p>
</div></footer>
</div></section>
<section class="slide" data-title="A Decorator-Based `InstrumentedSet`"><div class="section-body"><h1>A Decorator-Based <code>InstrumentedSet</code></h1>
<ol>
<li>Declare an interface <code>Set&lt;E&gt;</code></li>
<li>Let <code>HashSet&lt;E&gt;</code> implement <code>Set&lt;E&gt;</code></li>
<li>Define <code>ForwardingSet&lt;E&gt;</code> as an implementation of <code>Set&lt;E&gt;</code></li>
<li><p><code>ForwardingSet&lt;E&gt;</code> (our root Decorator)</p>
<ul>
<li>Has a field <code>s</code> of type <code>Set&lt;E&gt;</code></li>
<li>Implements methods in <code>Set&lt;E&gt;</code> by forwarding them to <code>s</code></li>
</ul>
</li>
<li><code>InstrumentedSet&lt;E&gt;</code> (a concrete Decorator) extends <code>ForwardingSet&lt;E&gt;</code> and overrides methods <code>add</code> and <code>addAll</code></li>
</ol>
<aside data-title="Recipe For Using Decorator"><div class="aside-body"><p>Instead of inheriting from a class <code>C</code> to define <code>EC</code>:</p>
<ul>
<li>Declare the interface of <code>C</code>, <code>IC</code></li>
<li>Let <code>C</code> implement <code>IC</code></li>
<li><p>If more than one decoration is planned:</p>
<ul>
<li>Let a class <code>ForwardingC</code> implement <code>IC</code>.</li>
<li><code>ForwardingC</code> has a field <code>ic</code> that holds an object of type <code>IC</code>.</li>
<li><code>ForwardingC</code> implements methods in <code>IC</code> by forwarding to <code>ic</code>. </li>
<li>Let <code>EC</code> extend <code>ForwardingC</code> and override methods in <code>IC</code> affected by the extension.</li>
</ul>
</li>
<li><p>Otherwise:</p>
<ul>
<li>Let <code>EC</code> implement <code>IC</code>.</li>
<li><code>EC</code> has a field ic that holds an object of type <code>IC</code>.</li>
<li><code>EC</code> implements methods in IC affected by the extension and forwards the rest to <code>ic</code>. </li>
</ul>
</li>
</ul>
</div></aside>
</div></section>
<section class="slide" data-title="A `ForwardingSet&lt;E&gt;`"><div class="section-body"><h1>A <code>ForwardingSet&lt;E&gt;</code></h1>
<pre><code class="Java">import java.util.*;
public class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; {
  private final Set&lt;E&gt; s;

  public ForwardingSet(Set&lt;E&gt; s) { this.s = s; }
  public void clear() { s.clear();}
  public boolean contains(Object o) { return s.contains(o); }
  public boolean isEmpty(){ return s.isEmpty();}
  public int size(){ return s.size();}
  public Iterator&lt;E&gt; iterator(){ return s.iterator();}
  public boolean add(E e){ return s.add(e);}
  public boolean remove(Object o) { return s.remove(o);}
  public boolean containsAll(Collection&lt;?&gt; c) { ... }
  public boolean addAll(Collection&lt;? extends E&gt; c) { ... }
  public boolean removeAll(Collection&lt;?&gt; c) {...}
  …
}
</code></pre>
</div></section>
<section class="slide" data-title="An Alternative `InstrumentedSet`"><div class="section-body"><h1>An Alternative <code>InstrumentedSet</code></h1>
<pre><code class="Java">import java.util.*;
public class InstrumentedSet&lt;E&gt; extends ForwardingSet&lt;E&gt; {
  private int addCount = 0;
  public InstrumentedSet(Set&lt;E&gt; s) { super(s); }
  @Override public boolean add(E e) {
    addCount++;
    return super.add(e);
  }
  @Override public boolean addAll(Collection&lt;? extends E&gt; c){
    addCount += c.size();
    return super.addAll(c);
  }
  public int getAddCount() { return addCount; }
}
public static void main(String[] args) {
  InstrumentedSet&lt;String&gt; s =
    new InstrumentedSet&lt;String&gt;(new HashSet&lt;String&gt;());
  s.addAll(Arrays.asList(&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;));
  System.out.println(s.getAddCount());
}
</code></pre>
<footer><div class="footer-body"><p>What is printed on the screen?</p>
</div></footer>
</div></section>
<p>In this case, the value <code>3</code> is printed on the screen. The internal call to add in the implementation of <code>addAll</code> in <code>HashSet</code> does not come back to the decorater <code>s</code>; hence, it does not increase the counter.</p>
<p><strong>Bloch&apos;s Conclusion</strong>:
The Decorator-based solution is better.<br />
There are only few disadvantages:</p>
<ul>
<li>No late binding.</li>
<li>Tedious to write forwarding methods, „but you do it only once“.</li>
<li>Efficiency impact of forwarding and memory footprint, but „<em>neither turns out to have much impact in practice</em>“</li>
</ul>
<section class="slide" data-title="Decorator and the Fragile Base Class"><div class="section-body"><h1>Decorator and the Fragile Base Class</h1>
<div class="statement">Does the decorator-based design really solve the fragile base-class problem?</div>
</div></section>
<p><strong>Ask yourself</strong>:</p>
<p>What happens if I add a new method to the interface?<br />
Doesn‘t the same problems reappear as with inheritance?</p>
<ul>
<li>Adding a method to the interface may escape the decoration (e.g., imagine a method <code>add(Collection,Filter)</code> is added to <code>Set&lt;E&gt;</code> and to <code>ForwardingSet&lt;E&gt;</code>; after that all compile-time requirements are satisfied, but <code>InstrumentedSet&lt;E&gt;</code> does not override the method and, hence, does not update the counter correctly.)</li>
<li>&quot;Some logic&quot; needs to be reimplemented. E.g., imagine that a method is added to set a filter (<code>setFilter(Filter)</code>) and after that always only those elements are added to the set that pass the filter. Such a change would require to duplicate the logic in our decorator.</li>
<li>Adding a method to the interface may conflict (signature) with the methods defined by the concrete decorator.</li>
</ul>
<h3>Decorator and Strategy</h3>
<section class="slide" data-title="Decorator and Strategy"><div class="section-body"><h1>Decorator and Strategy</h1>
<p>Decorator and Strategy share the goal of <strong>supporting dynamic behavior adaptation</strong>. </p>
<p><img src="Images/DP-DecoratorVsStrategy.png" alt="DP DecoratorVsStrategy" /></p>
</div></section>
<p>Decorator and Strategy can be used to simulate the effect of each other.</p>
<section class="slide" data-title="Simulate the Effect of Each Other"><div class="section-body"><h1>Simulate the Effect of Each Other</h1>
<p>By extending the number of strategies from just one to an open-ended list, we achieve principally the same effect as nesting decorators.</p>
<p><img src="Images/DP-DecoratorStrategySimulationStrategy.png" alt="DP DecoratorStrategySimulationStrategy" /></p>
</div></section>
<p><strong>Example</strong>: </p>
<ul>
<li>We can use Strategy to simulate data processing decoration of streams.</li>
<li>Different processing steps can be supported by having the component forward data-processing functionality to a <code>DataProcessing</code> object, which in turn may encapsulate another <code>DataProcessing</code> object. (<code>DataProcessing</code> objects encapsulate data-processing strategies.)</li>
</ul>
<section class="slide" data-title="Transparent vs. Non-Transparent Change"><div class="section-body"><h1>Transparent vs. Non-Transparent Change</h1>
<p><strong>Decorator changes a component from the outside</strong>:<br />
The component does not know about its decorators.
<img src="Images/DP-DecoratorStrategySimulationDecorator.png" alt="DP DecoratorStrategySimulationDecorator" /></p>
<hr />
<p><strong>Strategy changes a component from the inside</strong>:<br />
Component knows about Strategy-based extensions.
<img src="Images/DP-DecoratorStrategySimulationStrategy.png" alt="DP DecoratorStrategySimulationStrategy" /></p>
</div></section>
<h4>Changing the Skin versus Changing the Guts</h4>
<p>Decorator can be viewed as a skin over an object that changes its behavior.</p>
<p>Strategy can be viewed as guts inside an object that changes its behavior.</p>
<h4>Preferring Decorator over Strategy</h4>
<p><strong>The Decorator has two principal advantages over Strategy:</strong></p>
<ol>
<li><strong>Improved modularity</strong>: The Decorator “infrastructure” does not leave any footprint in the implementation of the decorated object.</li>
<li><strong>Extensible interface</strong>: Decorators can extend the interface of the decorated component “on-demand”; No need to plan an “one-size-fits-all” interface. <br /></li>
</ol>
<p>Consequently, the decorator is better when:</p>
<ul>
<li>We cannot foresee variations. </li>
<li>It is hard to design an interface that fits all needs of the variations.</li>
</ul>
<h4>Preferring Strategy over Decorator</h4>
<p><strong>The Strategy pattern is better when the varying object type is intrinsically heavyweight.</strong></p>
<p>The Decorator pattern is too costly to apply in this case. A Decorator&apos;s interface must conform to Component&apos;s interface.</p>
<p>A Strategy can have its own specialized interface. E.g., a strategy for rendering a border need only define the interface for rendering a border (<code>drawBorder()</code>, <code>getWidth()</code>, …).</p>
<p>Furthermore, a Strategy class can be lightweight even if the Component class is heavyweight.</p>
<h4>Summary</h4>
<section class="slide" data-title="Takeaway Decorator vs. Strategy"><div class="section-body"><h1>Takeaway Decorator vs. Strategy</h1>
<p>Like the Strategy, the Decorator pattern also uses a combination of object composition and inheritance/subtype polymorphism to support dynamic and reusable variations.</p>
<p>Unlike the Strategy, it adapts object behavior from the outside rather than inside.
Unlike Strategy, variations encapsulated in decorator objects do not leave any footprint in the behavior of the objects being adapted.</p>
<p>In that sense, it has a stronger “inheritance” resemblance than Strategy. </p>
</div></section>
<h3>Takeaway</h3>
<section class="slide" data-title="Takeaway"><div class="section-body"><h1>Takeaway</h1>
<p>Decorator has its own trade-offs.</p>
<p>Decorator may lead to error-prone and hard to understand designs.</p>
<ul>
<li>Many little objects emulate the behavior of a conceptually single object.</li>
<li>No object identity.</li>
<li>No late-binding.</li>
<li><p>Not appropriate for modeling the variability of heavy-weight objects with a lot of functionality. </p>
</li>
<li>Might not be applicable to third-party library objects.</li>
<li><p>It does not really solve the fragile base-class problem.</p>
</li>
</ul>
</div></section>
<h3>Delegation and Mixin-Composition</h3>
<section class="slide" data-title="A &quot;Static&quot; Decorator"><div class="section-body"><h1>A &quot;Static&quot; Decorator</h1>
<p>Using mixins we can statically decorate classes (class composition vs. object composition) and also get delegation semantics. </p>
<pre><code class="Scala">trait Component {
  def state : String
  def name: String
}
case class AComponent (val id : String) extends Component {
    def state = name+&quot;:&quot;+id
    def name = &quot;A&quot;
}
trait ComponentDecoratorA extends Component {
    abstract override def name = &quot;ByADecorated:&quot;+super.name
}
trait ComponentDecoratorB extends Component {
    abstract override def name = &quot;ByBDecorated:&quot;+super.name
}

object DemoStructuralDecorator extends App {
  val c = new AComponent(&quot;42&quot;)   // static decoration
              with ComponentDecoratorA with ComponentDecoratorB 
  println(c.state)
}
</code></pre>
<footer><div class="footer-body"><p>Output: <code>ByBDecorated:ByADecorated:A:42</code></p>
</div></footer>
</div></section>
<p><strong>Assessment</strong>:</p>
<ul>
<li>Each Decorator is well modularized</li>
<li>We get delegation semantics.</li>
<li>No overhead (no little objects).</li>
<li>No dynamic decoration.</li>
</ul>
<p><strong>Task</strong>: Apply this example to the <code>Account</code> example.</p>
<p>Ask yourself: Does <strong>Mixin-Composition</strong> solve the fragile base-class problem?</p>
<section class="slide" data-title="Scala Class Linearization"><div class="section-body"><h1>Scala Class Linearization</h1>
<p>Linearization specifies a single linear order for all of the ancestors of a class, including both the regular superclass chain and the parent chains of all of the traits.</p>
<p><strong>Example:</strong></p>
<pre><code class="Scala">abstract class AbsIterator extends AnyRef { ... }
trait RichIterator extends AbsIterator { ... }
class StringIterator extends AbsIterator { ... }
class Iter extends StringIterator with RichIterator { ... }
</code></pre>
<p>The linearization of Class <code>Iter</code>:</p>
<pre><code>{Iter, RichIterator, StringIterator, AbsIterator, ScalaObject, AnyRef, Any}
</code></pre>
</div></section>
<p>In order to allow reuse of compiled classes and to ensure well-defined behavior, the linearization must satisfy a few rules:</p>
<ul>
<li>The linearization of any class must include unmodified the linearization of any class (but not trait) it extends.</li>
<li>The linearization of any class must include all classes and mixin traits in the linearization of any trait it extends, but the mixin traits need not be in the same order as they appear in the linearization of the traits being mixed in.</li>
<li>No class or trait may appear more than once in the linearization.</li>
</ul>
<p>Due to linearization, Scala, does not suffer from the diamond inheritance problem, as compared to other languages that offer &quot;classical&quot; multiple inheritance.</p>
<p>Further Information:</p>
<ul>
<li><p><a href="http://jim-mcbeath.blogspot.de/2009/08/scala-class-linearization.html">Scala Class Linearization</a></p>
</li>
<li><p><a href="http://www.artima.com/scalazine/articles/stackable_trait_pattern.html">Stackable Traits</a></p>
</li>
</ul>
<h2>Proxy Design Pattern</h2>
<h3>Intent</h3>
<section class="slide" data-title="Intent"><div class="section-body"><h1>Intent</h1>
<div class="statement">Provide a surrogate or placeholder for another object to control access to it.</div>
</div></section>
<p>From the client’s point of view, the proxy behaves just like the actual object.</p>
<h3>Typical Variations</h3>
<h4>Virtual Proxies: Placeholders (as in image example).</h4>
<p><strong>Idea</strong> </p>
<p>Create expensive objects only on demand.
Objects associated with a large amount of data in a file or database may only be loaded into memory if the operation on the proxy demands that they are loaded.</p>
<p><strong>Implementation</strong></p>
<p>Some subset of operations may be performed without bothering to load the entire object, e.g., return the extent of an image.</p>
<h4>Smart References: Additional functionality.</h4>
<p><strong>Idea</strong></p>
<p>Replace bare pointer and provide additional actions when accessed.</p>
<p><strong>Examples</strong></p>
<ul>
<li>Locking / unlocking references to objects used from multiple threads</li>
<li>Reference counting, e.g., for resource management (garbage collection, observer activities)</li>
</ul>
<h4>Remote Proxies: Make distribution transparent.</h4>
<p><strong>Idea</strong></p>
<p>Provide a local interface for communicating with objects in a different address space.
Operations on the proxies are delegated to a remote object and return values are passed through the proxy back to the client.</p>
<p><strong>Issues</strong></p>
<p>From the client’s view, the proxy responds just like if the object were local, even though it is actually sending requests over a network.<br />
(Network failures may be impossible to hide… LSP?)</p>
<h4>Protection Proxies: Rights management.</h4>
<p><strong>Idea</strong> </p>
<p>Verify that the caller has permission to perform the operation.</p>
<p><strong>Issues</strong> </p>
<ul>
<li>Different clients may have different access levels for operating on an object</li>
<li>Read-only objects may be protected from unauthorized modifications this way </li>
<li>Exceptions are thrown in such violation cases (LSP?)</li>
</ul>
<h3>Structure</h3>
<section class="slide" data-title="Structure"><div class="section-body"><h1>Structure</h1>
<p><img src="Images/DP-Proxy-Structure.png" alt="DP Proxy Structure" /></p>
</div></section>
<h3>Example</h3>
<section class="slide" data-title="Example"><div class="section-body"><h1>Example</h1>
<p>  <img src="Images/DP-Proxy-Document+Structure.png" style="float:right"></p>
<p>Imagine, you are developing a browser rendering engine. 
In this case you do not want to handle all elements in a straightforward manner.</p>
<p>E.g., you immediately want to start laying out the page even if not all images are already completely loaded. However, this should be completely transparent to the layout engine.</p>
<footer><div class="footer-body"><p>How can I hide the fact that loading the image takes time? <br />
I don&apos;t want to complicate the editor&apos;s implementation. The optimization shouldn&apos;t impact the rendering and formatting code.</p>
</div></footer>
</div></section>
<section class="slide" data-title="Lazy Loading of Images"><div class="section-body"><h1>Lazy Loading of Images</h1>
<p><img src="Images/DP-Proxy-LazyImage-Solution.png" alt="DP Proxy LazyImage Solution" /></p>
<p>We use another object, an image proxy, that acts as a stand-in for the real image.</p>
</div></section>
<p>The Image Proxy</p>
<ul>
<li>implements the same interface as the real object.<br />
Client code is unaware that it doesn&apos;t use the real object.</li>
<li>instantiates the real object when required, e.g., when the editor asks the proxy to display itself by invoking its <code>draw()</code> operation.<br />
Keeps a reference to the image after creating it to forward subsequent requests to the image.</li>
</ul>
<section class="slide" data-title="Lazy Loading of Images - Solution"><div class="section-body"><h1>Lazy Loading of Images - Solution</h1>
<p><img src="Images/DP-Proxy-LazyImage-Code-ClassDiagram.png" alt="DP Proxy LazyImage Code ClassDiagram" /></p>
</div></section>
<h3>Summary</h3>
<section class="slide" data-title="Summary"><div class="section-body"><h1>Summary</h1>
<p>The Proxy Pattern describes how to replace an object with a surrogate object, </p>
<ul>
<li>without making clients aware of that fact, </li>
<li><p>while achieving a benefit of some kind:</p>
<ul>
<li>lazy creation,</li>
<li>resource and/or rights management, or</li>
<li>distribution transparency.</li>
</ul>
</li>
</ul>
</div></section>
<h3>Java&apos;s Dynamic Proxy Class</h3>
<section class="slide" data-title="Java&apos;s Dynamic Proxy Class"><div class="section-body"><h1>Java&apos;s Dynamic Proxy Class</h1>
<blockquote><p>A <strong>dynamic proxy class</strong> is a class that implements a list of interfaces specified at runtime such that a method invocation through one of the interfaces on an instance of the class will be encoded and dispatched to another object through a uniform interface. </p>
<p>A <strong>proxy interface</strong> is such an interface that is implemented by a proxy class.</p>
<p>A <strong>proxy instance</strong> is an instance of a proxy class.</p>
</blockquote>
<p>Proxy classes, as well as instances of them, are created using the static methods of the class <code>java.lang.reflect.Proxy</code>.</p>
</div></section>
<section class="slide" data-title="Java&apos;s Dynamic Proxy Class - Example"><div class="section-body"><h1>Java&apos;s Dynamic Proxy Class - Example</h1>
<pre><code class="Java">public interface Foo { Object bar(Object obj); }
public class FooImpl implements Foo { Object bar(Object obj) { … } }
</code></pre>
<pre><code class="Java">public class DebugProxy implements java.lang.reflect.InvocationHandler {
  private Object obj;

  public static Object newInstance(Object obj) {
    return Proxy.newProxyInstance(
      obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),
      new DebugProxy(obj));
   }

  private DebugProxy(Object obj) { this.obj = obj; }

  public Object invoke(Object proxy, Method m, Object[] args) 
      throws Throwable {
    System.out.println(&quot;before method &quot; + m.getName());
    return m.invoke(obj, args);
  }
}
</code></pre>
<p><strong>Usage</strong>:</p>
<pre><code class="Java">Foo foo = (Foo) DebugProxy.newInstance(new FooImpl());
foo.bar(null);
</code></pre>
</div></section>
<h3>Questions</h3>
<section class="slide" data-title="Questions"><div class="section-body"><h1>Questions</h1>
<ul>
<li><p>What is the &quot;major&quot; difference between the Proxy and the Decorator Pattern?<br />
(Think about the structure <strong>and</strong> the behavior.)</p>
</li>
<li><p>Is the Proxy Design Pattern subject to the &quot;fragile base class&quot; problem? </p>
</li>
<li><p>In Java, we only have forwarding semantics, but could it be desirable to have delegation semantics, when implementing the proxy pattern?</p>
</li>
</ul>
</div></section>
<p>Delegation semantics would be desirable for a protection proxy, where the different methods have different protection levels. Without delegation semantics, we need to know the self-call structure of the RealSubject to make sure that we check for sufficient access rights.</p>
<h2>Visitor Design Pattern</h2>
<h3>Intent</h3>
<section class="slide" data-title="Intent"><div class="section-body"><h1>Intent</h1>
<div class="statement">The Visitor Pattern enables to add new behavior to existing classes in a fixed class hierarchy without changing this hierarchy.</div>
</div></section>
<section class="slide" data-title="Intent of the Visitor in Context"><div class="section-body"><h1>Intent of the Visitor in Context</h1>
<h2>Recall the problems of inheritance with modeling variations at the level of multiple objects (object composites).</h2>
<p><img src="Images/DP-Visitor-ModelingVariations.png" alt="DP Visitor ModelingVariations" /></p>
</div></section>
<p>Problems:</p>
<ul>
<li>Weak support for combining variations at the level of the composite with those at the level of individual elements.</li>
<li>No support for expressing covariant variations.</li>
<li>Instantiation problems.</li>
</ul>
<h3>Solution</h3>
<section class="slide" data-title="Solution Idea"><div class="section-body"><h1>Solution Idea</h1>
<div class="statement">Represent the additional operations to be performed on the elements of an object structure (additional features) as objects (of type Visitor).</div>
</div></section>
<section class="slide" data-title="Structure"><div class="section-body"><h1>Structure</h1>
<p><img src="Images/DP-Visitor-Structure.png" alt="DP Visitor Structure" /></p>
<p>Example Usage:</p>
<pre><code class="Java">Element e = new ConcreteElementA(...);
Visitor v = new ConcreteVisitor1(...);
e.accept(v);
</code></pre>
</div></section>
<p>The <code>Visitor</code> interface declares a <code>visit</code> method per element type in the object structure.<br /></p>
<p>A <code>Visitor</code> interface describes how to “treat” the element types.</p>
<p>Concrete visitor classes implement the interface specifically, i.e., treat elements differently.</p>
<p>A concrete visitor class corresponds to a particular feature to be added to the object structure.</p>
<p>Elements in the object structure provide the method accept(<code>Visitor</code>).</p>
<p>On being asked to <code>accept</code> a visitor passed to it as a parameter, an element asks the visitor to visit it.</p>
<section class="slide" data-title="Structure (Long Version)"><div class="section-body"><h1>Structure (Long Version)</h1>
<p><img src="Images/DP-Visitor-Structure-Complete.png" alt="DP Visitor Structure Complete" /></p>
</div></section>
<h3>Case-Study: Arithmetic Expressions</h3>
<section class="slide" data-title="Case-Study: Arithmetic Expressions"><div class="section-body"><h1>Case-Study: Arithmetic Expressions</h1>
<p><img src="Images/DP-Visitory-Expr-BasicOO.png" alt="DP Visitory Expr(Naive)" /></p>
<footer><div class="footer-body"><p>Which are the potential design issues?</p>
</div></footer>
</div></section>
<p>Requirements:</p>
<ul>
<li><p>A library for (arithmetic) expressions must provide different functionality for:</p>
<ul>
<li>Formatting an expression to a string.</li>
<li>Computing the value of an expression.</li>
<li>Optimizing an expression.</li>
</ul>
</li>
<li><p>The library must be extensible with new functionality:</p>
<ul>
<li>Generate code for different machines,</li>
<li>Various refactorings, e.g., rename variables,</li>
</ul>
</li>
<li><p>The library must be extensible with new kinds of expressions.</p>
</li>
</ul>
<p>Design Issues:</p>
<ul>
<li>Impossible to reuse part of library functionality (product lines).</li>
<li>Changing one feature can destabilize other features (SRP).</li>
<li>New features cannot be incrementally added (OCP).</li>
</ul>
<section class="slide" data-title="Case Study: Arithmetic Expressions - Visitor-Based Design"><div class="section-body"><h1>Visitor-Based Design</h1>
<p><img src="Images/DP-Visitory-Expr-Visitor.png" alt="DP Visitory Expr Visitor" /></p>
<aside data-title="Double Dispatch"><div class="aside-body"><div class="statement">Dispatching an operation based on the dynamic type of two objects is called double dispatch.</div>
<p>Double dispatch is not supported in mainstream OO languages, e.g., Java.</p>
</div></aside>
<aside data-title="Double Dispatch - Alternative View"><div class="aside-body"><p><strong>Double-Dispatch - Another Point of View</strong></p>
<p>Method call in an object-oriented program: <code>receiver.message(param1,param2,...) </code><br />
The function that is called depends on the run-time type of the receiver. 
Double dispatch is a natural extension of this idea, the function that is called is determined from the run-time type of receiver <em>and</em> the run-time type of the first parameter. It is easy to model this behavior (double-dispatch) with a two-dimensional table of pointers to functions:</p>
<ul>
<li>The runtime type of the receiving object is used to determine a row in the table, and </li>
<li>the runtime type of the first parameter is used to determine a column in the table.
<img src="Images/DP-Visitor-DoubleDispatch-Table.png" alt="DP Visitor DoubleDispatch Table" /></li>
</ul>
</div></aside>
</div></section>
<p>The dispatch of the operations defined in the Element hierarchy depends on two parameters:</p>
<ol>
<li>Dynamic type of the receiver Element determines the class that has the needed method look-up table.</li>
<li>Name of the operation being called determines the entry in that table.</li>
</ol>
<p>For operations that are outsourced to visitors, we need to simulate the same dispatch semantics.<br />
We need to select an implementation of an operation based on both</p>
<ol>
<li>the dynamic type of the element on which to apply the operation,</li>
<li>the dynamic type of the visitor object representing the operation.</li>
</ol>
<h3>Reflections on the Visitor Structure</h3>
<section class="slide" data-title="Reflections on the Visitor Structure"><div class="section-body"><h1>Reflections on the Visitor Structure</h1>
<p><strong>Can we move the implementation of accept higher up the Element hierarchy?</strong></p>
<p><img src="Images/DP-Visitor-Structure-Question.png" alt="DP Visitor Structure Question" /></p>
</div></section>
<p>Answer: No. The method that is called by <code>v.visit(this)</code> is determined at compile-time. </p>
<h3>Case-Study: Calculating Shape Intersection</h3>
<section class="slide" data-title="Case-Study: Calculating Shape Intersection"><div class="section-body"><h1>Case-Study: Calculating Shape Intersection</h1>
<p><img src="Images/DP-Visitor-ShapeIntersection-Start-ClassHierarchy.png" alt="DP Visitor ShapeIntersection Start ClassHierarchy" /></p>
<p><strong>Task</strong>:
Implement an intersect operation that calculates whether two given shapes intersect.</p>
</div></section>
<p>  <span style="visibility:hidden"> TODO Enable: &quot;anim-step:1&quot; </span> </p>
<section class="slide"><div class="section-body"><h1>Case-Study: Calculating Shape Intersection</h1>
<p><img src="Images/DP-Visitor-ShapeIntersection-Start-ClassHierarchy.png" alt="DP Visitor ShapeIntersection Start ClassHierarchy" /></p>
<p><strong>Task</strong>:
Implement an intersect operation that calculates whether two given shapes intersect.</p>
<section data-anim-step="1"><div class="section-body"><p><strong>Sketch of the solution</strong>:</p>
<pre><code class="Java">Shape t = new Triangle(…);
Shape r = new Rectangle(…);
if (t.intersect(r)) {…}
</code></pre>
</div></section>
</div></section>
<p>For the proposed solution, the implementation of intersect depends on the dynamic type of both the receiver (<code>t</code>) and parameter (<code>r</code>) shapes. Hence, we need to simulate double dispatch in Java.</p>
<section class="slide"><div class="section-body"><h1>Case-Study: Calculating Shape Intersection</h1>
<h2>Simulating Double Dispatch</h2>
<p><img src="Images/DP-Visitor-ShapeIntersection-Start-withIntersectMethods.png" alt="DP Visitor ShapeIntersection Start WithIntersectMethods" /></p>
<footer><div class="footer-body"><p>Do you see how this design simulates double dispatch?</p>
</div></footer>
</div></section>
<section class="slide"><div class="section-body"><h1>Case-Study: Calculating Shape Intersection</h1>
<h2>Simulating Double Dispatch</h2>
<pre><code class="Java">Shape t = new Triangle(…);
Shape r = new Rectangle(…);
if (t.intersect(r)) {…}
</code></pre>
<p><img src="Images/DP-Visitor-ShapeIntersection-Start-withIntersectMethodsWithDoubleDispatchVisualization.png" alt="DP Visitor ShapeIntersection Start WithIntersectMethodsWithDoubleDispatchVisualization" /></p>
<footer><div class="footer-body"><p>How do you judge this design?</p>
</div></footer>
</div></section>
<p>External call <code>t.intersect(r)</code> is dispatched based on dynamic type of <code>t</code>.</p>
<p>Internal call <code>s.intersect(this)</code> is dispatched based on dynamic type of <code>r</code>.</p>
<p><strong>Assessment</strong>:</p>
<ul>
<li><p>The given design forces every shape class to implement its intersection with every other shape. Adding new shapes means implementing new methods in every other shape.</p>
</li>
<li><p>The double dispatch approach compromises the semantic-hierarchy concept. </p>
</li>
<li><p>This results in an inheritance tree where each derivative is aware of all other derivates.</p>
</li>
</ul>
<section class="slide" data-title="Case-Study: Shape Intersection Using Visitor"><div class="section-body"><h1>Case-Study: Shape Intersection Using Visitor</h1>
<p><img src="Images/DP-Visitor-ShapeIntersection-Visitor.png" alt="DP Visitor ShapeIntersection Visitor" /></p>
</div></section>
<p>The Visitor Pattern can be used to eliminate the cross-reference in each shape derivative to each other shape derivative. The key idea is to move the intersect functionality to visitors and to implement one intersection visitor (e.g., <code>CircleIntersection</code> or <code>RectangleIntersector</code>) per Shape type.</p>
<section class="slide"><div class="section-body"><h1>Case-Study: Shape Intersection Using Visitor</h1>
<pre><code class="Java">Shape c = new Circle(…);
Shape r = new Rectangle(…);
if (c.intersect(r)) {…}
</code></pre>
<p><img src="Images/DP-Visitor-ShapeIntersection-VisitorInteraction.png" alt="DP Visitor ShapeIntersection VisitorInteraction" /></p>
</div></section>
<h3>Assessment of the Visitor Design Pattern</h3>
<section class="slide" data-title="Advantages of the Visitor Design Pattern"><div class="section-body"><h1>Advantages of the Visitor Design Pattern</h1>
<ul>
<li><p><strong>New operations are easy to add</strong> without changing element classes (add a new concrete visitor).<br />
Different concrete elements do not have to implement their part of a particular algorithm.</p>
</li>
<li><p>Related behavior focused in a single concrete visitor.</p>
</li>
<li><p><strong>Visiting across hierarchies</strong>: Visited classes are not forced to share a common base class.</p>
</li>
<li><p><strong>Accumulating state</strong>: Visitors can accumulate state as they visit each element, thus, encapsulating the algorithm and all its data.</p>
</li>
</ul>
</div></section>
<section class="slide" data-title="Issues of the Visitor-Based Design - Adding Elements"><div class="section-body"><h1>Issues of the Visitor-Based Design</h1>
<h2>Adding Elements</h2>
<p>Scenario:
<img src="Images/DP-Visitor-Problem-AddingElements-Start.png" alt="DP Visitor Problem AddingElements Start" /></p>
<footer><div class="footer-body"><p>What happens if we want to add a new element?</p>
</div></footer>
</div></section>
<p>Description:</p>
<ul>
<li>Visitor visits all elements of a document.</li>
<li>ToPDF converts documents to PDF.</li>
<li>Various other concrete visitors may be implemented:<br />
spell checking, grammar checking, text analysis, speaking text service, ...</li>
</ul>
<section class="slide"><div class="section-body"><h1>Issues of the Visitor-Based Design</h1>
<h2>E.g., adding <code>Chart</code> (adding Elements)</h2>
<p><img src="Images/DP-Visitor-Problem-AddingElements-Chart.png" alt="DP Visitor Problem AddingElements Chart" /></p>
</div></section>
<p>Problem: Since Visitor has no method for <code>Chart</code>, it’s objects won’t be processed by any visitor. Our design is not closed against this kind of change.</p>
<section class="slide"><div class="section-body"><h1>Issues of the Visitor-Based Design</h1>
<h2>E.g., adding <code>Chart</code> <strong>and updating Visitor</strong></h2>
<p><img src="Images/DP-Visitor-Problem-AddingElements-ChangingVisitors.png" alt="DP Visitor Problem AddingElements ChangingVisitors" /></p>
<footer><div class="footer-body"><p>What are the issues?</p>
</div></footer>
</div></section>
<p><strong>Issues</strong>:</p>
<ul>
<li>We have to change all visitors for every new element.</li>
<li>Many visitors will have empty methods to comply to the interface.</li>
<li>Sometimes data structures are extended, but it‘s optional to process extensions.<br />
E.g., it doesn’t make sense to spell-check charts, i.e., SpellChecker.visit(Chart) will be empty.</li>
</ul>
<section class="slide"><div class="section-body"><h1>Issues of the Visitor-Based Design</h1>
<h2>E.g., adding <code>Chart</code> <strong>and keeping Visitor unchanged</strong></h2>
<p><img src="Images/DP-Visitor-Problem-AddingElements-VisitorUnchanged.png" alt="DP Visitor Problem AddingElements VisitorUnchanged" /></p>
<footer><div class="footer-body"><p>What are the issues?</p>
</div></footer>
</div></section>
<section class="slide"><div class="section-body"><h1>Issues of the Visitor-Based Design</h1>
<h2>E.g., adding <code>Chart</code> <strong>and keeping Visitor unchanged</strong></h2>
<p><img src="Images/DP-Visitor-Problem-AddingElements-VisitorUnchanged-Conclusion.png" alt="DP Visitor Problem AddingElements VisitorUnchanged Conclusion" /></p>
<footer><div class="footer-body"><p>What are the issues?</p>
</div></footer>
</div></section>
<p>Try to avoid such visitors as these implementations are extremely fragile; they are maintenance nightmares when more elements are added.</p>
<section class="slide" data-title="Issues of the Visitor-Based Design - Partial Visiting"><div class="section-body"><h1>Issues of the Visitor-Based Design</h1>
<h1>Partial Visiting Is Not Supported</h1>
<p>Visitor is like a matrix (cross product of all Visitor and Element classes):</p>
<p><img src="Images/DP-Visitor-Problem-PartialVisiting.png" alt="DP Visitor Problem PartialVisiting" /></p>
</div></section>
<p>Partial visiting is not supported!</p>
<p>To provide a common abstract <code>Visitor</code> interface to <code>Element</code>, <strong>every derivative</strong> of <code>Element</code> need to be addressed by every derivative of <code>Visitor</code>; even if this might not make sense or is not needed.  We have seen this for <code>SpellChecker.visit(Chart)</code></p>
<h4>Takeaway</h4>
<section class="slide" data-title="Takeaway"><div class="section-body"><h1>Takeaway</h1>
<ul>
<li><p>Visitor brings functional-style decomposition to OO designs. </p>
</li>
<li><p>Use Visitor for stable element hierarchies.<br />
Visitor works well in data hierarchies where new elements are never or at least not very often added.</p>
</li>
<li><p>Do not use it, if new elements are a likely change.</p>
</li>
<li><p>Visitor only makes sense if we have to add new operations often! In this case Visitor closes our design against these changes.</p>
</li>
</ul>
</div></section>
<h3>Solving the Expression Problem in Scala</h3>
<p>Recommended reading: <strong>Matthias Zenger and Martin Odersky</strong>, <em>Independently Extensible Solutions to the Expression Problem</em>, FOOL 2005</p>
<h4>Using &quot;Standard&quot; Object-Oriented Features</h4>
<section class="slide" data-title="Solving the Expression Problem in Scala - Plain OO"><div class="section-body"><h1>Solving the Expression Problem in Scala</h1>
<p><strong>The base trait.</strong></p>
<pre><code class="Scala">trait Expressions {

    type expression &lt;: Expression
    trait Expression {
        def eval: Double
    }

    trait Constant extends Expression {
        val v: Double
        def eval = v
    }
}

</code></pre>
<footer><div class="footer-body"><p>Resembles the solution that we have studied as part of the implementation of the SmartHome Scenario.</p>
</div></footer>
</div></section>
<p>To make it possible to extend the <code>Expression</code> trait (i.e., to enable an independently developed extension to contribute functionality to <code>Expression</code>s ) we have to abstract over the concrete type of Expression.</p>
<section class="slide"><div class="section-body"><h1>Solving the Expression Problem in Scala</h1>
<p><strong>Adding a new data-type.</strong></p>
<pre><code class="Scala">trait AddExpressions extends Expressions {
    trait Add extends Expression {
        val l: Expression
        val r: Expression
        def eval = l.eval + r.eval
    }
}

</code></pre>
<footer><div class="footer-body"><p>Resembles the solution that we have studied as part of the implementation of the SmartHome Scenario.</p>
</div></footer>
</div></section>
<section class="slide"><div class="section-body"><h1>Solving the Expression Problem in Scala</h1>
<p><strong>Adding new functionality.</strong></p>
<pre><code class="Scala">trait PrefixNotationForExpressions extends AddExpressions {

  type expression &lt;: Expression
  trait Expression extends super.Expression {
    def prefixNotation: String
  }

  trait Constant extends super.Constant with Expression {
    def prefixNotation = v.toString
  }

  trait Add extends super.Add with Expression {
    def prefixNotation = &quot;+&quot;+l.prefixNotation + r.prefixNotation
  }
}

</code></pre>
<footer><div class="footer-body"><p>Resembles the solution that we have studied as part of the implementation of the SmartHome Scenario.</p>
</div></footer>
</div></section>
<section class="slide"><div class="section-body"><h1>Solving the Expression Problem in Scala</h1>
<p><strong>Bringing everything together.</strong></p>
<pre><code class="Scala">object ExpressionsFramework
    extends PrefixNotationForExpressions
    with PostfixNotationForExpressions {
		
  type expression = Expression
  trait Expression
    extends super[PrefixNotationForExpressions].Expression
    with super[PostfixNotationForExpressions].Expression

  case class Constant(v: Double)
    extends super[PrefixNotationForExpressions].Constant
    with super[PostfixNotationForExpressions].Constant
    with Expression

  case class Add(val l: expression, val r: expression)
    extends super[PrefixNotationForExpressions].Add
    with super[PostfixNotationForExpressions].Add
    with Expression
}
</code></pre>
<footer><div class="footer-body"><p>Resembles the solution that we have studied as part of the implementation of the SmartHome Scenario.</p>
</div></footer>
</div></section>
<p><strong>Assessment</strong>:</p>
<ul>
<li>The solution is open w.r.t. to directly adding new functionality to expressions and w.r.t. adding new data-types that inherit from <code>Expression</code>.</li>
<li>It is easy to add support for new data-types (e.g., <code>Add</code>).</li>
<li>It is possible to add new functionality (in a type-safe way), but this requires a deep-mixin composition.</li>
<li>The solution is subject to the fragile base-class problem.</li>
</ul>
<p>The complete code: <a href="Code/src/visitor/oo/Expressions.scala">OO/Expressions.scala</a></p>
<h4>Using the Visitor-Design Pattern</h4>
<section class="slide" data-title="Solving the Expression Problem in Scala - Visitor Pattern"><div class="section-body"><h1>Solving the Expression Problem in Scala</h1>
<p><strong>The base trait.</strong></p>
<pre><code class="Scala">trait Expressions {
    
  trait Expression { def accept[T](visitor: visitor[T]): T }

  class Constant(val v: Double) extends Expression {
    def accept[T](visitor: visitor[T]): T = visitor.visitConstant(v)
  }

  type visitor[T] &lt;: Visitor[T]
  trait Visitor[T] {
    def visitConstant(v: Double): T
  }

  trait EvalVisitor extends Visitor[Double] {
    def visitConstant(v: Double): Double = v
  }
}
</code></pre>
</div></section>
<p>This solution does not support adding methods/functionality to an expression at runtime or by a third-party extension, i.e., an independently developed extension of the Expressions trait cannot contribute to the <code>Expression</code> trait.</p>
<section class="slide"><div class="section-body"><h1>Solving the Expression Problem in Scala</h1>
<p><strong>Adding a new data-type.</strong></p>
<pre><code class="Scala">trait AddExpressions extends Expressions {

  class Add(
    val l: Expression,
    val r: Expression) extends Expression {
				
    def accept[T](visitor: visitor[T]): T = visitor.visitAdd(l, r)
  }

  type visitor[T] &lt;: Visitor[T]
  trait Visitor[T] extends super.Visitor[T] {
    def visitAdd(l: Expression, r: Expression): T
  }

  trait EvalVisitor extends super.EvalVisitor with Visitor[Double] { 
  this: visitor[Double] ⇒
  def visitAdd(l: Expression, r: Expression): Double =
    l.accept(this) + r.accept(this)
  }
}
</code></pre>
</div></section>
<section class="slide"><div class="section-body"><h1>Solving the Expression Problem in Scala</h1>
<p>Bringing everything together:</p>
<pre><code class="Scala">trait ExtendedExpressions extends AddExpressions with MultExpressions {

  type visitor[T] = Visitor[T] 
  trait Visitor[T]
    extends super[AddExpressions].Visitor[T]
    with super[MultExpressions].Visitor[T]

  object EvalVisitor
    extends super[AddExpressions].EvalVisitor
    with super[MultExpressions].EvalVisitor
    with Visitor[Double] { 
	  this: visitor[Double] ⇒ }
}
</code></pre>
</div></section>
<p>By making the type visitor concrete (<code>type visitor[T] = Visitor[T]</code>) the data-type hierarchy is now fixed; extension is only possible w.r.t. new functionality.</p>
<section class="slide"><div class="section-body"><h1>Solving the Expression Problem in Scala</h1>
<p><strong>Adding new functionality.</strong></p>
<pre><code class="Scala">trait PrefixNotationForExpressions extends ExtendedExpressions {

  object PrefixNotationVisitor extends super.Visitor[String] { 
    this: visitor[String] ⇒

    def visitConstant(v: Double): String = v.toString+&quot; &quot;

    def visitAdd(l: Expression, r: Expression): String = 
      &quot;+ &quot;+l.accept(this) + r.accept(this)

    def visitMult(l: Expression, r: Expression): String = 
      &quot;* &quot;+l.accept(this) + r.accept(this)

  }
}
</code></pre>
</div></section>
<p>The complete code: <a href="Code/src/visitor/Expressions.scala">Visitor/Expressions.scala</a></p>
<p><strong>Assessment:</strong></p>
<ul>
<li>The solution is open w.r.t. to adding new functionality to expressions by means of a visitor and w.r.t. adding new data-types that inherit from <code>Expression</code>.</li>
<li>It is easy to add new functionality (e.g., <code>PrefixNotationForExpressions</code>).</li>
<li>It is possible to add new data-types (in a type-safe way), but this requires a deep-mixin composition.</li>
<li>The solution is subject to the fragile base-class problem.</li>
</ul>
<h2>Bridge Design Pattern</h2>
<h3>Intent</h3>
<section class="slide" data-title="The Bridge Design Pattern"><div class="section-body"><h1>The Bridge Design Pattern</h1>
<h2>Intent</h2>
<div class="statement">Decouple an abstraction from its implementation. So that the two can vary independently.</div>
</div></section>
<h3>Motivation by Example</h3>
<section class="slide" data-title="Motivation by Example"><div class="section-body"><h1>Motivation by Example</h1>
<p>We want to support multiple operating systems:</p>
<p><img src="Images/DP-Bridge-Windows-OS.png" alt="DP Bridge Windows OS" /></p>
<p>We want to provide different types of windows:</p>
<p><img src="Images/DP-Bridge-Windows-Types.png" alt="DP Bridge Windows Types" /></p>
</div></section>
<section class="slide"><div class="section-body"><h1>Motivation by Example</h1>
<p><strong>Two dimensions of variability!</strong></p>
<p><img src="Images/DP-Bridge-Windows-No-Solution.png" alt="DP Bridge Windows No Solution" /></p>
<footer><div class="footer-body"><p>Can you imagine a better solution?</p>
</div></footer>
</div></section>
<p>Several problems:</p>
<ul>
<li>Implementation bound to abstraction</li>
<li>Code duplication and proliferation of classes</li>
</ul>
<h3>Structure</h3>
<section class="slide" data-title="Structure"><div class="section-body"><h1>Structure</h1>
<p><img src="Images/DP-Bridge-Structure.png" alt="DP Bridge Structure" /></p>
</div></section>
<p>Combine inheritance and object composition:</p>
<ul>
<li>Use inheritance to model variations of the abstraction.</li>
<li>Use object composition to abstract from implementation variations. </li>
</ul>
<section class="slide" data-title="Bridge-Based Designs Illustrated"><div class="section-body"><h1>Bridge-Based Designs Illustrated</h1>
<p><img src="Images/DP-Bridge-Windows-BridgePatternApplied.png" alt="DP Bridge Windows BridgePatternApplied" /></p>
</div></section>
<p><strong>The Rationale Underlying the Solution</strong>:</p>
<ul>
<li>Object composition and inheritance provide different trade-offs for expressing variations. </li>
<li>Object composition is used to implement dynamic variations with a fixed interface.</li>
<li>Implementation variations are more of this kind; although not always…</li>
<li>For static variations inheritance is preferred, because it supports structural variations. </li>
<li>Abstraction variations are mostly static.</li>
<li>They often imply variation of structure.</li>
</ul>
<blockquote><p><strong>Inheritance allows adding of new field and methods.</strong></p>
<p><strong>Composition demands a fixed interface.</strong></p>
</blockquote>
<h3>Advantages</h3>
<p>Decoupling interface and implementation:</p>
<ul>
<li>Implementation can be configured at run-time.</li>
<li>The implementation in use is hidden inside the abstraction.</li>
</ul>
<p>Improved extensibility: </p>
<ul>
<li>Both abstractions and their implementations become independently extensible by subclassing without a class proliferation.</li>
<li>Different abstractions and implementations can be combined.</li>
</ul>
<section class="slide" data-title="Takeaway"><div class="section-body"><h1>Takeaway</h1>
<p>The Bridge Pattern instructs to use object composition to bridge between two inheritance hierarchies when you need to combine two kinds of variations of an object type.</p>
<p>The Bridge Pattern allows to vary an abstraction and its implementation independently of each other.</p>
<p>Works well as long as there is no dependency between the implementation on abstraction variations, i.e., if they do not vary co-variantly.</p>
</div></section>
<h2>Adapter Design Pattern</h2>
<h3>Intent</h3>
<section class="slide" data-title="The Adapter Design Pattern"><div class="section-body"><h1>The Adapter Design Pattern</h1>
<h2>Intent</h2>
<p>Intent: Fit foreign components into an existing design.</p>
<p><img src="Images/DP-Adapter-Framework.png" alt="DP Adapter Framework" /></p>
</div></section>
<p>We want to reuse existing frameworks or libraries in our software, even if they do not match with our design.</p>
<p>We do not want to change our design to adhere to the structure of the reused components.</p>
<h3>Case Study</h3>
<section class="slide" data-title="The Adapter Design Pattern - Illustrated"><div class="section-body"><h1>The Adapter Design Pattern - Illustrated</h1>
<p><img src="Images/DP-Adapter-CaseStudy-GraphicalFramework.png" alt="DP Adapter CaseStudy GraphicalFramework" /></p>
</div></section>
<p>We have acquired the framework <code>GraphicalFramework</code>.</p>
<p><code>GraphicalFramework</code> provides the interface <code>Node</code> to draw rectangles with a headline and text to the screen.</p>
<p>Drawing is done by the framework, we just need to provide the data via the interface <code>Node</code>.</p>
<section class="slide"><div class="section-body"><h1>Desired Usage of the Framework</h1>
<p><img src="Images/DP-Adapter-CaseStudy-DesiredUsage.png" alt="DP Adapter CaseStudy DesiredUsage" /></p>
</div></section>
<p>Our own design represents different kinds of persons.
We want to draw our data to the screen:</p>
<ul>
<li>Name and department of <code>Employee</code>.</li>
<li>Name and address of <code>Customer</code>.</li>
</ul>
<section class="slide"><div class="section-body"><h1>Adapting the Framework</h1>
<p><img src="Images/DP-Adapter-CaseStudy-AdaptingTheFramework.png" alt="DP Adapter CaseStudy AdaptingTheFramework" /></p>
</div></section>
<p>We will create adapters to use the functionality of <code>GraphicalFramework</code>  for our classes.</p>
<p>We have to adapt <code>Employee</code> and <code>Customer</code> to fit with <code>Node</code>.</p>
<h3>Two Kinds of Adapters</h3>
<h4>Object Adapter</h4>
<section class="slide" data-title="Object Adapter"><div class="section-body"><h1>Object Adapter</h1>
<p><img src="Images/DP-Adapter-Structure-ObjectForm.png" alt="DP Adapter Structure ObjectForm" /></p>
</div></section>
<ul>
<li><code>Adaptee</code> is wrapped by <code>Adapter</code> to fit in the interface of <code>Target</code>.</li>
<li><code>Adapter</code> forwards calls of <code>Client</code> to <code>request()</code> to the specific methods of <code>Adaptee</code> (e.g, <code>specificRequest()</code>).</li>
</ul>
<section class="slide"><div class="section-body"><h1>Using Object Adapter</h1>
<p><img src="Images/DP-Adapter-CaseStudy-ObjectAdapter.png" alt="DP Adapter CaseStudy ObjectAdapter" /></p>
</div></section>
<p><strong>Advantages</strong>:</p>
<ul>
<li><code>Adapter</code> works with <code>Adaptee</code> and any subclass of it.</li>
<li><code>Adapter</code> can add functionality to <code>Adaptee</code> and its subclasses.</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Cannot override methods in <code>Adaptee</code>.</li>
<li>Cannot reuse <code>Adapter</code> with subclasses of <code>Target</code>.</li>
<li><code>Adapter</code> and <code>Adaptee</code> are different objects.<br />
(Need to maintain relation between <code>Adaptee</code> and his <code>Adapter</code>)</li>
</ul>
<h4>Class Adapter</h4>
<section class="slide" data-title="Class Adapter"><div class="section-body"><h1>Class Adapter</h1>
<p><img src="Images/DP-Adapter-Structure-ClassForm.png" alt="DP Adapter Structure ClassForm" /></p>
</div></section>
<p>Instead of having <code>Adaptee</code> as an attribute, <code>Adapter</code> inherits from <code>Adaptee</code>.</p>
<section class="slide"><div class="section-body"><h1>Using Class Adapter</h1>
<p><img src="Images/DP-Adapter-CaseStudy-ClassAdapter.png" alt="DP Adapter CaseStudy ClassAdapter" /></p>
</div></section>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Behavior of <code>Adaptee</code> can be overridden.</li>
<li>Adapter and <code>Adaptee</code> are the same object, no forwarding.</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li><code>Adapter</code> cannot be used with subclasses of <code>Adaptee</code> or <code>Target</code>. </li>
<li><code>Multiple</code> inheritance may be required.<br />
In Java: At least one of <code>Target</code> and <code>Adaptee</code> must be an Interface.</li>
</ul>
<h3>Takeaway</h3>
<section class="slide" data-title="Takeaway"><div class="section-body"><h1>Takeaway</h1>
<p>Adapter is an effective means to adapt existing behavior to the expected interfaces of a reusable component or framework.</p>
<p>Two variants: <strong>Object and Class Adapter</strong></p>
<ul>
<li>Both have their trade-offs.</li>
<li>Both have problems with the reusability of the adapter.</li>
</ul>
</div></section>
<h3>Pimp My Library (Scala)</h3>
<section class="slide" data-title="Pimp My Library (Scala)"><div class="section-body"><h1>Pimp-my-Library Idiom/Pattern (Scala)</h1>
<h2>Goal</h2>
<p>Solve the problem that you can change or extend your own code, but if you use other libraries you have to take them as they are.</p>
<h2>Solution Idea</h2>
<p>Define a conversion function to convert your object into the required object and make this conversion <code>implicit</code> to let the compiler automatically perform the conversion when needed.<br />
(<em>Transparent</em> generation of object adapters.)</p>
</div></section>
<h4>Example Scenario</h4>
<p>We want to be able to repeat a certain operation multiple times and want to store the result in some given mutable store.</p>
<p>But, Scala&apos;s (2.10) mutable collections do not define a common method to add an element to them.</p>
<p>In the following we develop a generalization of the previously shown <code>repeat</code> method. This variant enables the developer to specify the target data store.</p>
<section class="slide"><div class="section-body"><p>Implementing a <code>repeatAndStore</code> method <strong>(naïve approach)</strong>.</p>
<pre><code class="Scala">object ControlFlowStatements {
  import scala.collection.mutable.Set
</code></pre>
<section data-anim-step="1"><div class="section-body"><pre><code class="Scala">  abstract class MutableCollection[T, C[T]](val underlying: C[T]) {
    def +=(elem: T): Unit
  }
</code></pre>
</div></section>
<section data-anim-step="2"><div class="section-body"><pre><code class="Scala">  implicit def setToMutableCollection[T](set: Set[T]) =
    new MutableCollection(set) { def +=(elem: T) = set += (elem) }
</code></pre>
</div></section>
<pre><code class="Scala">  def repeatAndStore[T, C[T]]
      (times: Int)(f: ⇒ T)(collection: MutableCollection[T, C]): C[T] = {
    var i = 0; while (i &lt; times) { collection += f; i += 1 }
    collection.underlying
  }
</code></pre>
<pre><code class="Scala">}
</code></pre>
<aside data-title="Example Usage"><div class="aside-body"><pre><code class="Scala">object CFSDemo extends App {
  import ControlFlowStatements._

  val nanos =
    repeatAndStore(5) {
      System.nanoTime()
    }(new scala.collection.mutable.HashSet[Long]())

}
</code></pre>
<p>What is the type of <code>nanos</code>?</p>
</div></aside>
</div></section>
<p>The previous solution has two issues:</p>
<ol>
<li>The <code>repeatAndStore</code> method requires a <code>MutableCollection</code> which is basically an implementation-internal type.</li>
<li>It returns the original collection to make the usage easier, but important type information is lost (the <code>HashSet</code> has become a <code>Set</code>).</li>
</ol>
<section class="slide"><div class="section-body"><p>Implementing a <code>repeatAndStore</code> method.</p>
<pre><code class="Scala">object ControlFlowStatementsBase {
  trait Mutable[-C[_]] {
    def add[T](collection: C[T], elem: T): Unit
  }

  implicit object Set extends Mutable[Set] {
    def add[T](collection: Set[T], elem: T) { collection += elem }
  }

  implicit object MutableBuffer extends Mutable[Buffer] {
    def add[T](collection: Buffer[T], elem: T) { collection += elem }
  }

  def repeatWithContextBound[T, X[T] &lt;: AnyRef: Mutable]
  (times: Int)
      (f: ⇒ T)(collection: X[T]): collection.type = {
    var i = 0
    while (i &lt; times) { 
	    implicitly[Mutable[X]].add(collection, f); i += 1 
    }
    collection
  }
}
</code></pre>
<aside data-title="Example Usage"><div class="aside-body"><pre><code class="Scala">object CFSDemo extends App {
  import ControlFlowStatements._

  val nanos_1: HashSet[Long] = 
    repeatWithContextBound(5){ System.nanoTime() }(new HashSet[Long]())

  val nanos_2: ArrayBuffer[Long] = 
    repeatWithContextBound(5){ System.nanoTime() }(new ArrayBuffer[Long]())

  val nanos_3: nanos_1.type = 
    repeatWithContextBound(5) {System.nanoTime() }(nanos_1)

  def stricterEquals[X &lt;: AnyRef](a: X)(b: a.type) = a == b
  stricterEquals(nanos_1)(nanos_3)
  // /* correctly won&apos;t compile */ stricterEquals(nanos_2)(nanos_3)
}
</code></pre>
</div></aside>
</div></section>
<h3>Builder Design Pattern</h3>
<h3>Intent</h3>
<section class="slide" data-title="Builder - Intent"><div class="section-body"><h1>Builder - Intent</h1>
<div class="statement">Divide the construction of multi-part objects in different steps, so that different implementations of these steps can construct different representations of objects.</div>
</div></section>
<h3>Structure</h3>
<section class="slide" data-title="Builder - Structure"><div class="section-body"><h1>Builder - Structure</h1>
<p><img src="Images/DP-Builder-Structure.png" alt="DP Builder Structure" /></p>
</div></section>
<p><code>Builder</code> defines the individual steps of the construction of <code>Product</code>.</p>
<p><code>Director</code> knows in which order to construct <code>Product</code>.</p>
<p><code>ConcreteBuilder</code> implements the steps of construction.</p>
<h3>Example</h3>
<p>We want to construct different types of cars.</p>
<p>In this example, cars have an engine and an interior.</p>
<section class="slide" data-title="Builder - A Car Builder"><div class="section-body"><h1>Builder - A Car Builder</h1>
<p><img src="Images/DP-Builder-ACar.png" alt="DP Builder ACar" /></p>
</div></section>
<section class="slide"><div class="section-body"><h1>Builder - A Car Builder</h1>
<p><img src="Images/DP-Builder-CarBuilder.png" alt="DP Builder CarBuilder" /></p>
</div></section>
<p><code>CarBuilder</code> defines the two methods to construct car parts. Concrete builders must implement these methods. For convenience, the instantiation of cars (buildCar()) is implemented in <code>CarBuilder</code>.</p>
<p><code>CarConstructionDirector</code>  is configured with a <code>CarBuilder</code> and calls the construction methods in the correct order.</p>
<section class="slide"><div class="section-body"><h1>Two Possible Car Builders</h1>
<pre><code class="Java">class CheapCarBuilder extends CarBuilder {
  void buildEngine() {
    car.setEngine(Engine.SMALL_ENGINE);
  }

  void buildInterior() {
    car.setInterior(Interior.PLASTIC_INTERIOR);
  }
}
</code></pre>
<pre><code class="Java">class LuxuryCarBuilder extends CarBuilder {
  void buildEngine() {
    car.setEngine(Engine.SPORT_ENGINE);
  }

  void buildInterior() {
    car.setInterior(Interior.WOODEN_INTERIOR);
  }
}
</code></pre>
</div></section>
<h3>Discussion</h3>
<p><strong>Assessment of the Builder Pattern</strong>:</p>
<ul>
<li><p><strong>Advantages</strong>:</p>
<ul>
<li>Creation of objects can be configured at runtime.</li>
<li>Concrete builders can use complex logic.<br />
E.g. a car builder creating cars depending on available parts in storage.</li>
<li>Good way to create composite structures.</li>
</ul>
</li>
<li><p><strong>Disadvantages</strong>:</p>
<ul>
<li>May yield many classes.</li>
<li>Only works if all objects can be constructed using the same order.</li>
</ul>
</li>
</ul>
<p><strong>Builder vs. Abstract Factory Pattern</strong>:</p>
<ul>
<li><p>Abstract Factory focuses on creating multiple objects of a common family.</p>
<ul>
<li>Abstract Factory knows what object to create.</li>
<li>Configuration is fixed after deployment of the software.</li>
</ul>
</li>
<li><p>Builder focuses on creating complex objects step by step.</p>
<ul>
<li>The director knows how to construct the object.</li>
<li>Configuration is chosen at runtime via the concrete builder.</li>
</ul>
</li>
</ul>
<section class="slide" data-title="Takeaway"><div class="section-body"><h1>Takeaway</h1>
<p>Use <em>Abstract Factory</em> for creating objects depending on finite numbers of factors you know in advance.<br />
E.g. if there are only three kinds of cars.</p>
<p>Use <em>Builder</em> for creating complex objects depending on unbound number of factors that are decided at runtime.<br />
E.g. if cars can be configured with multiple different parts.</p>
</div></section>
<h2>Command Design Pattern</h2>
<h3>Motivating Example: A Document Editor</h3>
<p>Given some user operations such as &quot;creating a document&quot;, &quot;opening a file&quot;, &quot;saving a document&quot;, &quot;printing a document&quot;, &quot;cutting selected text&quot; and &quot;pasting it back in&quot;, we then want to be able to access them from more than one place in the UI (a menu and a toolbar).</p>
<section class="slide" data-title="Motivating Example: A Document Editor"><div class="section-body"><h1>Motivating Example: A Document Editor</h1>
<p><img src="Images/DP-Command-ApplicationClassDiagram.png" alt="DP Command ApplicationClassDiagram" /></p>
<footer><div class="footer-body"><p>What do you think?</p>
</div></footer>
</div></section>
<p>The implementation of each <code>MenuItem</code> subclass is the same as the implementation of one of <code>ToolIcon</code> subclasses.
Multiple copies of the same functionality → maintenance problem.</p>
<p>Need a mechanism for <code>MenuItem</code> and <code>ToolIcon</code> to share implementations.<br />
Need to separate the user-interface control from it’s implementation so that implementations can be shared.</p>
<p>Want to also support a general undo capability so that the user can reverse previous operations.</p>
<section class="slide" data-title="Decouple Invoker from Receiver"><div class="section-body"><h1>Solution: Decouple Invoker from Receiver</h1>
<p><img src="Images/DP-Command-ApplicationClassDiagramWithCommand.png" alt="DP Command ApplicationClassDiagramWithCommand" /></p>
</div></section>
<section class="slide" data-title="Decouple Invoker from Receiver"><div class="section-body"><h1>Solution: Decouple Invoker from Receiver</h1>
<p><img src="Images/DP-Command-ImplementingPasteAndOpen.png" alt="DP Command ImplementingPasteAndOpen" /></p>
</div></section>
<h3>In a Nutshell</h3>
<section class="slide" data-title="Command Design Pattern - Intent"><div class="section-body"><h1>Intent</h1>
<p><strong>Encapsulate a request to an object, thereby allowing to:</strong></p>
<ul>
<li>Issue requests without knowing the receiver or the operation being requested.</li>
<li>Parameterize clients with different requests.</li>
<li>Queue or log requests and support undoable requests.</li>
</ul>
</div></section>
<section class="slide" data-title="Command Design Pattern - Structure"><div class="section-body"><h1>Structure</h1>
<p><img src="Images/DP-Command-Structure.png" alt="DP Command Structure" /></p>
</div></section>
<ul>
<li><code>Command</code> declares the interface for executing an operation.</li>
<li><code>ConcreteCommand</code> defines a receiver-action binding by implementing <code>execute()</code>.</li>
<li><code>Client</code> creates a <code>ConcreteCommand</code> object, sets its <code>Receiver</code>, and configures the command of the <code>Invoker</code>.</li>
<li><code>Invoker</code> asks its command to carry out the request.</li>
<li><code>Receiver</code> knows how to perform the operations associated with carrying out a request.</li>
</ul>
<section class="slide" data-title="Command Design Pattern - Collaboration"><div class="section-body"><h1>Collaboration</h1>
<p><img src="Images/DP-Command-Collaboration.png" alt="DP Command Collaboration" /></p>
</div></section>
<h3>Advantages of Command</h3>
<section class="slide" data-title="Command Design Pattern - Implementation Sharing"><div class="section-body"><h1>Implementation Sharing</h1>
<p><img src="Images/DP-Command-SupportingMenuAndToolbarOperations-ImplementationSharing.png" alt="DP Command SupportingMenuAndToolbarOperations ImplementationSharing" /></p>
</div></section>
<ul>
<li>A command centralizes an operation to a single location so that multiple copies of the code are not necessary.</li>
<li>Different user-interface controls can share the same implementation<br />
(e.g., a button, tool icon, and menu item can all perform the same operation).</li>
<li>Decouples the user interface from the operation being performed.</li>
</ul>
<section class="slide" data-title="Command Design Pattern - Supporting Undoable Operations"><div class="section-body"><h1>Supporting Undoable Operations</h1>
<p><img src="Images/DP-Command-AddingUndototheFontCommand.png" alt="DP Command AddingUndototheFontCommand" /></p>
</div></section>
<ul>
<li><code>Command</code>s store enough information to undo the performed operation.</li>
<li>Each command subclass implements its <code>unexecute()</code> function;<br />
when <code>unexecute()</code> is called the command reverses its action.</li>
</ul>
<section class="slide"><div class="section-body"><h1>Supporting Multiple Levels Of Undo</h1>
<div style="float:left;width:150px"> 
	Single Level of Undo
</div>
<p><img src="Images/DP-Command-MultipleLevelsOfUndo-SLU.png" alt="DP Command MultipleLevelsOfUndo SLU" /></p>
<hr />
<div style="float:left;width:150px"> 
	Multiple Levels of Undo
</div>
<p><img src="Images/DP-Command-MultipleLevelsOfUndo-MLU.png" alt="DP Command MultipleLevelsOfUndo MLU" /></p>
</div></section>
<ul>
<li>Undoing more than just the last command allows the user to back up farther and farther each time undo is selected from the menu.</li>
<li>Adding a redo feature: it would also be nice for a user to be able to redo an undone operation.<br />
Redo should have multiple levels corresponding to the number of undo&apos;s issued by the user.</li>
</ul>
<section class="slide"><div class="section-body"><h1>Implementing a Command History</h1>
<p><img src="Images/DP-Command-CommandHistory.png" alt="DP Command CommandHistory" /></p>
</div></section>
<p>The command history can be seen as a list of past commands.</p>
<p>As new commands execute they are added to the front of the history.</p>
<p>To <strong>undo</strong> a command, <code>unexecute()</code> is called on the command at the front of the list.</p>
<p>The present pointer is moved past that command.</p>
<p>To <strong>undo</strong> the command before that, <code>unexecute()</code> is called on the next command in the history.</p>
<p>The present pointer is moved to point before that command.</p>
<p>To <strong>redo</strong> the command that was just undone, <code>execute()</code> is called on that command.</p>
<p>The present pointer is moved up past that command.</p>
<section class="slide" data-title="Command Design Pattern - Macro Commands"><div class="section-body"><h1>Macro Commands</h1>
<p><img src="Images/DP-Command-MacroCommands.png" alt="DP Command MacroCommands" /></p>
</div></section>
<h3>Takeaway</h3>
<section class="slide" data-title="Command Design Pattern - Takeaway"><div class="section-body"><h1>Takeaway</h1>
<ul>
<li><p>Command allows to decouple the invoker of an operation from the receiver of that operation.</p>
</li>
<li><p>A <code>Command</code> object encapsulates the knowledge about a concrete operation and a concrete receiver of that operation.</p>
</li>
</ul>
<p>As a result:</p>
<ul>
<li>the same invoker can be reused with different operation-receiver pairs.</li>
<li>the same operation-receiver pair can be plugged into different invokers.</li>
<li>commands can be queued, undone/redone, and composed into macro-commands. </li>
</ul>
</div></section>
<h3>Example Implementation</h3>
<p>In practice (in GUI applications), you often have multiple instances of the command design pattern which are related to different kinds of actions.</p>
<ol>
<li>The command pattern is used to associate some action with a menu item or a tool bar icon and which (as a second step) then may require some further user input/interacts with the environment. These commands are usually not stored in any command history as it makes no sense to redo/undo them (e.g., &quot;open file&quot;, &quot;save file&quot;, &quot;copy text to clipboard&quot;). </li>
<li>You have commands that update the state of an application (i.e., manipulates the application&apos;s data) and which you may want to store in the command history because you want to be able to undo/redo the corresponding action. These commands then have to offer an <code>execute</code> and <code>unexecute</code> methods.</li>
</ol>
<p>Some commands, e.g., &quot;paste clipboard content&quot; are typically triggered by some user interaction, but do not require any further user interaction and, hence, could be regarded as a command of the second type. But, this is deceiving. Imagine that - at some later point in time - the user undos the last editing steps including the pasting of the clipboard content. When the user then redos that step, he expects that the same content is added again as was just removed/originally added – even if the clipboard content has changed in the meantime. Hence, even in this case we want to distinguish between the command that interacts with the environment and the command that directly (after gathering all information) with the document.</p>
<section class="slide" data-title="Command Design Pattern - Example Implementation"><div class="section-body"><h1>Example Implementation</h1>
<p><strong>Supporting multiple-step undo/redo</strong></p>
<p>The application:</p>
<pre><code class="Scala">object Application { var document: String = &quot;&quot; }
</code></pre>
<p>The <code>Command</code> trait:</p>
<pre><code class="Scala">trait Command { 
  def execute(): Unit
  def unexecute(): Unit
}
</code></pre>
</div></section>
<section class="slide"><div class="section-body"><h1>Example Implementation</h1>
<p><strong>Supporting multiple-step undo/redo</strong></p>
<p>A <code>ConcreteCommand</code> to manipulate the document:</p>
<pre><code class="Scala">class AddTextCommand(val text: String) extends Command {
  import Application.document
  
  def execute() { document += text }

  def unexecute() {
    document = document.substring(0, document.length - text.length)
  }

  override def toString = &quot;Add text: &quot;+text
}
</code></pre>
</div></section>
<section class="slide"><div class="section-body"><h1>Example Implementation</h1>
<p><strong>Supporting multiple-step undo/redo</strong></p>
<p>The command history:</p>
<pre><code class="Scala">object CommandManager {
  private var pastCommands: List[Command] = Nil
  private var futureCommands: List[Command] = Nil

  def execute(command: Command) {
    command.execute()
    pastCommands = command :: pastCommands
    futureCommands = Nil // kill all previous future commands
  }
  def undo() {
    if (pastCommands.nonEmpty) {
      val pastCommand = pastCommands.head; pastCommand.unexecute()
      futureCommands = pastCommand :: futureCommands
      pastCommands = pastCommands.tail
  } }
  def redo() {
    if (futureCommands.nonEmpty) {
      val futureCommand = futureCommands.head; futureCommand.execute()
      pastCommands = futureCommand :: pastCommands
      futureCommands = futureCommands.tail
} } }
</code></pre>
</div></section>
<p>In this case, the responsibility for calling a <code>ConcreteCommand</code>&apos;s <code>execute</code> method is delegated to the <code>CommandManager</code>.</p>
<section class="slide"><div class="section-body"><h1>Example Implementation</h1>
<p><strong>Supporting multiple-step undo/redo</strong></p>
<p>Creating a command object and adding it to the history:</p>
<pre><code class="Scala">object askForInput extends (() ⇒ Unit) {

    def apply() {
        import javax.swing.JOptionPane.showInputDialog
        val text = showInputDialog(&quot;Please, enter some text.&quot;)
        if (text ne null) {
            CommandManager.execute(new AddTextCommand(text))
        }
    }
}
</code></pre>
</div></section>
<p>The <code>askForInput</code> object has the responsibility to ask the user for some input and to add the respective input to the document. This object is also a <code>ConcreteCommand</code> where the <code>execute</code> method is called <code>apply</code>. </p>
<section class="slide"><div class="section-body"><h1>Example Implementation</h1>
<p><strong>Supporting multiple-step undo/redo</strong></p>
<p>Example usage:</p>
<pre><code class="Scala">object CommandDemo extends App {
    for (i ← 0 until 3) {
        askForInput()
    }

    CommandManager.undo
    CommandManager.undo
    CommandManager.redo
}
</code></pre>
</div></section>
<h1>Domain Specific Languages</h1>
<section class="slide" data-title="Domain Specific Languages (DSLs)"><div class="section-body"><h1>Domain Specific languages (DSLs)</h1>
<blockquote><p>[...] a good programmer in these times does not just write
programs. [...] a good programmer does language design,
though not from scratch, but building on the frame of a base
language. -Guy Steele Jr.</p>
</blockquote>
</div></section>
<section class="slide" data-title="Introduction"><div class="section-body"><h1>Introduction</h1>
<blockquote><p>A <strong>Domain Specific Language</strong> is a computer programming language focused on a particular domain -Martin Fowler</p>
</blockquote>
<p>Here are two examples of DSLs: </p>
<p>An example of DSLs is an Antlr grammar for defining integers, comments and lower case letters. </p>
<pre><code class="Antlr">integer : (HEX_PREFIX | OCTAL_PREFIX)? DIGITS;            
DIGITS : &apos;1&apos;..&apos;9&apos; &apos;0&apos;..&apos;9&apos;*;                                             
ML_COMMENT : &apos;/*&apos; ( options {greedy=false;} : . )* &apos;*/&apos; ; .                                                  
NO_LOWERCASE_LETTERS : (~(&apos;a&apos;..&apos;z&apos;))+;       
</code></pre>
</div></section>
<section class="slide" data-title="second DSL example"><div class="section-body"><h1>DSLs - a second example</h1>
<p>Here we create an SQL table, insert and select records from it. </p>
<pre><code class="SQL">CREATE TABLE Persons
(
PersonID int,
LastName varchar(255),
FirstName varchar(255),
Address varchar(255),
City varchar(255)
);

insert into Persons values(1,&apos;Eichberg&apos;,&apos;Michael&apos;,&apos;Hochschulstr. 10&apos;,&apos;Darmstadt&apos;);
select Address from Persons where LastName=&apos;Eichberg&apos;;
</code></pre>
<p>Examples of DSLs are : HTML, SQL, Yacc, Antlr ...</p>
</div></section>
<p>What distinguishes DSLs is their high expressiveness inside the boundaries of a particular domain and limited expressiveness outside the boundaries of that domain. </p>
<p>So, a single project can contain many DSLs in different parts where every language addresses a specific domain and all integrated in one project.</p>
<section class="slide" data-title="Abstraction as a tool for building good Software"><div class="section-body"><h1>Abstraction as a tool for building good Software</h1>
<p>As we learned before that abstraction is the key to to building good software as it complies with many class design principles and design patterns.</p>
<p>There are many abstraction mechanisms as:</p>
<ul>
<li>Abstract Data Types (ADTs)</li>
<li>Classes</li>
<li>Objects </li>
<li>Modularization</li>
<li>Higher order Functions </li>
<li>....</li>
</ul>
</div></section>
<h2>Alternatively abstraction as a Programming language</h2>
<p>A good way of abstraction is to design a programming language specific to every targeted domain which encloses the terms and semantics for that domain. </p>
<p>This language should be easy to use and to extend by domain experts.</p>
<p>Avoid noise about programming language details and have focus on the problem domain.</p>
<section class="slide" data-title="Why build my own DSL?"><div class="section-body"><h1>Why build my own DSL?</h1>
<p>There are several reasons that make DSLs more practical in solving Domain specific problems</p>
<ul>
<li>A DSL is more understandable for the domain experts than a General Purpose Language(GPL) making it much easier to learn, use, validate and modify</li>
<li>Having an own library that captures domain specific semantics and that could be extensible to adapt future evolutions</li>
<li>The code is almost self-documented</li>
<li>It is maintainable, portable, reusable and easier to check</li>
<li>It may be easier to apply formal methods on DSLs as reasoning can be done within the domain semantics</li>
</ul>
</div></section>
<section class="slide" data-title="Desired properties of DSLs"><div class="section-body"><h1>Desired properties of DSLs</h1>
<p>To build an optimal DSL we should make use of the advantages of the previously mentionned approaches.</p>
<ul>
<li>Precise representation of domain concepts</li>
<li>Composability</li>
<li>Reasonable performance</li>
<li>Infrastructure reusability (parser, compiler, linker, ...)</li>
<li>High modularity</li>
<li>Static safety</li>
<li>Tool support for debugging/syntax highlighting/code completion </li>
<li>...</li>
</ul>
</div></section>
<h2>Tradeoffs of building a DSL</h2>
<ul>
<li>When building a DSL you need to implement your own parser/compiler</li>
<li>Building a language for every application domain could be tedious</li>
<li>The programmer needs to anticipate future changes that could be introduced to that domain as it evolves over time</li>
<li>This is quite difficult or could be impossible</li>
<li>Solution : Make use of the existing features of a general purpose programming language </li>
</ul>
<section class="slide" data-title="DSLs takeaway"><div class="section-body"><h1>DSLs Takeaway</h1>
<table border="1">
	<tr>
		<th></th>
		<th>DSLs</th>
	</tr>
	<tr>
		<th>Precise representation of domain concepts</th>
		<td><center>++</center></td>
	</tr>
	<tr>
		<th>Tool support</th>
		<td>+/-</td>
	</tr>
	<tr>
		<th>Infrastructure reuse</th>
		<td>--</td>
	</tr>
	<tr>
		<th>High Modularity</th>
		<td>-</td>
	</tr>
	<tr>
		<th>Composability</th>
		<td>--</td>
	</tr>
	<tr>
		<th>Static safety</th>
		<td>+/-</td>
	</tr>
</table>
</div></section>
<p>It is excellent for representing domain concepts as it is build from scratch to adopt that domain. An example is SQL for representing the databases domain.</p>
<p>The tool support could be an advantage/disadvantage depending on the effort that we need to develop tool support for the DSL.</p>
<p>The static saftey could be advantage/disadvantage according to whether it is integrated with other language or if it is standalone.</p>
<p>There is no infrastructure reuse as the whole &quot;package&quot;(grammar/parser/compiler/...) has to be built from scratch.</p>
<p>The composability also is a disadvantage as the language is strictly for representing a specific domain and not composable with languages for other domains.</p>
<p>The &quot;o&quot; symbol denotes that this feature is not applicable.</p>
<section class="slide" data-title="Embedding of a DSL"><div class="section-body"><h1>Embedding of a DSL</h1>
<ul>
<li><p>Example: SQLj</p>
</li>
</ul>
<pre><code class="SQL">sql private static iterator EmployeeIterator(String, String, BigDecimal);
...
EmployeeIterator iter;
#sql [ctx] iter = {
  SELECT LASTNAME
       , FIRSTNME
       , SALARY
    FROM DSN8710.EMP
   WHERE SALARY BETWEEN :min AND :max
};
do {
  #sql {
    FETCH :iter
     INTO :lastname, :firstname, :salary
  };
  // Print row...
} while (!iter.endFetch());
iter.close();
</code></pre>
</div></section>
<ul>
<li>The DSL has its own syntax which is different from the syntax of the host language</li>
<li>A special compiler needed to compile the DSL then it passes to the host language compiler</li>
<li>Disadvantages: composability and also in IDEs, syntax highlighting/code completion is not available for the DSL but only for the host language</li>
</ul>
<section class="slide" data-title="Code Generators"><div class="section-body"><h1>Code Generators</h1>
<p>Use preprocessors to integrate a DSL into a a General purpose host language.</p>
<p>Files containing the DSL code and host language code will be mixed and converted to program fragments of the host language.</p>
<p>Advantage: quite flexible and makes multiple interpretations possible.</p>
<p>Disadvantage: difficult interoperability among preprocessors and the need to almost build an almost full featured compiler.</p>
<p>An example is SQLj.</p>
</div></section>
<section class="slide" data-title="Embedding of DSLs takeaway"><div class="section-body"><h1>Embedding of DSLs Takeaway</h1>
<table border="1">
	<tr>
		<th></th>
		<th>DSLs</th>
		<th>Embedding of DSLs</th>
	</tr>
	<tr>
		<th>Precise representation of domain concepts</th>
		<td><center>++</center></td>
		<td>o</td>
	</tr>
	<tr>
		<th>Tool support</th>
		<td>+/-</td>
		<td>-</td>
	</tr>
	<tr>
		<th>Infrastructure reuse</th>
		<td>--</td>
		<td>o</td>
	</tr>
	<tr>
		<th>High Modularity</th>
		<td>-</td>
		<td>o</td>
	</tr>
	<tr>
		<th>Composability</th>
		<td>--</td>
		<td>-</td>
	</tr>
	<tr>
		<th>Static safety</th>
		<td>+/-</td>
		<td>+</td>
	</tr>
</table> 
</div></section>
<p>Embedding of a DSL in a host language is statically safe as it has its own compiler which will always guarantee the static safety
of the embedded language, independent from the host language.</p>
<p>Embedding of a DSL in a host language will make it not composable as it has its own compiler/interpreter that differs from that of the
host language.</p>
<p>The tool support is just for the host language not for the embedded language.</p>
<section class="slide" data-title="Embedded Domain Specific Languages (EDSLs)"><div class="section-body"><h1>Embedded Domain Specific Languages (EDSLs)</h1>
<p>Embedding a DSL into an already existing general purpose programming language will greatly reduce the implementation effort.</p>
<p>The embedded language will make use of the features of the host language.</p>
<p>But on the other side embedding the DSL as a library will make it have a single interpretation that is <strong>tightly coupled</strong> to the host language.</p>
<p>There are many approaches for embedding a DSL into a general purpose language.</p>
</div></section>
<section class="slide" data-title="Embedded Interpreter"><div class="section-body"><h1>Embedded Interpreter</h1>
<p>Make use of the host language parser and compiler by embedding the DSL as host language expressions.</p>
<p>The written syntax could be interpreted by a host language interpreter</p>
<p>This is known as the <strong>Interpreter pattern</strong></p>
<p>However, mixing several DSLs&apos; expressions will create ambiguity on how should every expression be interpreted .</p>
</div></section>
<section class="slide" data-title="Pure Embedding"><div class="section-body"><h1>Pure Embedding</h1>
<p>Similar to a traditional library approach, however, domain specific semantics are taken into consideration while constructing the language.</p>
<p>Domain types are implemented as host language types.</p>
<p>However host language and DSL as tightly coupled.</p>
</div></section>
<section class="slide" data-title="Embedded DSLs Takeaway"><div class="section-body"><h1>Embedded DSLs Takeaway</h1>
<table border="1">
	<tr>
		<th></th>
		<th>DSLs</th>
		<th>Embedding of DSLs</th>
		<th>Embedded DSLs</th>
	</tr>
	<tr>
		<th>Precise representation of domain concepts</th>
		<td><center>++</center></td>
		<td>o</td>
		<td>-</td>
	</tr>
	<tr>
		<th>Tool support</th>
		<td>+/-</td>
		<td>-</td>
		<td>+/-</td>
	</tr>
	<tr>
		<th>Infrastructure reuse</th>
		<td>--</td>
		<td>o</td>
		<td>++</td>
	</tr>
	<tr>
		<th>High Modularity</th>
		<td>-</td>
		<td>o</td>
		<td>o</td>
	</tr>
	<tr>
		<th>Composability</th>
		<td>--</td>
		<td>-</td>
		<td>+</td>
	</tr>
	<tr>
		<th>Static safety</th>
		<td>+/-</td>
		<td>+</td>
		<td>+/-</td>
	</tr>
</table> 
</div></section>
<p>Embedded DSLs are bound by the syntax of the host language. So it could have some shortage in representing the domain concepts.</p>
<p>Concerning tool support, there is tool support (syntax highlighting, code completion,...) for the host language but there <strong>might not</strong> be tool support for the embedded DSL (e.g. slick).</p>
<p>The static safety depends on the type safety of the host language. So if the host language is dynamically typed then there is no type safety for the EDSL.</p>
<section class="slide" data-title="Host languages of DSLs"><div class="section-body"><h1>Host languages of DSLs</h1>
<p>Many of today&apos;s General purpose languages can be valid as a host languages for EDSLs. For example: Java, Haskell, Scala,...</p>
<p>We have chosen scala for its rich features as family polymorohism, support for higher order functions, mixin composition, syntactic flexibility, advanced type system, ...</p>
<p>However all of the previously mentionned languages can be used to build one.</p>
</div></section>
<section class="slide" data-title="Case Study- The *Regions* language"><div class="section-body"><h1>Case Study- The <em>Regions</em> language</h1>
<p>Derived from the image processing domain</p>
<p>It is basically for one domain specific type <em>Regions</em>.</p>
<p>Along with operations required for describing regions and building more complex regions.</p>
<p>For demonstration purposes, the language is kept simple. However, it can be easily extended without changing the basic language structure.</p>
</div></section>
<section class="slide"><div class="section-body"><h1>The <em>Regions</em> language - cont</h1>
<pre><code class="Scala">
trait Regions{

   type Vector= (double,double)
   type Region

   def univ : Region
   def empty : Region  
   def circle : Region
   def scale(v : Vector, x :Region) : Region
   def union(x : Region, y :Region) : Region
  }
  
   def program(semantics : Regions) : semantics. Region ={   
   import semantics._
  
   val ellipse24=scale ((2,4), circle)
   union (univ,ellipse24) //The returned expression
  }
  
</code></pre>
</div></section>
<p>Here two type members are declared:</p>
<ul>
<li><strong>Vector</strong> as a pair of doubles</li>
<li><strong>Region</strong> as an abstract domain type that will be defined in subclasses.</li>
</ul>
<p>Beside type members, operations are defined to represent </p>
<ul>
<li>empty regions</li>
<li>universal regions: that include every point</li>
<li>circle to represent a unit circle aroung the origin of the coordinate space</li>
<li>scaling a region by a by a vector v resulting in a new scaled region</li>
<li>and the union between regions </li>
</ul>
<p>A client of the Regions interface is defined having a dependent return type that depends on the <strong>semantics</strong> implementation of type</p>
<section class="slide"><div class="section-body"><h1>Various sematics for the <em>Regions</em> type</h1>
<p>After defining the trait of the Regions language, we can now define various semantics that extend this trait and implement abstract types and operations.</p>
<p>An example of the operations are :</p>
<ul>
<li>checking if a point is inside or outside a region</li>
<li>pretty printing of region operations</li>
</ul>
</div></section>
<section class="slide"><div class="section-body"><h1>The <em>Evaluation</em> trait</h1>
<pre><code class="Scala">
trait Evaluation extends Regions{

   type Region = Vector =&gt; boolean

   def univ : Region = p =&gt; true
   def empty : Region  = p =&gt;false
   def circle : Region = p =&gt; p._1*p._1 + p._2*p._2 &lt; 1
   def scale(v : Vector, x :Region) : Region = p =&gt; x(p._1/v._1,p._2/v._2)
   def union(x : Region, y :Region) : Region = p =&gt; x(p) || y(p)
   
}   

object Eval extends Evaluation
 
  
</code></pre>
</div></section>
<p>A region is seen as a set of points</p>
<p>Points inside the region are mapped to <em>true</em> and those outside are mapped to <em>false</em></p>
<p>For example, the universal region contains all points so it will always output true. On the other hand, the empty region does not
contain any point so it will always output false. </p>
<p>Also in circle, a point is seen is a part of the unit circle if the square sum of its components is less than or equal one.</p>
<p>In union, we can use characteristic functions of regions we want to combine to map all
points to true which are mapped to true by any of the composed regions.</p>
<section class="slide"><div class="section-body"><h1>The pretty printing trait</h1>
<pre><code class="Scala">trait Printing extends Regions {

type Region = String

  def univ : Region = &quot;univ&quot;
  def empty : Region = &quot;empty&quot;
  def circle : Region = &quot;circle&quot;
  def scale(v : Vector, x : Region) : Region
  = &quot;scale(&quot; + v + &quot;, &quot; + x + &quot;)&quot;

  def union(x : Region, y : Region) : Region
  = &quot;union(&quot; + x + &quot;, &quot; + y + &quot;)&quot;
}

object Print extends Printing
  
</code></pre>
</div></section>
<p>Mapping the domain type <em>Regions</em> to a string and ouputing the corresponding string representation for every operation.</p>
<section class="slide"><div class="section-body"><h1>Optimizing the <em>Regions</em> DSL</h1>
<pre><code class="Scala">trait Optimization extends Regions {

  val semantics : Regions

  type Region = (semantics.Region, boolean)

  def univ : Region = (semantics.univ, true)
  def empty : Region = (semantics.empty, false)
  def circle : Region = (semantics.circle, false)

  def scale(v : Vector, x : Region) : Region =
    if (x._2) (semantics.univ, true)
    else (semantics.scale(v, x._1), false)

  def union(x : Region, y : Region) : Region =
    if (x._2 || y._2) (semantics.univ, true)
    else (semantics.union(x._1, y._1), false)
}

// prints &quot;union(univ, scale((2.0,4.0), circle)&quot;
println(program(Print))

object OptimizePrint extends Optimization { val semantics = Print }

// prints &quot;(univ, true)&quot;
println(program(OptimizePrint))  
</code></pre>
</div></section>
<p>The <em>Region</em> here is represented as a pair of unoptimized region and a boolean value that indicates whether this region is statically known to be universal or not</p>
<p>For example, in the <em>union</em> operation, if any of the regions is the universal region then the resulting region is universal.</p>
<p>In the Optimization trait, the actual optimization is done in the <em>union</em> and <em>scale</em> operations. Where these operations can make use of the additional information
given in the <em>univ, empty and circle</em> regions to shorten evaluation paths.</p>
<p>Since the Optimization trait can work on any region semantics, therefore, it can work with the Pretty printing and optimization semantics defined before.</p>
<hr />
<p>[#Dijkstra:1972:HP:355604.361591]: <strong>E. W. Dijkstra</strong>; <em>The humble programmer</em>; Commun. ACM 15, 1972, <a href="http://doi.acm.org/10.1145/355604.361591">http://doi.acm.org/10.1145/355604.361591</a></p>
<p>[#Bloch:OOPSLA2006]: <strong>J. Bloch</strong>; <em>How to design a good API and why it matters</em>;  , 2006, <a href="http://doi.acm.org/10.1145/1176617.1176622">http://doi.acm.org/10.1145/1176617.1176622</a></p>
</div>
	<!-- START [FOOTER] - Automatically inserted by LectureDoc in generated HTML files.  -->	
	<script src="Library/LectureDoc/LectureDoc-Help.js" type="text/javascript"></script>

	<!-- END -->

</body></html>
